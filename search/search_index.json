{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#what-is-gradys-sim-nextgen","title":"What is GrADyS-SIM NextGen?","text":"<p>GrADyS-SIM NextGen is a network simulation framework. You can use this software to create simulations capable of representing scenarios populated by network nodes that coexist in a simulated environment and can send messages to each  other. The primary focuses of the simulator are usability and flexibility.  </p> <p>Usability is achieved by opting for a simple-to-use python simulation API  that allows you to quickly build and prototype decentralized algorithms in  a network simulation environment. Flexibility is achieved by enabling the  user to reuse his algorithm implementations on a more realistic network  simulation scenario by integrating with OMNeT++ and, in the future, even  reuse his algorithms in the real world through a MAVLINK integration.</p> <p>The framework was created to be used in three main ways: prototype mode, integrated mode and experiment mode. As mentioned one of the main features of this framework is that you can use the exact same implemented logic on all three modes, without changing a line of code. You can understand more about these modes in the execution mode documentation here.</p> <p>What's being executed in these three modes is a central piece of code called protocols. Protocols are user-defined classes that implement some kind of logic, they dictate the behaviour of a simulation node. A simulation node is an entity that exists within the simulation environment. It interacts with the environment through movement and with other nodes through network communication.</p> <p>The way protocols are build they can interact with the environment without being dependent on a specific environment implementation. They observe and act through interfaces provided to them during execution in a technique commonly called dependency injection. What this means is that you can re-utilize that same code in completely different environments as long as someone has done the work of integrating that environment with the interfaces that the protocol expects. GrADyS-SIM NextGen provides integrations to three environment types which are the previously mentioned modes.</p>"},{"location":"#history","title":"History","text":"<p>GrADyS is a project member of  a laboratory called LAC from PUC-Rio university.  Our main work is focused on exploring the coordination of autonomous vehicles through  descentralized algorithms.</p> <p>We created GrADyS-SIM to enable us to test our algorithms in a controlled, cheap and fast environment. Field tests are expensive and consume large amounts of time. Having a simulation environment helps us understand and validate things before we take them to the field.</p> <p>GrADyS-SIM was created first and foremost to serve as a tool for the GrADyS project. As we developed it we noticed that this could be a very useful tool not only for us but for the scientific community in general. </p> <p>GrADyS-SIM runs in the OMNeT++ which is an event-based  network simulator that enabled us to quickly model very complex network architectures  and test the effects ofdifferent scenarios, network protocols and components on our  algorithms. OMNeT++ although stillvery useful has a very steep learning curve, even  setting it up is a very involved process thatrequires specific setups to get it working  perfectly. Even for the people inside our project it is cumbersome to work with so we  concluded that some new tool needed to be built to remedy this.</p> <p>These were our motivations to create this tool. We are also taking extra care to make sure this won't be a tool only for the GrADyS project, but for anyone with similar interests to ours. This means creating a very general implementation that can be  used to implement all kinds of different ideas, instead of something focused only on our area of research.</p> <p>GrADyS-SIM-NextGen was envisoned as a low-dependency, light and easy to use simulator that would not substitute OMNeT++ but fill the niche of being a tool for quick prototyping  before more realistic results would be collected from OMNeT++. An issue we already had was translating results from the OMNeT++ simulation to the real world. Introducing a  new link in this chain would only make this disconnect between our imlpementation environments greather, so GrADyS-SIM NextGen would need to somehow generate code that could be run everywhere, in python, OMNeT++ and the real world. </p>"},{"location":"#what-should-i-expect-from-gradys-sim-nextgen","title":"What should I expect from GrADyS-SIM NextGen?","text":"<p>GrADyS-SIM NextGen is a tool for implementing and simulating decentralized  algorithms. It shines in simulating environment populated by nodes capable of communication and movement. In this dynamic environment you can implement algorithms that coordinate the movement of these nodes and the communication between them in order to achieve some goal. </p> <p>The simulator will help you to implement your algorithm's logic, testing it, validating it and understanding it. You will be able to see how your algorithm performs in situations analogous to the ones it would find in the real-world. This process will help you create more resilient, robust and efficient  algorithms that perform well within the constraints of the real world.</p> <p>GrADyS-SIM NextGen is a low-dependency, light and easy to use simulator. It was built with simplicity of use as a primary goal. If you want quick prototyping and testing of your algorithms, this is the tool for you. We also provide more complex tools that can be used to simulate more realistic scenarios, but they are not as easy to use as the prototype-mode simulator. The algorithm logic you implement in this simulator, which we tend to call \"protocols\", can be reused in any of our provided simulation environments and even in the real-world,  although this feature is not ready yet. All of this with no code adaptation necessary as the protocols run isolated to the code that make each of the environments work.</p>"},{"location":"framework/","title":"What's included?","text":"<p>When we talk about GrADyS-SIM NextGen as a simulation framework we are talking  about a set of tools that enable you to create and execute network simulations. These components are distributed under different repositories, and have  different purposes.</p> <p>Seeing all these components may seem overwhelming at first. This section aims to give you a high level overview of what each component does and how they interact with each other, and where you can read more about them.</p> <p></p>"},{"location":"framework/#the-gradysim-python-package","title":"The <code>gradysim</code> python package","text":"<p>The <code>gradysim</code> python package contains all the python implementations in the GrADyS-SIM NextGen framework. It is also responsible for hosting the  documentation you are reading. It is the main entry point for the framework and the place where you can find the most information about it. Any component that is hosted outside this repository will have a link to its documentation in this repository.</p> <p>The <code>gradysim</code> package is divided into three main subpackages: <code>protocol</code>, <code>simulator</code> and <code>encapsulator</code>. We will talk about each of them next.</p>"},{"location":"framework/#protocol","title":"<code>protocol</code>","text":"<p>The <code>protocol</code> subpackage specifies the Protocol API and it's dependencies.  You will use this packet to build your own protocols that are  environment-agnostic. This means that you can use the same protocol  implementation in different environments without changing your code.  These execution environments are often called execution modes inside the documentation.</p> <p>Inside this package you will find everything you need to build your own protocol. This includes the IProtocol interface that you extend to create your own protocol, the  IProvider interface that provides the means for your protocol to interact with it's environment and the  CommunicationCommand and MobilityCommand commands that your protocol needs to talk to the mobility and communication modules.</p> <p>Also included is a library of plugins intended to help developers build their protocols. These plugins enhance the experience of building protocols by  providing common functionalities that are often needed in protocols. You can read more about them in the plugins documentation.</p> <p>Info</p> <p>View the creating a protocol and the  implementation of a simulation scenario guides for  concrete examples of using this package. For a more in-depth view read the  documentation for the <code>protocol</code> subpackage here.</p>"},{"location":"framework/#simulator","title":"<code>simulator</code>","text":"<p>This package contains the code responsible for executing protocols in  prototype-mode. Implemented in it is a python event-based network simulator that is capable of executing protocols in a simulated environment. You can use this package to quickly prototype your protocols and test them in a simulated environment that is simpler than the one provided in the integrated mode.</p> <p>Simulations are capable of simulating the movement of nodes in a 3D space and the communication between nodes. The protocol interacts with the simulation environment through glue-code provided in the <code>encapsulator</code> package.</p> <p>Info</p> <p>Both the creating a protocol and the  implementation of a simulation scenario guides use the prototype-mode simulator to execute the protocols. You can read them to  understand how to use this package. For a more in-depth view read the  documentation for the <code>simulator</code> subpackage here.</p>"},{"location":"framework/#encapsulator","title":"<code>encapsulator</code>","text":"<p>The final subpackage in the <code>gradysim</code> package is the <code>encapsulator</code>. It is responsible for providing the glue-code that enables the protocols defined using the <code>protocol</code> package to interact with the simulation environment provided by the execution mode the protocol is being run in. This environment can be the prototype-mode simulator, the integrated-mode OMNeT++ or the experiment-mode.</p> <p>The IEncapsulator interface  defines the template that encapsulators must follow. Encapsulators connect  protocols to their execution environment by injecting the environment-specific provider instance into it. This provider instance will be used by the protocol to interact with the environment.</p> <p>Generally speaking, you shouldn't need to implement your own encapsulator. The framework provides encapsulators for the  prototype-mode simulator and  the integrated-mode's OMNeT++. </p> <p>Info</p> <p>Since as a normal user of the framework you shouldn't need to interact directly with this module, no guides for using it are provided. If you want an in depth view of how it works you can read the documentation for the <code>encapsulator</code> subpackage here. </p>"},{"location":"framework/#the-omnet-gradys-sim-simulator","title":"The OMNeT++ GrADyS-SIM Simulator","text":"<p>Before GrADyS-SIM NextGen was created, GrADyS-SIM already existed and was built using the OMNeT++ network simulator. In the context of OMNeT++ GrADyS-SIM is  a library of modules that enable you to build simulations inside OMNeT++ that work in a specific way. More specifically, they enable users to build and simulate network simulations populated by mobile vehicles and stationary nodes that all communicate with eachother so implement some kind of distributed  algorithm we call \"protocol\".</p> <p>It was created to satisfy the needs of the GrADyS project that aimed to  simulate scenarios where autonomous aerial vehicles would fly over stationary sensors to collect data and bring it to a stationary ground station. After realising how useful the architecture we built was, we decided to make it available to the public as a simulation framework which we called GrADyS-SIM.</p> <p>GrADyS-SIM NextGen is a continuation of this project. The focus of the framework turned to the python-implemented protocols and the new python and old OMNeT++ simulators are now viewed as environments where the protocols can execute in.</p> <p>The OMNeT++ framework is still available and is still being maintained. It can still be used independently but it has been integrated into the GrADyS-SIM NextGen framework to run as an execution-mode, integrated-mode. This means that your protocols written in python using the <code>protocol</code> package can run inside the OMNeT++ simulation which provides a more realistic network model.</p> <p>Info</p> <p>The OMNeT++ GrADyS-SIM Simulator is hosted in a separate repository. You can find it here.  There you will find installation instructions and a guide on how to use it to run your protocols in the integrated-mode. For a more in depth look you can read this technical report  describing the original simulation framework.</p>"},{"location":"framework/#integration-with-ardupilots-sitl-simulator","title":"Integration with Ardupilot's SITL Simulator","text":"<p>OMNeT++ and it's component library INET provides a very competent network model,  but it's model for mobility is very simplistic. Nodes move through very simple  arithmetics based on their speed, position and time since last update. An urge  for a more realistic simulation environment motivated the team to integrate the  OMNeT++ simulator with Ardupilot's SITL simulator. </p> <p>ArduPilot is an open source autopilot system supporting multi-copters, traditional helicopters, fixed wing aircraft, rovers and more. It's a very  popular autopilot system used in many different applications. The SITL Simulator is a simulator that is part of ArdiPilot's ecosystem that allows you to simulate the behaviour of real vehicles running ArduPilot. The simulated vehicles  communicate just like real ones through the MAVLink protocol. They also operate convincingly like their real counterparts, taking into account the physics of the vehicle and it's environment.</p> <p>Through the MAVLink protocol this simulator was integrated into GrADyS-SIM's OMNeT++ simulator. Using this integration the framework provides a mobility model superior to any available in INET. This integration is available in the integrated-mode of the framework. That means that you can use it to run your protocols in a more realistic environment.</p> <p>Info</p> <p>The integration with Ardupilot's SITL Simulator is hosted in a separate  repository. You can find it  here. There you will also find instructions in how to use it. In the past this project was hosted in a separate repository. You can find it  here.</p>"},{"location":"Getting%20Started/execution/","title":"Execution Modes","text":""},{"location":"Getting%20Started/execution/#prototype-mode","title":"Prototype mode","text":"<p>The user-defined protocol is executed in a very simple python event-based network simulator. The idea behind this mode is that it is very quick to set up, basically dependency free and very light. These characteristics make it perfect for prototyping and learning. Changes can be quickly implemented and tested and the simple nature of the simulator makes it a good learning tool for people unfamiliar with how these  distributed algorithms are typically implemented.</p> <p>The simulator doesn't offer many tools to accurately simulate a real-world simulation. This is an intentional decision to keep this execution mode as simple as possible.  You will be working with an abstraction, a simplified representation of the real world  that allows you to validate the protocol you implemented.</p> <p>Although simple don't underestimate how useful this execution mode is. The tools  provided can help validate your protocol under a surprising amount of conditions.  The instructions on how to use this mode and the full list of features are available in the documentation for the simulation module here.</p>"},{"location":"Getting%20Started/execution/#integrated-mode","title":"Integrated mode","text":"<p>Integrated mode uses the OMNeT++ network simulator to execute the user-defined  protocols in a realistic network simulation environment. The OMNeT++ simulation and integration are hosted in a different repository accesible  here. There you will find installation instructions and a guide on how to use it.</p>"},{"location":"Getting%20Started/execution/#experiment-mode","title":"Experiment mode","text":"<p>The idea behing this mode is allowing the user to run their protocols integrated with an actual real vehicle running Ardupilot.</p> <p>This mode has not been implemented yet. Check back later for updates!</p>"},{"location":"Getting%20Started/setup/","title":"Quick Setup","text":"<p>Setting up the python part of the simulation framework is easy, just install the python package using the following command:</p> <pre><code>pip install gradysim\n</code></pre> <p>With this python package you will be able to create import the project's  modules from the <code>gradysim</code> module. With this installation you will be able to create protocols and run them in prototype-mode.</p> <p>After setting this up check out the Creating a Protocol section to learn about  how the simulator works.</p>"},{"location":"Guides/1_creating/","title":"Creating a protocol","text":"<p>Info</p> <p>This guide will walk you through the process of creating a protocol and executing it using the simulator using prototype-mode.</p>"},{"location":"Guides/1_creating/#understanding-a-protocol","title":"Understanding a protocol","text":"<p>Protocols are classes that implements your algorithms main logic. The class is called protocol because it defines the behaviour protocol of the node. If you are satisfied with the simulation environment provided ready to use by GrADyS-SIM NextGen, this is the only class you need to code. You can use your protocol on any simulation environment. We will be using prototype mode to run a protocol within a python environment.</p> <p>Before building a protocol it is important to have a basic idea of what you are building. Protocols are classes that implement node behaviour on an event based environment. Event based means that you will program your logic in a reactive way. In other words the program's execution flow will only run code within your class when something happens to the node whose logic you are programming. This \"something\" can be a timer firing, a message being received or some information about your mobility being transferred to it. This is very similar to how user interfaces are build, they lay idle and react to user inputs.</p> <p></p> <p>Protocols have to inherit from the <code>IProtocol</code> class and implement the protocol interface this base class defines. These methods are called to react to some event relevant to the network node hosting your protocol. The logic of your protocol is implemented in these reactions.</p> <p>The protocol class itself does not handle communication or mobility, these are handled externally. Think of the protocol as the brains of the operation, issuing commands to these external modules that actually perform the actions.</p> <p>In order to issue these commands they have use to a set of methods accessible through a <code>IProvider</code> instance which is available through <code>self.provider</code> defined in the protocol base class. These methods are how the protocol interacts with its environment. Methods are available to send messages, move to specific places, schedule timers and more.</p>"},{"location":"Guides/1_creating/#building-our-first-protocol","title":"Building our first protocol","text":"counter_protocol.py<pre><code>import logging\n\nfrom gradysim.protocol.interface import IProtocol\nfrom gradysim.protocol.messages.telemetry import Telemetry\n\n\nclass CounterProtocol(IProtocol):\n    counter: int\n\n    def initialize(self):\n        # We initialize our counter at zero\n        self.counter = 0\n\n        # Using the protocol's provider to schedule a timer\n        self.provider.schedule_timer(\n            \"\",  # We don't care about the name since we're only going to use one\n            self.provider.current_time() + 1  # Scheduling it 1 second from now\n        )\n\n    def handle_timer(self, timer: str):\n        # Every time the timer fires we increment the counter\n        self.counter += 1\n\n        # And schedule a new one\n        self.provider.schedule_timer(\n            \"\",\n            self.provider.current_time() + 1\n        )\n\n    def handle_packet(self, message: str):\n        # We won't be receiving packets, so we don't care about this\n        pass\n\n    def handle_telemetry(self, telemetry: Telemetry):\n        # We don't care about mobility, so we are ignoring the received telemetry\n        pass\n\n    def finish(self):\n        # We print our final counter value at the end of the simulator\n        logging.info(f\"Final counter value: {self.counter}\")\n</code></pre> <p>The protocol above is very simple. All it does is use the provider methods available to the protocol to schedule a timer that fires every second. When this timer fires the protocol increments a counter and sets the timer again.</p> <p>Info</p> <p>Timers are a very important part of protocols. They are used to schedule events that will happen in the future. This is a very common pattern in distributed systems. Timers can be scheduled using the IProvider.schedule_timer method and cancelled using the IProvider.cancel_timer method.</p> <p>Now that we have created a protocol, we just have to execute it. As mentioned we will be using prototype mode for this example. Creating a simulation is  preferably done through the SimulationBuilder  class. This class presents a simple API for instantiating python simulations.</p> counter_execution.py<pre><code>from counter_protocol import CounterProtocol\nfrom gradysim.simulator.handler.timer import TimerHandler\nfrom gradysim.simulator.simulation import SimulationBuilder, SimulationConfiguration\n\n\ndef main():\n    # Configuring the simulator. The only option that interests us\n    # is limiting the simulator to 10 real-world seconds.\n    config = SimulationConfiguration(\n        duration=10\n    )\n    # Instantiating the simulator builder with the created config\n    builder = SimulationBuilder(config)\n\n    # Calling the add_node function we create a network node that\n    # will run the CounterProtocol we created.\n    builder.add_node(CounterProtocol, (0, 0, 0))\n\n    # Handlers enable certain simulator features. In the case of our\n    # simulator all we really need is a timer.\n    builder.add_handler(TimerHandler())\n\n    # Calling the build functions creates a simulator from the previously\n    # specified options.\n    simulation = builder.build()\n\n    # The start_simulation() method will run the simulator until our 10-second\n    # limit is reached.\n    simulation.start_simulation()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Danger</p> <p>This pattern of defining a main function and running it only if the file is being executed directly is required if you are using the VisualizationHandler as it will spawn a new process to run the visualization thread. We will use the visualization handler later so we are preparing for it. Read more about this in  the handler's documentation. </p> <p>Info</p> <p>A Simulator instance is returned  from the <code>build</code> method of the  SimulationBuilder class.  This instance is used to run the simulation. Both the  Simulator.start_simulation and the Simulator.start_simulation methods can be used to run the simulation. The first method will run the simulation until it ends, while the second will run it for a single iteration and return True if the simulation is not done.</p> <p>Running the file above we will notice the following output on our terminal:</p> Console output<pre><code>INFO     [--------- Simulation started ---------]\nINFO     [--------- Simulation finished ---------]\nINFO     [it=0 time=0:00:00 | Node 0 Finalization] Final counter value: 10\nINFO     Real time elapsed: 0:00:00.000195      Total iterations: 10    Simulation time: 0:00:10\n</code></pre> <p>We can see that the simulation ran for 10 simulation seconds which took 0.000195 real-world seconds to execute. In that time we ran 10 simulation iterations.  Remember that our CounterProtocol sets a timer for every second, so the number  of iterations is expected. What is also expected is the \"Final counter value\"  logged, which is 10.</p>"},{"location":"Guides/1_creating/#adding-communication","title":"Adding Communication","text":"<p>The last example, while useful to demonstrate how a protocol is the class that implements your logic in an event-based manner, didn't demonstrate one of the main features of the simulator: communication. One of the biggest challenges of building distributed systems is that they rely on asynchronous communication to share information between nodes.</p> <p>GrADyS-SIM NextGen will help you build these kinds of systems by providing support for communication between network nodes. Nodes share messages with each other by using communication commands that instruct their mobility modules to perform actions like broadcasting a message, sending one to a specific node or others.</p> counter_protocol.py<pre><code>import logging\n\nfrom gradysim.protocol.interface import IProtocol\nfrom gradysim.protocol.messages.communication import CommunicationCommand, CommunicationCommandType\nfrom gradysim.protocol.messages.telemetry import Telemetry\n\n\nclass CounterProtocol(IProtocol):\n    sent: int\n    received: int\n\n    def initialize(self):\n        # We initialize two counters: one for sent and one\n        # for received messages\n        self.sent = 0\n        self.received = 0\n\n        # Using the protocol's provider to schedule a timer\n        self.provider.schedule_timer(\n            \"\",  # We don't care about the name since we're only going to use one\n            self.provider.current_time() + 1  # Scheduling it 1 second from now\n        )\n\n    def handle_timer(self, timer: str):\n        # Every time the timer fires we increment the counter\n        self.sent += 1\n\n        # Creating a new communication command that will instruct the mobility module\n        # to broadcast a message\n        command = CommunicationCommand(\n            CommunicationCommandType.BROADCAST,\n            message=\"\"  # Content is irrelevant, we are only counting messages\n        )\n\n        # Sending the command\n        self.provider.send_communication_command(command)\n\n        # Scheduling a new timer\n        self.provider.schedule_timer(\n            \"\",\n            self.provider.current_time() + 1\n        )\n\n    def handle_packet(self, message: str):\n        # This time we care about received messages, we increment our received\n        # counter every time a new one arrives.\n        self.received += 1\n\n    def handle_telemetry(self, telemetry: Telemetry):\n        # We don't care about mobility, so we are ignoring the received telemetry\n        pass\n\n    def finish(self):\n        # We print our final counter value at the end of the simulator\n        logging.info(f\"Final counter values: \"\n                     f\"sent={self.sent} ; received={self.received}\")\n</code></pre> <p>To demonstrate communication we are now creating a simulation populated by  several network nodes. All of these nodes are periodically sending messages to  all the other ones. Each node keeps track of how many messages it has received  and sent.</p> counter_execution.py<pre><code>from counter_protocol import CounterProtocol\nfrom gradysim.simulator.handler.communication import CommunicationHandler\nfrom gradysim.simulator.handler.timer import TimerHandler\nfrom gradysim.simulator.simulation import SimulationBuilder, SimulationConfiguration\n\n\ndef main():\n    # Configuring the simulator. The only option that interests us\n    # is limiting the simulator to 10 real-world seconds.\n    config = SimulationConfiguration(\n        duration=10\n    )\n    # Instantiating the simulator builder with the created config\n    builder = SimulationBuilder(config)\n\n    # Calling the add_node function we create a network node that\n    # will run the CounterProtocol we created.\n    for _ in range(10):\n        builder.add_node(CounterProtocol, (0, 0, 0))\n\n    # Handlers enable certain simulator features. In the case of our\n    # simulator all we really need is a timer.\n    builder.add_handler(TimerHandler())\n    builder.add_handler(CommunicationHandler())\n\n    simulation = builder.build()\n    simulation.start_simulation()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>The result of executing this protocol is the following:</p> Console output<pre><code>INFO     [--------- Simulation started ---------]\nINFO     [--------- Simulation finished ---------]\nINFO     [it=0 time=0:00:00 | Node 0 Finalization] Final counter values: sent=10 ; received=90\nINFO     [it=0 time=0:00:00 | Node 1 Finalization] Final counter values: sent=10 ; received=90\nINFO     [it=0 time=0:00:00 | Node 2 Finalization] Final counter values: sent=10 ; received=90\nINFO     [it=0 time=0:00:00 | Node 3 Finalization] Final counter values: sent=10 ; received=90\nINFO     [it=0 time=0:00:00 | Node 4 Finalization] Final counter values: sent=10 ; received=90\nINFO     [it=0 time=0:00:00 | Node 5 Finalization] Final counter values: sent=10 ; received=90\nINFO     [it=0 time=0:00:00 | Node 6 Finalization] Final counter values: sent=10 ; received=90\nINFO     [it=0 time=0:00:00 | Node 7 Finalization] Final counter values: sent=10 ; received=90\nINFO     [it=0 time=0:00:00 | Node 8 Finalization] Final counter values: sent=10 ; received=90\nINFO     [it=0 time=0:00:00 | Node 9 Finalization] Final counter values: sent=10 ; received=90\nINFO     Real time elapsed: 0:00:00.004000  Total iterations: 1000  Simulation time: 0:00:10\n\nProcess finished with exit code 0\n</code></pre> <p>We can see that every node's timer fired 10 times, as expected from our last protocol. The interesting part is seeing that each node received 90 messages, 1  from every node other then itself 10 times.</p>"},{"location":"Guides/1_creating/#configuring-the-communication-medium","title":"Configuring the communication medium","text":"<p>An important part of developing distributed systems is thinking about  resiliency. A lot of times communication is flawed and messages fail to reach  their destination. In order to enable developers to validate their protocols the communication handleris configurable to enable certain restrictions to  communication, like adding delay, limiting the range of communication and adding  failures.</p> counter_execution.py<pre><code>from counter_protocol import CounterProtocol\nfrom gradysim.simulator.handler.communication import CommunicationMedium, CommunicationHandler\nfrom gradysim.simulator.handler.timer import TimerHandler\nfrom gradysim.simulator.simulation import SimulationBuilder, SimulationConfiguration\n\n\ndef main():\n    # This time we will be running the simulator for a longer time\n    # to help us visualize the effect of the medium configurations.\n    config = SimulationConfiguration(\n        duration=100\n    )\n\n    builder = SimulationBuilder(config)\n\n    # Adding 10 nodes all on (0, 0, 0)\n    for _ in range(10):\n        builder.add_node(CounterProtocol, (0, 0, 0))\n\n    # Adding a node far away, outside communication range from the others\n    builder.add_node(CounterProtocol, (50, 0, 0))\n\n    builder.add_handler(TimerHandler())\n\n    # Configuring a communication medium with limited transmission range,\n    # 1-second delay for message delivery and a 50% failure rate\n    medium = CommunicationMedium(\n        transmission_range=30,\n        delay=1,\n        failure_rate=0.5\n    )\n    builder.add_handler(CommunicationHandler(medium))\n\n    # Calling the build functions creates a simulator from the previously\n    # specified options.\n    simulation = builder.build()\n\n    # The start_simulation() method will run the simulator until our 10-second\n    # limit is reached.\n    simulation.start_simulation()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> Console output<pre><code>INFO     [--------- Simulation started ---------]\nINFO     [--------- Simulation finished ---------]\nINFO     [it=0 time=0:00:00 | Node 0 Finalization] Final counter values: sent=100 ; received=434\nINFO     [it=0 time=0:00:00 | Node 1 Finalization] Final counter values: sent=100 ; received=442\nINFO     [it=0 time=0:00:00 | Node 2 Finalization] Final counter values: sent=100 ; received=476\nINFO     [it=0 time=0:00:00 | Node 3 Finalization] Final counter values: sent=100 ; received=446\nINFO     [it=0 time=0:00:00 | Node 4 Finalization] Final counter values: sent=100 ; received=430\nINFO     [it=0 time=0:00:00 | Node 5 Finalization] Final counter values: sent=100 ; received=450\nINFO     [it=0 time=0:00:00 | Node 6 Finalization] Final counter values: sent=100 ; received=444\nINFO     [it=0 time=0:00:00 | Node 7 Finalization] Final counter values: sent=100 ; received=438\nINFO     [it=0 time=0:00:00 | Node 8 Finalization] Final counter values: sent=100 ; received=443\nINFO     [it=0 time=0:00:00 | Node 9 Finalization] Final counter values: sent=100 ; received=450\nINFO     [it=0 time=0:00:00 | Node 10 Finalization] Final counter values: sent=100 ; received=0\nINFO     Real time elapsed: 0:00:00.026000  Total iterations: 5553  Simulation time: 0:01:40\n</code></pre> <p>Let's analyse these numbers. We have 11 nodes sending messages for 100 seconds so without any restrictions we would expect each node to receive 1000 messages.  Let's now account for the restrictions:</p> <ul> <li>One of the nodes is away from communication range. It should receive 0   messages while all the   others should receive 900 messages</li> <li>We have a 10-second communication delay, this means that only 99 seconds worth   of messages will   actually reach their targets. Each node should receive 9 * 99 = 891 messages</li> <li>There is a 50% failure rate for the delivery of every message. This means that   each node should   receive an average of 891 / 2 = 445.5 messages.</li> </ul> <p>As you can see the actual values are very close to our expectancy. The failure rate is probabilistic so that accounts for the small differences we see, but the  average of every node's received messages is still very close the expected  value.</p>"},{"location":"Guides/1_creating/#introducing-mobility","title":"Introducing mobility","text":"<p>In distributed systems network nodes are not always static, they sometimes move. An example of this are mobile networks, or communication-capable vehicles. For  this use case we provide the MobilityHandler. Nodes can control their movement  by sending mobility commands using their<code>IProvider</code> instance. If a mobility  handler is present these commands will be translated to movement.</p> counter_protocol.py<pre><code>import logging\nimport random\n\nfrom gradysim.protocol.interface import IProtocol\nfrom gradysim.protocol.messages.communication import BroadcastMessageCommand\nfrom gradysim.protocol.messages.mobility import GotoCoordsMobilityCommand\nfrom gradysim.protocol.messages.telemetry import Telemetry\n\n\nclass CounterProtocol(IProtocol):\n    sent: int\n    received: int\n\n    def initialize(self):\n        # We initialize two counters: one for sent and one\n        # for received messages\n        self.sent = 0\n        self.received = 0\n\n        # Using the protocol's provider to schedule a timer\n        self.provider.schedule_timer(\n            \"message\",  # We don't care about the name since we're only going to use one\n            self.provider.current_time() + 1  # Scheduling it 1 second from now\n        )\n\n        self.provider.schedule_timer(\n            \"mobility\",  # We don't care about the name since we're only going to use one\n            self.provider.current_time() + 5  # Scheduling it 1 second from now\n        )\n\n    def handle_timer(self, timer: str):\n        if timer == \"message\":\n            # Every time the timer fires we increment the counter\n            self.sent += 1\n\n            # Creating a new communication command that will instruct the mobility module\n            # to broadcast a message\n            command = BroadcastMessageCommand(\n                message=\"\"  # Content is irrelevant, we are only counting messages\n            )\n\n            # Sending the command\n            self.provider.send_communication_command(command)\n\n            # Scheduling a new timer\n            self.provider.schedule_timer(\n                \"message\",\n                self.provider.current_time() + 1\n            )\n        else:\n            # Issuing a GOTO_COORDS command. Mobility commands have dynamic parameters\n            # so subclasses are provided for every command type to help you create them\n            # with proper typing support\n            command = GotoCoordsMobilityCommand(\n                random.uniform(-50, 50),\n                random.uniform(-50, 50),\n                random.uniform(0, 50)\n            )\n            self.provider.send_mobility_command(command)\n\n            # Scheduling a new timer\n            self.provider.schedule_timer(\n                \"mobility\",\n                self.provider.current_time() + 5\n            )\n\n    def handle_packet(self, message: str):\n        # This time we care about received messages, we increment our received\n        # counter every time a new one arrives.\n        self.received += 1\n\n    def handle_telemetry(self, telemetry: Telemetry):\n        # We don't care about mobility, so we are ignoring the received telemetry\n        pass\n\n    def finish(self):\n        # We print our final counter value at the end of the simulator\n        logging.info(f\"Final counter values: \"\n                     f\"sent={self.sent} ; received={self.received}\")\n</code></pre> <p>As you can see we have modified our protocol to add a second timer. Since we now have concurrent timers we need to name them to use them properly. For the new mobility timer we are issuing a command to move the node to a random location every 5 seconds. When a new command is issued the previous target gets overriden.</p> counter_execution.py<pre><code>from counter_protocol import CounterProtocol\nfrom gradysim.simulator.handler.communication import CommunicationMedium, CommunicationHandler\nfrom gradysim.simulator.handler.mobility import MobilityHandler\nfrom gradysim.simulator.handler.timer import TimerHandler\nfrom gradysim.simulator.simulation import SimulationBuilder, SimulationConfiguration\n\n\ndef main():\n    config = SimulationConfiguration(\n        duration=100\n    )\n    builder = SimulationBuilder(config)\n\n    # Adding 10 nodes on (0, 0, 0)\n    for _ in range(10):\n        builder.add_node(CounterProtocol, (0, 0, 0))\n\n    builder.add_handler(TimerHandler())\n\n    # We will limit the communication range.\n    # This will help us see the effect of mobility on\n    # the nodes' position.\n    medium = CommunicationMedium(\n        transmission_range=30\n    )\n\n    builder.add_handler(CommunicationHandler(medium))\n\n    # Adding mobility handler\n    builder.add_handler(MobilityHandler())\n\n    simulation = builder.build()\n    simulation.start_simulation()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>We configured the <code>MobilityHandler</code> and set our communication medium to a short range. Since the range of motion for our nodes is from [-50, 50] and the communication range is only 30, we expect to see erratic values on the nodes' received counters as many will be out of range relative to others.</p> Console output<pre><code>INFO     [--------- Simulation started ---------]\nINFO     [--------- Simulation finished ---------]\nINFO     [it=0 time=0:00:00 | Node 0 Finalization] Final counter values: sent=100 ; received=748\nINFO     [it=0 time=0:00:00 | Node 1 Finalization] Final counter values: sent=100 ; received=767\nINFO     [it=0 time=0:00:00 | Node 2 Finalization] Final counter values: sent=100 ; received=810\nINFO     [it=0 time=0:00:00 | Node 3 Finalization] Final counter values: sent=100 ; received=754\nINFO     [it=0 time=0:00:00 | Node 4 Finalization] Final counter values: sent=100 ; received=748\nINFO     [it=0 time=0:00:00 | Node 5 Finalization] Final counter values: sent=100 ; received=800\nINFO     [it=0 time=0:00:00 | Node 6 Finalization] Final counter values: sent=100 ; received=764\nINFO     [it=0 time=0:00:00 | Node 7 Finalization] Final counter values: sent=100 ; received=765\nINFO     [it=0 time=0:00:00 | Node 8 Finalization] Final counter values: sent=100 ; received=746\nINFO     [it=0 time=0:00:00 | Node 9 Finalization] Final counter values: sent=100 ; received=766\nINFO     Real time elapsed: 0:00:00.155505  Total iterations: 18867 Simulation time: 0:01:40\n</code></pre> <p>The results are as expected, every onde sent 100 messages but their received counter is not 900, since many messages fall out of communication range and are  not delivered.</p>"},{"location":"Guides/1_creating/#adding-visualization","title":"Adding visualization","text":"<p>Looking at the console output we see that the nodes are probably moving, but a lot of times it is useful to properly see what's happening in the simulation.  The <code>VisualizationHandler</code> was created for this purpose. All we need to do to use it is add this handler to our execution. </p> <p>The visualization handler works by starting a websocket server on a separate process that will serve data about the visualization status to a web page client. This web page can be automatically opened by the handler by setting the <code>open_browser</code> parameter to <code>True</code> on the handler's configuration. The web page will show the nodes' position and some other basic information about the simulation. </p> <p>Another feature of the visualization is the ability of controlling aspects of the visualization from your protocol through the VisualizationController.  You can use this to visually display information about your protocol's state.  In this case we will be using it to display the node's received messages as a  color gradient from black to red.</p> <p>Warning</p> <p>The <code>VisualizationController</code> only runs when the protocol is running in the python simulator, in prototype-mode. There is no need to modify your protocol when running it in another environment, all the visualization commands will be ignored in that case.</p> <p>The web page interface can be accessed anytime on  this URL. The visualization will automatically connect to the websocket server once you start the simulation.</p> counter_execution.py<pre><code>from counter_protocol import CounterProtocol\nfrom gradysim.simulator.handler.communication import CommunicationMedium, CommunicationHandler\nfrom gradysim.simulator.handler.mobility import MobilityHandler\nfrom gradysim.simulator.handler.timer import TimerHandler\nfrom gradysim.simulator.handler.visualization import VisualizationHandler\nfrom gradysim.simulator.simulation import SimulationBuilder, SimulationConfiguration\n\n\ndef main():\n    # To enhance our viewing experience we are setting the simulator\n    # to real-time mode. This means that the simulator will run\n    # approximately synchronized with real-time, enabling us to see\n    # the nodes moving properly. We are also decreasing the total\n    # simulator time, so we don't have to wait for that long\n    config = SimulationConfiguration(\n        duration=30,\n        real_time=True\n    )\n    builder = SimulationBuilder(config)\n\n    for _ in range(10):\n        builder.add_node(CounterProtocol, (0, 0, 0))\n\n    builder.add_handler(TimerHandler())\n\n    medium = CommunicationMedium(\n        transmission_range=30\n    )\n    builder.add_handler(CommunicationHandler(medium))\n\n    builder.add_handler(MobilityHandler())\n\n    # Adding visualization handler to the simulator\n    builder.add_handler(VisualizationHandler())\n\n    simulation = builder.build()\n    simulation.start_simulation()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>When we execute this example a window will open showing the node's position in real-time while the simulation is running.</p> <p>Warning</p> <p>Take a look at the  visualization handler's documentation for a better and more up-to-date overview of the visualization interface's capabilities. The video presented above may not  reflect the current state of the visualization interface, as it is constantly being improved.</p>"},{"location":"Guides/1_creating/#making-sure-your-protocol-works","title":"Making sure your protocol works","text":"<p>One of the main points of even creating simulations is validating your  implementations. Looking at the console output and visualization are good ways of doing that, but they may not be reliable methods when we are dealing with  complex scenarios.</p> <p>For this use case the <code>AssertionHandler</code> is perfect as it enables the user to write assertions (basically functions that return a boolean) that get validated at runtime. Assertions can be evaluated on a individual level or simulation-wide.</p> counter_execution.py<pre><code>import math\n\nfrom counter_protocol import CounterProtocol\nfrom gradysim.simulator.handler.assertion import assert_always_true_for_protocol, AssertionHandler\nfrom gradysim.simulator.handler.communication import CommunicationHandler\nfrom gradysim.simulator.handler.mobility import MobilityHandler\nfrom gradysim.simulator.handler.timer import TimerHandler\nfrom gradysim.simulator.node import Node\nfrom gradysim.simulator.simulation import SimulationBuilder, SimulationConfiguration\n\n\ndef main():\n    # Trying a much larger simulator to illustrate a scenario\n    # where visual evaluation would be hard\n    config = SimulationConfiguration(\n        duration=10000\n    )\n    builder = SimulationBuilder(config)\n\n    for _ in range(10):\n        builder.add_node(CounterProtocol, (0, 0, 0))\n\n    builder.add_handler(TimerHandler())\n    builder.add_handler(CommunicationHandler())\n    builder.add_handler(MobilityHandler())\n\n    # Creating an assertion that checks if the number of received\n    # messages is plausible. Since nodes send a message very second\n    # it can't possibly be larger than 9 times the current time.\n    @assert_always_true_for_protocol(CounterProtocol,\n                                     name=\"received_is_plausible\",\n                                     description=\"The received messages can't possibly be \"\n                                                 \"bigger than 9 * current_time\")\n    def assert_received_is_plausible(node: Node[CounterProtocol]):\n        protocol_instance = node.protocol_encapsulator.protocol\n        current_time = protocol_instance.provider.current_time()\n        received = protocol_instance.received\n        return received &lt;= math.floor(current_time) * 9\n\n    # Adding an assertion handler, it receives all the desired\n    # assertions as parameters.\n    builder.add_handler(AssertionHandler([assert_received_is_plausible]))\n\n    simulation = builder.build()\n    simulation.start_simulation()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> Console output<pre><code>INFO     [--------- Simulation started ---------]\nINFO     [--------- Simulation finished ---------]\nINFO     [it=0 time=0:00:00 | Node 0 Finalization] Final counter values: sent=10000 ; received=75026\nINFO     [it=0 time=0:00:00 | Node 1 Finalization] Final counter values: sent=10000 ; received=75171\nINFO     [it=0 time=0:00:00 | Node 2 Finalization] Final counter values: sent=10000 ; received=74901\nINFO     [it=0 time=0:00:00 | Node 3 Finalization] Final counter values: sent=10000 ; received=75065\nINFO     [it=0 time=0:00:00 | Node 4 Finalization] Final counter values: sent=10000 ; received=75262\nINFO     [it=0 time=0:00:00 | Node 5 Finalization] Final counter values: sent=10000 ; received=75176\nINFO     [it=0 time=0:00:00 | Node 6 Finalization] Final counter values: sent=10000 ; received=74931\nINFO     [it=0 time=0:00:00 | Node 7 Finalization] Final counter values: sent=10000 ; received=74595\nINFO     [it=0 time=0:00:00 | Node 8 Finalization] Final counter values: sent=10000 ; received=75302\nINFO     [it=0 time=0:00:00 | Node 9 Finalization] Final counter values: sent=10000 ; received=75165\nINFO     Real time elapsed: 0:00:23.687526  Total iterations: 1870593   Simulation time: 2:46:40\n</code></pre> <p>If an assertion error happened the simulation would be interrupted and  information about the failure location and time would be displayed. Accurately  naming and adding descriptions to your assertions can enhance the interpretation of the generated errors. Since no assertion error happens we can be sure that  the simulation is working properly.</p>"},{"location":"Guides/2_simple/","title":"Simulating a data collection scenario","text":"<p>Info</p> <p>This guide will step through the complete implementation of a protocol and execution in prototype-mode.</p> Full code of the protocols implemented in this guide <pre><code>import enum\nimport json\nimport logging\nfrom typing import TypedDict\n\nfrom gradysim.protocol.interface import IProtocol\nfrom gradysim.protocol.messages.communication import SendMessageCommand, BroadcastMessageCommand\nfrom gradysim.protocol.messages.telemetry import Telemetry\nfrom gradysim.protocol.plugin.mission_mobility import MissionMobilityPlugin, MissionMobilityConfiguration, LoopMission\n\n\n\nclass SimpleSender(enum.Enum):\n    SENSOR = 0\n    UAV = 1\n    GROUND_STATION = 2\n\n\nclass SimpleMessage(TypedDict):\n    packet_count: int\n    sender_type: int\n    sender: int\n\n\ndef report_message(message: SimpleMessage) -&gt; str:\n    return (f\"Received message with {message['packet_count']} packets from \"\n            f\"{SimpleSender(message['sender_type']).name} {message['sender']}\")\n\n\nclass SimpleSensorProtocol(IProtocol):\n    _log: logging.Logger\n    packet_count: int\n\n    def initialize(self) -&gt; None:\n        self._log = logging.getLogger()\n        self.packet_count = 0\n\n        self._generate_packet()\n\n    def _generate_packet(self) -&gt; None:\n        self.packet_count += 1\n        self._log.info(f\"Generated packet, current count {self.packet_count}\")\n        self.provider.schedule_timer(\"\", self.provider.current_time() + 1)\n\n    def handle_timer(self, timer: str) -&gt; None:\n        self._generate_packet()\n\n    def handle_packet(self, message: str) -&gt; None:\n        simple_message: SimpleMessage = json.loads(message)\n        self._log.info(report_message(simple_message))\n\n        if simple_message['sender_type'] == SimpleSender.UAV.value:\n            response: SimpleMessage = {\n                'packet_count': self.packet_count,\n                'sender_type': SimpleSender.SENSOR.value,\n                'sender': self.provider.get_id()\n            }\n\n            command = SendMessageCommand(json.dumps(response), simple_message['sender'])\n            self.provider.send_communication_command(command)\n\n            self._log.info(f\"Sent {response['packet_count']} packets to UAV {simple_message['sender']}\")\n\n            self.packet_count = 0\n\n    def handle_telemetry(self, telemetry: Telemetry) -&gt; None:\n        pass\n\n    def finish(self) -&gt; None:\n        self._log.info(f\"Final packet count: {self.packet_count}\")\n\n\nmission_list = [\n    [\n        (0, 0, 20),\n        (150, 0, 20)\n    ],\n    [\n        (0, 0, 20),\n        (0, 150, 20)\n    ],\n    [\n        (0, 0, 20),\n        (-150, 0, 20)\n    ],\n    [\n        (0, 0, 20),\n        (0, -150, 20)\n    ]\n]\n\n\nclass SimpleUAVProtocol(IProtocol):\n    _log: logging.Logger\n\n    packet_count: int\n\n    _mission: MissionMobilityPlugin\n\n    def initialize(self) -&gt; None:\n        self._log = logging.getLogger()\n        self.packet_count = 0\n\n        self._mission = MissionMobilityPlugin(self, MissionMobilityConfiguration(\n            loop_mission=LoopMission.REVERSE,\n        ))\n\n        self._mission.start_mission(mission_list.pop())\n\n        self._send_heartbeat()\n\n    def _send_heartbeat(self) -&gt; None:\n        self._log.info(f\"Sending heartbeat, current count {self.packet_count}\")\n\n        message: SimpleMessage = {\n            'packet_count': self.packet_count,\n            'sender_type': SimpleSender.UAV.value,\n            'sender': self.provider.get_id()\n        }\n        command = BroadcastMessageCommand(json.dumps(message))\n        self.provider.send_communication_command(command)\n\n        self.provider.schedule_timer(\"\", self.provider.current_time() + 1)\n\n    def handle_timer(self, timer: str) -&gt; None:\n        self._send_heartbeat()\n\n    def handle_packet(self, message: str) -&gt; None:\n        simple_message: SimpleMessage = json.loads(message)\n        self._log.info(report_message(simple_message))\n\n        if simple_message['sender_type'] == SimpleSender.SENSOR.value:\n            self.packet_count += simple_message['packet_count']\n            self._log.info(f\"Received {simple_message['packet_count']} packets from \"\n                           f\"sensor {simple_message['sender']}. Current count {self.packet_count}\")\n        elif simple_message['sender_type'] == SimpleSender.GROUND_STATION.value:\n            self._log.info(\"Received acknowledgment from ground station\")\n            self.packet_count = 0\n\n    def handle_telemetry(self, telemetry: Telemetry) -&gt; None:\n        pass\n\n    def finish(self) -&gt; None:\n        self._log.info(f\"Final packet count: {self.packet_count}\")\n\n\nclass SimpleGroundStationProtocol(IProtocol):\n    _log: logging.Logger\n    packet_count: int\n\n    def initialize(self) -&gt; None:\n        self._log = logging.getLogger()\n        self.packet_count = 0\n\n    def handle_timer(self, timer: str) -&gt; None:\n        pass\n\n    def handle_packet(self, message: str) -&gt; None:\n        simple_message: SimpleMessage = json.loads(message)\n        self._log.info(report_message(simple_message))\n\n        if simple_message['sender_type'] == SimpleSender.UAV.value:\n            response: SimpleMessage = {\n                'packet_count': self.packet_count,\n                'sender_type': SimpleSender.GROUND_STATION.value,\n                'sender': self.provider.get_id()\n            }\n\n            command = SendMessageCommand(json.dumps(response), simple_message['sender'])\n            self.provider.send_communication_command(command)\n\n            self.packet_count += simple_message['packet_count']\n            self._log.info(f\"Sent acknowledgment to UAV {simple_message['sender']}. Current count {self.packet_count}\")\n\n    def handle_telemetry(self, telemetry: Telemetry) -&gt; None:\n        pass\n\n    def finish(self) -&gt; None:\n        self._log.info(f\"Final packet count: {self.packet_count}\")\n</code></pre> Full code needed to execute this example <pre><code>from gradysim.simulator.handler.communication import CommunicationHandler, CommunicationMedium\nfrom gradysim.simulator.handler.mobility import MobilityHandler\nfrom gradysim.simulator.handler.timer import TimerHandler\nfrom gradysim.simulator.handler.visualization import VisualizationHandler, VisualizationConfiguration\nfrom gradysim.simulator.simulation import SimulationBuilder, SimulationConfiguration\nfrom simple_protocol import SimpleSensorProtocol, SimpleGroundStationProtocol, SimpleUAVProtocol\n\n\ndef main():\n    # Configuring simulation\n    config = SimulationConfiguration(\n        duration=200\n    )\n    builder = SimulationBuilder(config)\n\n    # Instantiating 4 sensors in fixed positions\n    builder.add_node(SimpleSensorProtocol, (150, 0, 0))\n    builder.add_node(SimpleSensorProtocol, (0, 150, 0))\n    builder.add_node(SimpleSensorProtocol, (-150, 0, 0))\n    builder.add_node(SimpleSensorProtocol, (0, -150, 0))\n\n    # Instantiating 4 UAVs at (0,0,0)\n    builder.add_node(SimpleUAVProtocol, (0, 0, 0))\n    builder.add_node(SimpleUAVProtocol, (0, 0, 0))\n    builder.add_node(SimpleUAVProtocol, (0, 0, 0))\n    builder.add_node(SimpleUAVProtocol, (0, 0, 0))\n\n    # Instantiating ground station at (0,0,0)\n    builder.add_node(SimpleGroundStationProtocol, (0, 0, 0))\n\n    # Adding required handlers\n    builder.add_handler(TimerHandler())\n    builder.add_handler(CommunicationHandler(CommunicationMedium(\n        transmission_range=30\n    )))\n    builder.add_handler(MobilityHandler())\n    builder.add_handler(VisualizationHandler(VisualizationConfiguration(\n        x_range=(-150, 150),\n        y_range=(-150, 150),\n        z_range=(0, 150)\n    )))\n\n    # Building &amp; starting\n    simulation = builder.build()\n    simulation.start_simulation()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"Guides/2_simple/#scenario-description","title":"Scenario description","text":"<p>We have sensors spread around some location. These sensors collect information about their local  environment which is of interest to us. The deployment location has no communication infrastructure and is hard to  access, so to get the information out of these sensors we will employ a UAV swarm. The UAVs will fly autonomously to  the deployment location, retrieve data from the sensors through local communication and fly back to a central ground station where the data will be offloaded and analysed. </p> <p>The number of UAVs that are available for this mission is equal to the number of sensors deployed in the field, thus  each UAV will only monitor one sensor.</p> <p>Here is some additional information about the scenario's requirements:</p> <ul> <li>UAVs should continuously fly between the deployment location and the ground station</li> <li>Sensors are continuously collecting data and generate new packets periodically at a steady rate</li> <li>Every packet a sensor has will be transferred once a UAV makes contact with it</li> <li>There is no limit to how many packets any agent can carry</li> <li>The ground station is effectively a packet sink</li> <li>Communication is local and it's range is limited</li> </ul>"},{"location":"Guides/2_simple/#designing-the-simulation","title":"Designing the simulation","text":"<p>We have three different types of agents in this scenario: sensors, UAVs and the ground station. Since each agent type behaves differently, three protocol classes will be created. The protocols that will implement the agent type behaviours are very simple and can each be described in a couple of  steps:</p> Sensor protocol<pre><code>1. Periodically generates packets and stores them\n2. Listens for any UAV messages and responds by sending to the UAV every packet \n   stored in the sensor\n</code></pre> UAV protocol<pre><code>1. Repeatedly flies between the ground station and a sensor\n2. Periodically tries to communicate with nearby agents, advertising the number \n   of packets it contains\n3. Stores packets received from sensors\n4. Drops packets after sending them to the ground station\n</code></pre> Ground station protocol<pre><code>1. Listens for any UAV communication and absorbs their packets\n2. Responds to the sender UAV confirming that their packets were received\n</code></pre> <p>Although independent the three protocol types will need to communicate to complete their task. In GrADyS-SIM NextGen communication is done through messages containing a string payload. In order to facilitate implementation we need to define a common message format that is serializable and has every field necessary for communication. </p> <p>Interactions in the protocols above are defined between agent types, <code>UAV &lt;-&gt; sensor</code> and <code>UAV &lt;-&gt; ground station</code>  message exchanges are handled in different ways. So, if we want to use a common message format, we need to include  the agent type in the format to allow these interactions to be defined. </p> <p>Protocols talk to each other in a request-response manner, generally with the UAV initiating the exchange. In order to know who to respond to we need to have the agent id in  the message definition.</p> <p>Finally, in our interactions the sensor transmits packets to the UAVs, and they transmit packets to the ground station.  We need to know the agent's packet count in order to implement the transmission.</p>"},{"location":"Guides/2_simple/#implementing-the-protocols","title":"Implementing the protocols","text":"<p>With our requirements ready all that is left is translating all this into protocol code. Our use-case is very simple so it will be easy to present the code step-by-step. Let's first show the SimpleMessage implementation. Following our requirements we implemented the simple message as a dictionary. In order to have typing hints we create a <code>TypedDict</code> class containing the desired fields. GrADyS-SIM NextGen doesn't impose any </p> Message declaration<pre><code>class SimpleMessage(TypedDict):\n    packet_count: int\n    sender_type: int\n    sender: int\n</code></pre> <p>To identify the types of agents in our simulation we will use the <code>SimpleSender</code> enum shown below. </p> SimpleSender enum<pre><code>class SimpleSender(enum.Enum):\n    SENSOR = 0\n    UAV = 1\n    GROUND_STATION = 2\n</code></pre> <p>To help us with logging a <code>report_message</code> function is defined. It receives a SimpleMessage and appropriately logs it.</p> Message logging<pre><code>class SimpleMessage(TypedDict):\n    packet_count: int\n    sender_type: int\n    sender: int\n</code></pre>"},{"location":"Guides/2_simple/#sensor","title":"Sensor","text":"<p>The first protocol we will implement in the sensor is the periodic data generation. Below is a snippet from the protocol's initialize method, we are storing the generated packets in the <code>self.packet_count</code> variable, at simulation start 0  packets are in storage. The <code>_generate_packet</code> method increments this counter by one and schedules a timer for  one second later. The <code>handle_timer</code> is called when this timer fires and in turn calls the <code>_generate_packet</code> method again. This creates an infinite loop which with a periodicity of 1 second increments the packet counter.</p> Sensor initialization and timer<pre><code>    def initialize(self) -&gt; None:\n        self.packet_count = 0\n\n        self._generate_packet()\n\n    def _generate_packet(self) -&gt; None:\n        self.packet_count += 1\n        self.provider.schedule_timer(\"\", self.provider.current_time() + 1)\n\n    def handle_timer(self, timer: str) -&gt; None:\n        self._generate_packet()\n</code></pre> <p>Next we need to implement the interaction with other modules. The <code>handle_packet</code> method will be called when a message is recieved from another module. This missage will be a SimpleMessage and needs to be deserialized. The only relevant interaction in the sensor is with an UAV, so we will only implement that. The code below shows a snipped from the  <code>handle_packet</code> method. After receiving a message from a UAV the sensor will send every one of its packets to the UAV and zero out the <code>self.packet_count</code> counter.</p> Sensor interactions<pre><code>    def handle_packet(self, message: str) -&gt; None:\n        simple_message: SimpleMessage = json.loads(message)\n\n        if simple_message['sender_type'] == SimpleSender.UAV.value:\n            response: SimpleMessage = {\n                'packet_count': self.packet_count,\n                'sender_type': SimpleSender.SENSOR.value,\n                'sender': self.provider.get_id()\n            }\n\n            command = SendMessageCommand(json.dumps(response), simple_message['sender'])\n            self.provider.send_communication_command(command)\n\n            self._log.info(f\"Sent {response['packet_count']} packets to UAV {simple_message['sender']}\")\n\n            self.packet_count = 0\n</code></pre> Full sensor code <pre><code>class SimpleSensorProtocol(IProtocol):\n    _log: logging.Logger\n    packet_count: int\n\n    def initialize(self) -&gt; None:\n        self._log = logging.getLogger()\n        self.packet_count = 0\n\n        self._generate_packet()\n\n    def _generate_packet(self) -&gt; None:\n        self.packet_count += 1\n        self._log.info(f\"Generated packet, current count {self.packet_count}\")\n        self.provider.schedule_timer(\"\", self.provider.current_time() + 1)\n\n    def handle_timer(self, timer: str) -&gt; None:\n        self._generate_packet()\n\n    def handle_packet(self, message: str) -&gt; None:\n        simple_message: SimpleMessage = json.loads(message)\n        self._log.info(report_message(simple_message))\n\n        if simple_message['sender_type'] == SimpleSender.UAV.value:\n            response: SimpleMessage = {\n                'packet_count': self.packet_count,\n                'sender_type': SimpleSender.SENSOR.value,\n                'sender': self.provider.get_id()\n            }\n\n            command = SendMessageCommand(json.dumps(response), simple_message['sender'])\n            self.provider.send_communication_command(command)\n\n            self._log.info(f\"Sent {response['packet_count']} packets to UAV {simple_message['sender']}\")\n\n            self.packet_count = 0\n\n    def handle_telemetry(self, telemetry: Telemetry) -&gt; None:\n        pass\n\n    def finish(self) -&gt; None:\n        self._log.info(f\"Final packet count: {self.packet_count}\")\n</code></pre>"},{"location":"Guides/2_simple/#ground-station","title":"Ground Station","text":"<p>The ground station is the second protocol we will implement. It is even more simple them the sensor since it doesn't require any periodic timer to function. The snipped below covers the initialization of a <code>self.packet_count</code> property storing the number of packets that have been delivered to the ground station and the definition of the <code>handle_packet</code> method. The handling behaviour only cares about messages that came from UAVs, when received the ground station adds the packets the UAV contains to its packet count and sends a message back to the UAV, so it can know his packets have been delivered.</p> Ground station initialization and interactions<pre><code>    def initialize(self) -&gt; None:\n        self.packet_count = 0\n\n    def handle_packet(self, message: str) -&gt; None:\n        simple_message: SimpleMessage = json.loads(message)\n\n        if simple_message['sender_type'] == SimpleSender.UAV.value:\n            response: SimpleMessage = {\n                'packet_count': self.packet_count,\n                'sender_type': SimpleSender.GROUND_STATION.value,\n                'sender': self.provider.get_id()\n            }\n\n            command = SendMessageCommand(json.dumps(response), simple_message['sender'])\n            self.provider.send_communication_command(command)\n\n            self.packet_count += simple_message['packet_count']\n</code></pre> Full ground station code <pre><code>class SimpleGroundStationProtocol(IProtocol):\n    _log: logging.Logger\n    packet_count: int\n\n    def initialize(self) -&gt; None:\n        self._log = logging.getLogger()\n        self.packet_count = 0\n\n    def handle_timer(self, timer: str) -&gt; None:\n        pass\n\n    def handle_packet(self, message: str) -&gt; None:\n        simple_message: SimpleMessage = json.loads(message)\n        self._log.info(report_message(simple_message))\n\n        if simple_message['sender_type'] == SimpleSender.UAV.value:\n            response: SimpleMessage = {\n                'packet_count': self.packet_count,\n                'sender_type': SimpleSender.GROUND_STATION.value,\n                'sender': self.provider.get_id()\n            }\n\n            command = SendMessageCommand(json.dumps(response), simple_message['sender'])\n            self.provider.send_communication_command(command)\n\n            self.packet_count += simple_message['packet_count']\n            self._log.info(f\"Sent acknowledgment to UAV {simple_message['sender']}. Current count {self.packet_count}\")\n\n    def handle_telemetry(self, telemetry: Telemetry) -&gt; None:\n        pass\n\n    def finish(self) -&gt; None:\n        self._log.info(f\"Final packet count: {self.packet_count}\")\n</code></pre>"},{"location":"Guides/2_simple/#uav","title":"UAV","text":"<p>The UAV protocol is the most complicated one as it has to interact to both sensors and the ground station. It also needs to periodically broadcast the number of packets it has to initiate interactions with other agents. The snipped bellow illustrates the protocol's initialization and this timer, it is implemented in a similar way to the sensor packet  generation timer. The <code>_send_heartbeat</code> function implements a recurrent timer with a periodicity of 1 second that  broadcasts the message.</p> UAV initialization and timer<pre><code>    def initialize(self) -&gt; None:\n        self.packet_count = 0\n        self._send_heartbeat()\n\n    def _send_heartbeat(self) -&gt; None:\n        message: SimpleMessage = {\n            'packet_count': self.packet_count,\n            'sender_type': SimpleSender.UAV.value,\n            'sender': self.provider.get_id()\n        }\n        command = BroadcastMessageCommand(json.dumps(message))\n        self.provider.send_communication_command(command)\n\n        self.provider.schedule_timer(\"\", self.provider.current_time() + 1)\n</code></pre> <p>Another thing the UAV needs to do is actually travel from the sensors to the ground station. We will use the MissionMobilityPlugin to implement this. This plugin allows us to specify a list of waypoints and configure a looping mission that will have our node follow this list of  waypoints infinitely. Since we want each of our UAVs to go to a different sensor, we will prepare a list of missions that the UAVs will pick from during initialization. Each mission starts at (0,0), where the ground station will be and flies to one of the sensor's deployment locations which we will define later. The UAVs always fly 20 meters above the ground.</p> List of missions<pre><code>mission_list = [\n    [\n        (0, 0, 20),\n        (150, 0, 20)\n    ],\n    [\n        (0, 0, 20),\n        (0, 150, 20)\n    ],\n    [\n        (0, 0, 20),\n        (-150, 0, 20)\n    ],\n    [\n        (0, 0, 20),\n        (0, -150, 20)\n    ]\n]\n</code></pre> UAV mission initalization<pre><code>        self._mission = MissionMobilityPlugin(self, MissionMobilityConfiguration(\n            loop_mission=LoopMission.REVERSE,\n        ))\n\n        self._mission.start_mission(mission_list.pop())\n</code></pre> <p>Next let's define our interactions with other protocols in the <code>handle_packet</code> method. A message from a sensor means  that one of our messages has been received, and it is sending us its packets, in that case we accept them and add them to our <code>self.packet_count</code> property. If a message is received from the ground station it means that we have succesfully delivered our packets to it, and we should discard them. The snippet below shows this behaviour.</p> UAV interactions<pre><code>    def handle_packet(self, message: str) -&gt; None:\n        simple_message: SimpleMessage = json.loads(message)\n\n        if simple_message['sender_type'] == SimpleSender.SENSOR.value:\n            self.packet_count += simple_message['packet_count']\n        elif simple_message['sender_type'] == SimpleSender.GROUND_STATION.value:\n            self.packet_count = 0\n</code></pre> Full UAV code <pre><code>mission_list = [\n    [\n        (0, 0, 20),\n        (150, 0, 20)\n    ],\n    [\n        (0, 0, 20),\n        (0, 150, 20)\n    ],\n    [\n        (0, 0, 20),\n        (-150, 0, 20)\n    ],\n    [\n        (0, 0, 20),\n        (0, -150, 20)\n    ]\n]\n\n\nclass SimpleUAVProtocol(IProtocol):\n    _log: logging.Logger\n\n    packet_count: int\n\n    _mission: MissionMobilityPlugin\n\n    def initialize(self) -&gt; None:\n        self._log = logging.getLogger()\n        self.packet_count = 0\n\n        self._mission = MissionMobilityPlugin(self, MissionMobilityConfiguration(\n            loop_mission=LoopMission.REVERSE,\n        ))\n\n        self._mission.start_mission(mission_list.pop())\n\n        self._send_heartbeat()\n\n    def _send_heartbeat(self) -&gt; None:\n        self._log.info(f\"Sending heartbeat, current count {self.packet_count}\")\n\n        message: SimpleMessage = {\n            'packet_count': self.packet_count,\n            'sender_type': SimpleSender.UAV.value,\n            'sender': self.provider.get_id()\n        }\n        command = BroadcastMessageCommand(json.dumps(message))\n        self.provider.send_communication_command(command)\n\n        self.provider.schedule_timer(\"\", self.provider.current_time() + 1)\n\n    def handle_timer(self, timer: str) -&gt; None:\n        self._send_heartbeat()\n\n    def handle_packet(self, message: str) -&gt; None:\n        simple_message: SimpleMessage = json.loads(message)\n        self._log.info(report_message(simple_message))\n\n        if simple_message['sender_type'] == SimpleSender.SENSOR.value:\n            self.packet_count += simple_message['packet_count']\n            self._log.info(f\"Received {simple_message['packet_count']} packets from \"\n                           f\"sensor {simple_message['sender']}. Current count {self.packet_count}\")\n        elif simple_message['sender_type'] == SimpleSender.GROUND_STATION.value:\n            self._log.info(\"Received acknowledgment from ground station\")\n            self.packet_count = 0\n\n    def handle_telemetry(self, telemetry: Telemetry) -&gt; None:\n        pass\n\n    def finish(self) -&gt; None:\n        self._log.info(f\"Final packet count: {self.packet_count}\")\n</code></pre>"},{"location":"Guides/2_simple/#executing-what-weve-built","title":"Executing what we've built","text":"<p>Everything up to this point has been related only to protocols. The protocol we created above should be able to run in any execution-mode. We will create a prototype-mode simulation to test it.</p> <p>Warning</p> <p>Although the protocol will run on any environment it doesn't mean that all interactions will work exactly the same. Different environments bring with them new complexities that you might not have anticipated when you built your protocol. These protocols, for example, would have issues in integrated-mode as OMNeT++ simulates message colisions and all our UAVs send messages exactly every 1 second. A simple way to fix this would be introducing a small random delay to UAV messages. This is an example of how having varied environments can help you build more robust protocols.</p> Execution code for prototype-mode<pre><code>from gradysim.simulator.handler.communication import CommunicationHandler, CommunicationMedium\nfrom gradysim.simulator.handler.mobility import MobilityHandler\nfrom gradysim.simulator.handler.timer import TimerHandler\nfrom gradysim.simulator.handler.visualization import VisualizationHandler, VisualizationConfiguration\nfrom gradysim.simulator.simulation import SimulationBuilder, SimulationConfiguration\nfrom simple_protocol import SimpleSensorProtocol, SimpleGroundStationProtocol, SimpleUAVProtocol\n\n\ndef main():\n    # Configuring simulation\n    config = SimulationConfiguration(\n        duration=200\n    )\n    builder = SimulationBuilder(config)\n\n    # Instantiating 4 sensors in fixed positions\n    builder.add_node(SimpleSensorProtocol, (150, 0, 0))\n    builder.add_node(SimpleSensorProtocol, (0, 150, 0))\n    builder.add_node(SimpleSensorProtocol, (-150, 0, 0))\n    builder.add_node(SimpleSensorProtocol, (0, -150, 0))\n\n    # Instantiating 4 UAVs at (0,0,0)\n    builder.add_node(SimpleUAVProtocol, (0, 0, 0))\n    builder.add_node(SimpleUAVProtocol, (0, 0, 0))\n    builder.add_node(SimpleUAVProtocol, (0, 0, 0))\n    builder.add_node(SimpleUAVProtocol, (0, 0, 0))\n\n    # Instantiating ground station at (0,0,0)\n    builder.add_node(SimpleGroundStationProtocol, (0, 0, 0))\n\n    # Adding required handlers\n    builder.add_handler(TimerHandler())\n    builder.add_handler(CommunicationHandler(CommunicationMedium(\n        transmission_range=30\n    )))\n    builder.add_handler(MobilityHandler())\n    builder.add_handler(VisualizationHandler(VisualizationConfiguration(\n        x_range=(-150, 150),\n        y_range=(-150, 150),\n        z_range=(0, 150)\n    )))\n\n    # Building &amp; starting\n    simulation = builder.build()\n    simulation.start_simulation()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Danger</p> <p>This pattern of defining a main function and running it only if the file is being executed directly is required if you are using the VisualizationHandler as it will spawn a new process to run the visualization thread. Read more about this in the handler's documentation. </p> <p>The code above configures a python simulation that will run for 200 seconds. Four sensors are added to the simulation at specific deployment locations around a 300x300 meter area centered around (0,0). Four UAVs are  instantiated, each of them will serve one of these sensors. Last, the ground station is created at (0,0)) on the ground. </p> <p>After all the node's have been added we will add the handlers required for this simulation to run. The timer handler is required to enable timers, communication handler is also added and configured for a communication range of 30 meters. Mobility is also necessary to enable movement and finally visualization is added so we can watch the simulation progress.</p> <p>Finally, we build the simulation and run it.</p>"},{"location":"Guides/2_simple/#results","title":"Results","text":"<p>After running the simulation you will see that some useful stats have been logged. They indicate that the UAVs were  successful in transporting messages from the sensors to the ground station. Over the entire simulation over 600 packets were delivered to the ground station by them.</p> <pre><code>INFO     [it=0 time=0:00:00 | SimpleSensorProtocol 0 Finalization] Final packet count: 43\nINFO     [it=0 time=0:00:00 | SimpleSensorProtocol 1 Finalization] Final packet count: 43\nINFO     [it=0 time=0:00:00 | SimpleSensorProtocol 2 Finalization] Final packet count: 43\nINFO     [it=0 time=0:00:00 | SimpleSensorProtocol 3 Finalization] Final packet count: 43\nINFO     [it=0 time=0:00:00 | SimpleUAVProtocol 4 Finalization] Final packet count: 0\nINFO     [it=0 time=0:00:00 | SimpleUAVProtocol 5 Finalization] Final packet count: 0\nINFO     [it=0 time=0:00:00 | SimpleUAVProtocol 6 Finalization] Final packet count: 0\nINFO     [it=0 time=0:00:00 | SimpleUAVProtocol 7 Finalization] Final packet count: 0\nINFO     [it=0 time=0:00:00 | SimpleGroundStationProtocol 8 Finalization] Final packet count: 632\n</code></pre>"},{"location":"Guides/3_extending/","title":"Extending the Simulation","text":"<p>The simulation may not have all possible features that you need. We urge you to use the tools for extensibility provided by the simulator itself, instead of modifying the simulator code directly. This will make it easier to update the simulator to newer versions and sharing your creations with others.</p> <p>There are a few ways to extend the simulator. We are going to showcase them in this guide.</p>"},{"location":"Guides/3_extending/#extension-classes","title":"Extension Classes","text":"<p>Extension classes, documented here, allow a  protocol to interact directly with the simulation through an extension class. These classes have access to simulation internals and can modify them as needed.</p> <p>To be more specific, extension classes have access to  handlers; which are the classes that implement  parts of the simulation logic. Some examples of handlers are ones that  implement mobility or  communication.</p> <p>To showcase how to create an extension class, we are going to analyze the code of one of our extension classes, the camera hardware. This extension class implements a camera attached to a node that can \"visually\" detect other nodes' presence within it's field of view.</p> <p>Before we start, let's take a look at the base extension class code:</p> Base extension class<pre><code>import warnings\nfrom typing import Optional\n\nfrom gradysim.encapsulator.python import PythonProvider\nfrom gradysim.protocol.interface import IProtocol\n\n\nclass Extension:\n    \"\"\"\n    Base class for all extensions. Extensions are classes that can be used to extend the functionality of the simulation\n    environment. They are designed to be used by protocols to interact with the simulation environment in a more\n    sophisticated way.\n    \"\"\"\n\n    _provider: Optional[PythonProvider]\n\n    def __init__(self, protocol: IProtocol):\n        provider = protocol.provider\n\n        if protocol.provider is None:\n            raise ReferenceError(\"Protocol provider is not initialized. Make sure you are not creating this extension \"\n                                 \"before the protocol's initialize method is called.\")\n\n        if not isinstance(provider, PythonProvider):\n            warnings.warn(\"Extensions can only be ran in a python simulation environment. \"\n                          \"Every functionality in this extension will be a no-op.\")\n            self._provider = None\n        else:\n            self._provider = provider\n</code></pre> <p>The base extension class is a simple class designed to be subclassed. It only a single method, the initializer itself. The initializer receives a protocol instance and, through its provider, acceses simulation internals. Beware that the protocol itself should no do this if you are interested in keeping your protocol code abstraction in order. The extension intentionally breaks the  abstraction layer to allow for mode flexibility.</p> <p>The extension class can only be used when the protocol is running on the  python simulator. Every operation of an extension class should become a no-op when the runtime environment is not the python simulator. The type of provider is PythonProvider when the runtime environment is the python simulator, if another provider is present the base extension class is  set to None.</p> <p>Now, let's take a look at the camera extension class code. The camera extension class introduces a simulated camera hardware to the simulation. The camera can take pictures of the nodes within its field of view and detect their position and class. The camera integrates with the mobility module  like this:</p> Camera hardware extension class initializer<pre><code>class CameraHardware(Extension):\n    def __init__(self, protocol: IProtocol, configuration: CameraConfiguration):\n        super().__init__(protocol)\n        if self._provider is not None:\n            self._mobility: Optional[MobilityHandler] = self._provider.handlers.get('mobility')\n</code></pre> Full code of the camera extension class initializer <pre><code>import math\nfrom dataclasses import dataclass\nfrom typing import Optional, TypedDict, Tuple, List\n\nfrom gradysim.protocol.interface import IProtocol\nfrom gradysim.protocol.position import Position\nfrom gradysim.simulator.extension.extension import Extension\nfrom gradysim.simulator.handler.mobility import MobilityHandler\n\nclass DetectedNode(TypedDict):\n    position: Position\n    type: str\n\n@dataclass\nclass CameraConfiguration:\n    \"\"\"\n    Configuration class for the camera hardware\n    \"\"\"\n\n    camera_reach: float\n    \"\"\"The length of the cone that represents the camera's area of detection\"\"\"\n\n    camera_theta: float\n    \"\"\"The angle that determines how wide the cone, that represents the camera's area of detection, is\"\"\"\n\n    facing_elevation: float\n    \"\"\"The inclination of where the camera is pointing to in degrees, with 0 being directly up\"\"\"\n\n    facing_rotation: float\n    \"\"\"The rotation of the camera in degrees, with zero being along the x-axis in the positive direction\"\"\"\n\nclass CameraHardware(Extension):\n    \"\"\"\n    This extension simulates a camera hardware that can detect other nodes within its area of detection. The camera\n    has a reach, field of view, and direction of facing. The camera is capable of taking pictures, returning the list\n    of detected nodes within its area of detection.\n\n    The area of detection is a cone whose point is at the node's position and base faces the direction the camera is\n    pointing to, determined by the facing_inclination and facing_rotation attributes of the configuration. The cone's\n    angle at the point is determined by the field_of_view attribute of the configuration. The cone's length, or the\n    distance between its point and base, is determined by the cone_reach attribute of the configuration.\n    \"\"\"\n\n    def __init__(self, protocol: IProtocol, configuration: CameraConfiguration):\n        super().__init__(protocol)\n        if self._provider is not None:\n            self._mobility: Optional[MobilityHandler] = self._provider.handlers.get('mobility')\n        self._configuration = configuration\n\n        self._camera_vector = self._camera_direction_unit_vector()\n        self._camera_theta = math.radians(self._configuration.camera_theta)\n\n    def _camera_direction_unit_vector(self) -&gt; Tuple[float, float, float]:\n        \"\"\"\n        Returns the unit vector that represents the direction the camera is facing to\n        Returns:\n            A tuple representing the unit vector\n        \"\"\"\n        facing_inclination = math.radians(self._configuration.facing_elevation)\n        facing_rotation = math.radians(self._configuration.facing_rotation)\n\n        x = math.sin(facing_inclination) * math.cos(facing_rotation)\n        y = math.sin(facing_inclination) * math.sin(facing_rotation)\n        z = math.cos(facing_inclination)\n\n        return x, y, z\n\n    def take_picture(self) -&gt; List[DetectedNode]:\n        \"\"\"\n        This simulated camera hardware is able to detect other nodes within its are of detection. This method returns\n        the list of nodes currently inside the area of detection of the camera.\n        Returns:\n            A list of detected nodes\n        \"\"\"\n        if self._mobility is None:\n            return []\n\n        node_position = self._provider.node.position\n\n        other_nodes = [node for node in self._mobility.nodes.values() if node.id != self._provider.node.id]\n\n        detected_nodes = []\n        for node in other_nodes:\n            other_node_position = node.position\n            relative_vector = (\n                other_node_position[0] - node_position[0],\n                other_node_position[1] - node_position[1],\n                other_node_position[2] - node_position[2]\n            )\n\n            # Check if the node is within the camera's reach\n            distance = math.sqrt(relative_vector[0] ** 2 + relative_vector[1] ** 2 + relative_vector[2] ** 2)\n            if distance &gt; self._configuration.camera_reach:\n                continue\n\n            if distance &gt; 0:\n                # Check if the angle between vectors is less than theta\n                normalized_relative_vector = (\n                    relative_vector[0] / distance,\n                    relative_vector[1] / distance,\n                    relative_vector[2] / distance\n                )\n                dot_product = (\n                    self._camera_vector[0] * normalized_relative_vector[0] +\n                    self._camera_vector[1] * normalized_relative_vector[1] +\n                    self._camera_vector[2] * normalized_relative_vector[2]\n                )\n                angle = math.acos(dot_product) - 1e-6 # Tolerance\n                if angle &gt; self._camera_theta:\n                    continue\n\n            detected_nodes.append({\n                'position': other_node_position,\n                'type': 'node'\n            })\n\n        return detected_nodes\n\n    def change_facing(self, facing_elevation: float, facing_rotation: float):\n        \"\"\"\n        Changes the direction the camera is facing to\n        Args:\n            facing_elevation: The inclination of where the camera is pointing to in degrees, with 0 being at the ground\n            facing_rotation: The rotation of the camera in degrees, with zero being along the x-axis in the positive direction\n        \"\"\"\n        self._configuration.facing_elevation = facing_elevation\n        self._configuration.facing_rotation = facing_rotation\n        self._camera_vector = self._camera_direction_unit_vector()\n</code></pre> <p>The picture taking process is implemented by looking at every sensor's position and calculating if its within the camera's field of view. The calculation is  out of the scope of this tutorial, but you can check the code and  documentation to  understand how it works. The camera extension class uses the information available in the mobility handler to determine the full list of node's and  their positions here:</p> Camera hardware extension class using mobility handler<pre><code>    def take_picture(self) -&gt; List[DetectedNode]:\n        ...\n        other_nodes = [node for node in self._mobility.nodes.values() if node.id != self._provider.node.id]\n\n        detected_nodes = []\n        for node in other_nodes:\n            other_node_position = node.position\n</code></pre> Full code of the camera extension class <pre><code>import math\nfrom dataclasses import dataclass\nfrom typing import Optional, TypedDict, Tuple, List\n\nfrom gradysim.protocol.interface import IProtocol\nfrom gradysim.protocol.position import Position\nfrom gradysim.simulator.extension.extension import Extension\nfrom gradysim.simulator.handler.mobility import MobilityHandler\n\nclass DetectedNode(TypedDict):\n    position: Position\n    type: str\n\n@dataclass\nclass CameraConfiguration:\n    \"\"\"\n    Configuration class for the camera hardware\n    \"\"\"\n\n    camera_reach: float\n    \"\"\"The length of the cone that represents the camera's area of detection\"\"\"\n\n    camera_theta: float\n    \"\"\"The angle that determines how wide the cone, that represents the camera's area of detection, is\"\"\"\n\n    facing_elevation: float\n    \"\"\"The inclination of where the camera is pointing to in degrees, with 0 being directly up\"\"\"\n\n    facing_rotation: float\n    \"\"\"The rotation of the camera in degrees, with zero being along the x-axis in the positive direction\"\"\"\n\nclass CameraHardware(Extension):\n    \"\"\"\n    This extension simulates a camera hardware that can detect other nodes within its area of detection. The camera\n    has a reach, field of view, and direction of facing. The camera is capable of taking pictures, returning the list\n    of detected nodes within its area of detection.\n\n    The area of detection is a cone whose point is at the node's position and base faces the direction the camera is\n    pointing to, determined by the facing_inclination and facing_rotation attributes of the configuration. The cone's\n    angle at the point is determined by the field_of_view attribute of the configuration. The cone's length, or the\n    distance between its point and base, is determined by the cone_reach attribute of the configuration.\n    \"\"\"\n\n    def __init__(self, protocol: IProtocol, configuration: CameraConfiguration):\n        super().__init__(protocol)\n        if self._provider is not None:\n            self._mobility: Optional[MobilityHandler] = self._provider.handlers.get('mobility')\n        self._configuration = configuration\n\n        self._camera_vector = self._camera_direction_unit_vector()\n        self._camera_theta = math.radians(self._configuration.camera_theta)\n\n    def _camera_direction_unit_vector(self) -&gt; Tuple[float, float, float]:\n        \"\"\"\n        Returns the unit vector that represents the direction the camera is facing to\n        Returns:\n            A tuple representing the unit vector\n        \"\"\"\n        facing_inclination = math.radians(self._configuration.facing_elevation)\n        facing_rotation = math.radians(self._configuration.facing_rotation)\n\n        x = math.sin(facing_inclination) * math.cos(facing_rotation)\n        y = math.sin(facing_inclination) * math.sin(facing_rotation)\n        z = math.cos(facing_inclination)\n\n        return x, y, z\n\n    def take_picture(self) -&gt; List[DetectedNode]:\n        \"\"\"\n        This simulated camera hardware is able to detect other nodes within its are of detection. This method returns\n        the list of nodes currently inside the area of detection of the camera.\n        Returns:\n            A list of detected nodes\n        \"\"\"\n        if self._mobility is None:\n            return []\n\n        node_position = self._provider.node.position\n\n        other_nodes = [node for node in self._mobility.nodes.values() if node.id != self._provider.node.id]\n\n        detected_nodes = []\n        for node in other_nodes:\n            other_node_position = node.position\n            relative_vector = (\n                other_node_position[0] - node_position[0],\n                other_node_position[1] - node_position[1],\n                other_node_position[2] - node_position[2]\n            )\n\n            # Check if the node is within the camera's reach\n            distance = math.sqrt(relative_vector[0] ** 2 + relative_vector[1] ** 2 + relative_vector[2] ** 2)\n            if distance &gt; self._configuration.camera_reach:\n                continue\n\n            if distance &gt; 0:\n                # Check if the angle between vectors is less than theta\n                normalized_relative_vector = (\n                    relative_vector[0] / distance,\n                    relative_vector[1] / distance,\n                    relative_vector[2] / distance\n                )\n                dot_product = (\n                    self._camera_vector[0] * normalized_relative_vector[0] +\n                    self._camera_vector[1] * normalized_relative_vector[1] +\n                    self._camera_vector[2] * normalized_relative_vector[2]\n                )\n                angle = math.acos(dot_product) - 1e-6 # Tolerance\n                if angle &gt; self._camera_theta:\n                    continue\n\n            detected_nodes.append({\n                'position': other_node_position,\n                'type': 'node'\n            })\n\n        return detected_nodes\n\n    def change_facing(self, facing_elevation: float, facing_rotation: float):\n        \"\"\"\n        Changes the direction the camera is facing to\n        Args:\n            facing_elevation: The inclination of where the camera is pointing to in degrees, with 0 being at the ground\n            facing_rotation: The rotation of the camera in degrees, with zero being along the x-axis in the positive direction\n        \"\"\"\n        self._configuration.facing_elevation = facing_elevation\n        self._configuration.facing_rotation = facing_rotation\n        self._camera_vector = self._camera_direction_unit_vector()\n</code></pre> <p>To use the camera extension class, simply instantiate it during initialization. To illustrate a potential use case, we'll implement a simple simulation where a couple of drones fly over an area and take pictures of the nodes below them, logging how many they see. The code for this simulation is shown below:</p> Protocols using the camera hardware<pre><code>import logging\n\nfrom gradysim.protocol.interface import IProtocol\nfrom gradysim.protocol.messages.telemetry import Telemetry\nfrom gradysim.protocol.plugin.random_mobility import RandomMobilityPlugin, RandomMobilityConfig\nfrom gradysim.simulator.extension.camera import CameraHardware, CameraConfiguration\n\n\nclass PointOfInterest(IProtocol):\n    def initialize(self) -&gt; None:\n        pass\n\n    def handle_timer(self, timer: str) -&gt; None:\n        pass\n\n    def handle_packet(self, message: str) -&gt; None:\n        pass\n\n    def handle_telemetry(self, telemetry: Telemetry) -&gt; None:\n        pass\n\n    def finish(self) -&gt; None:\n        pass\n\n\nclass Drone(IProtocol):\n    camera: CameraHardware\n\n    def initialize(self) -&gt; None:\n        plugin = RandomMobilityPlugin(self, RandomMobilityConfig(x_range=(-50, 50), y_range=(-50, 50), z_range=(10, 10)))\n        plugin.initiate_random_trip()\n\n        self.provider.schedule_timer(\"\", self.provider.current_time())\n\n        configuration = CameraConfiguration(\n            20, # Reach of the camera\n            30, # Angle of the cone\n            180, # Facing elevation - facing downwards\n            0 # Facing rotation\n        )\n        self.camera = CameraHardware(self, configuration)\n\n    def handle_timer(self, timer: str) -&gt; None:\n        detected = self.camera.take_picture()\n        logging.info(f\"Detected {len(detected)} points of interest\")\n        self.provider.schedule_timer(\"\", self.provider.current_time() + 5)\n\n    def handle_packet(self, message: str) -&gt; None:\n        pass\n\n    def handle_telemetry(self, telemetry: Telemetry) -&gt; None:\n        pass\n\n    def finish(self) -&gt; None:\n        pass\n</code></pre> <p>The point of interest protocol implements no behaviour, it serves simply as a point of interest for the camera hardware to detect. The Drone protocol randomly flies above the area and takes pictures of the nodes below it at 5 second intervals. The simulation code is shown below:</p> Simulation using the camera hardware<pre><code>import random\n\nfrom gradysim.simulator.handler.mobility import MobilityHandler\nfrom gradysim.simulator.handler.timer import TimerHandler\nfrom gradysim.simulator.handler.visualization import VisualizationHandler\nfrom gradysim.simulator.simulation import SimulationConfiguration, SimulationBuilder\nfrom protocol import PointOfInterest, Drone\n\n\ndef main():\n    # Configuring simulation\n    config = SimulationConfiguration(\n        duration=200\n    )\n    builder = SimulationBuilder(config)\n\n    builder.add_handler(TimerHandler())\n    builder.add_handler(MobilityHandler())\n    builder.add_handler(VisualizationHandler())\n\n    # Instantiating a bunch of ground sensors\n    for _ in range(100):\n        builder.add_node(PointOfInterest,\n                         (random.randint(-50, 50), random.randint(-50, 50), 0))\n\n    # Instantiating 4 UAVs at (0,0,0)\n    for _ in range(4):\n        builder.add_node(Drone, (0, 0, 0))\n\n    # Building &amp; starting\n    simulation = builder.build()\n    simulation.start_simulation()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>The expected output of the simulation is:</p> <pre><code>INFO     [--------- Simulation started ---------]\nINFO     [it=0 time=0:00:00 | Drone 100 Initialization] RandomMobilityPlugin: Initiating a random trip\nINFO     [it=0 time=0:00:00 | Drone 100 Initialization] RandomMobilityPlugin: traveling to waypoint (14.370034502815273, 12.48244048437983, 10.0)\nINFO     [it=0 time=0:00:00 | Drone 101 Initialization] RandomMobilityPlugin: Initiating a random trip\nINFO     [it=0 time=0:00:00 | Drone 101 Initialization] RandomMobilityPlugin: traveling to waypoint (-24.720737786286406, 32.04056460547929, 10.0)\nINFO     [it=0 time=0:00:00 | Drone 102 Initialization] RandomMobilityPlugin: Initiating a random trip\nINFO     [it=0 time=0:00:00 | Drone 102 Initialization] RandomMobilityPlugin: traveling to waypoint (-1.4705086519382746, 5.365903305621153, 10.0)\nINFO     [it=0 time=0:00:00 | Drone 103 Initialization] RandomMobilityPlugin: Initiating a random trip\nINFO     [it=0 time=0:00:00 | Drone 103 Initialization] RandomMobilityPlugin: traveling to waypoint (-22.70707551545876, -36.412604020078106, 10.0)\nINFO     [it=0 time=0:00:00 | Drone 100 handle_timer] Detected 3 points of interest\nINFO     [it=1 time=0:00:00 | Drone 103 handle_timer] Detected 3 points of interest\nINFO     [it=2 time=0:00:00 | Drone 101 handle_timer] Detected 3 points of interest\nINFO     [it=3 time=0:00:00 | Drone 102 handle_timer] Detected 3 points of interest\nINFO     [it=11037 time=0:00:01.050000 | Drone 102 handle_telemetry] RandomMobilityPlugin: traveling to waypoint (30.939559651294985, 4.471458779580473, 10.0)\nINFO     [it=21745 time=0:00:02.060000 | Drone 100 handle_telemetry] RandomMobilityPlugin: traveling to waypoint (10.641625971935532, -43.2282648851834, 10.0)\nINFO     [it=43050 time=0:00:04.070000 | Drone 101 handle_telemetry] RandomMobilityPlugin: traveling to waypoint (37.52680363429771, 37.89473119809303, 10.0)\nINFO     [it=44321 time=0:00:04.190000 | Drone 102 handle_telemetry] RandomMobilityPlugin: traveling to waypoint (17.293162626366794, 27.386533869882385, 10.0)\nINFO     [it=45592 time=0:00:04.310000 | Drone 103 handle_telemetry] RandomMobilityPlugin: traveling to waypoint (-26.725198762915912, 8.771431035907064, 10.0)\nINFO     [it=53004 time=0:00:05 | Drone 102 handle_timer] Detected 0 points of interest\nINFO     [it=53005 time=0:00:05 | Drone 101 handle_timer] Detected 0 points of interest\nINFO     [it=53006 time=0:00:05 | Drone 103 handle_timer] Detected 1 points of interest\nINFO     [it=53007 time=0:00:05 | Drone 100 handle_timer] Detected 1 points of interest\nINFO     [it=71143 time=0:00:06.720000 | Drone 102 handle_telemetry] RandomMobilityPlugin: traveling to waypoint (-26.91921588222399, 38.910668436612625, 10.0)\nINFO     [it=79307 time=0:00:07.490000 | Drone 100 handle_telemetry] RandomMobilityPlugin: traveling to waypoint (-9.859851685045506, -22.136296678139523, 10.0)\nINFO     [it=91918 time=0:00:08.680000 | Drone 103 handle_telemetry] RandomMobilityPlugin: traveling to waypoint (8.848617474256883, 18.21708387682807, 10.0)\nINFO     [it=106008 time=0:00:10 | Drone 100 handle_timer] Detected 1 points of interest\nINFO     [it=106009 time=0:00:10 | Drone 102 handle_timer] Detected 1 points of interest\nINFO     [it=106010 time=0:00:10 | Drone 103 handle_timer] Detected 1 points of interest\nINFO     [it=106011 time=0:00:10 | Drone 101 handle_timer] Detected 3 points of interest\n\n...\n\nINFO     [it=2120160 time=0:03:20 | Drone 102 handle_timer] Detected 3 points of interest\nINFO     [it=2120161 time=0:03:20 | Drone 101 handle_timer] Detected 0 points of interest\nINFO     [it=2120162 time=0:03:20 | Drone 103 handle_timer] Detected 1 points of interest\nINFO     [it=2120163 time=0:03:20 | Drone 100 handle_timer] Detected 0 points of interest\nINFO     [--------- Simulation finished ---------]\nINFO     Real time elapsed: 0:00:22.017243  Total iterations: 2120165   Simulation time: 0:03:20.010000\n</code></pre>"},{"location":"Guides/Prototype%20Mode/","title":"Introduction","text":"<p>The guides in this section will teach you to use the Python Simulator which is part of the GrADyS-SIM NextGen framewok. Simulations ran in this mode are said to be in prototype mode. </p>"},{"location":"Guides/Prototype%20Mode/#why-use-the-python-simulator","title":"Why use the Python Simulator?","text":"<p>Use this simulator if you want quick iteration, easy setup, and a simple interface. This simulator is great for testing out new ideas and quickly prototyping new protocols. Don't let the word \"prototype\" fool you, this  simulator is still very powerful and can be used to simulate any protocol that  the other execution modes can. </p>"},{"location":"Guides/Prototype%20Mode/#how-does-it-work","title":"How does it work?","text":"<p>The python simulator is an event-based simulator. This means that the simulator will simulate through the execution of events. Events can be any action that occurs in a specific timestamp. Events can represent messages being sent,  node's positions being updated or anything else. </p> <p>The event-loop is basically a heap of these events, where the top of the heap is the event that will be executed next, based on its timestamp. The simulator  will execute the event by calling its callback method. For implementation  details check out the Event section.</p> <p>Every other component in the simulator is built on top of this event-based architecture. The simulator is very modular and extensible, so you can easily add new components to the simulator if you which to do it. The simulator is  extended through the creation of handlers. Handlers are merely classes with a reference to the event-loop and nodes in the simulation. They use these  references to implement some functionality. Check out the  Handler section to learn more about handlers.</p> <p>Protocols do not directly have access to any of the simulator's components.  They indirectly interact with the simulator through the  python encapsulator.</p>"},{"location":"Guides/Prototype%20Mode/#important-concepts","title":"Important concepts","text":"<p>Before you start using the simulator you should understand the following concepts:</p> <ul> <li>Event-loop: The event-loop is the central component of the simulator. It is   responsible for executing events in the correct order. Check out the    Event section to learn more about events.</li> <li>Event: Events are the building blocks of the simulator. They represent   actions that occur in a specific timestamp. Check out the Event   section to learn more about events.</li> <li>Handler: Extensible interface to implement new functionality in the    simulator. Check out the Handler section to    learn more about handlers.</li> </ul>"},{"location":"Guides/Prototype%20Mode/#architecture","title":"Architecture","text":""},{"location":"Modules/Encapsulator/","title":"Introduction","text":""},{"location":"Modules/Encapsulator/#gradysim.encapsulator","title":"<code>gradysim.encapsulator</code>","text":"<p>The encapsulator module is a middle-man between protocols and environments. One of GrADyS-SIM NextGen's features is the construction of protocols that can be used in different environments without changes to their code. These environments are called execution modes. Protocols are wrapped in encapsulators that handle the effects of the environment on the protocol and are injected with provider instances that provide them with the necessary tools to interact with the environment.</p> <p>This module provides encapsulators that enable users to run their protocols inside a python simulation (prototype-mode), integrated with a realistic network simulator OMNeT++ (integrated-mode) and, in the future, connected to real-life nodes.</p> <p>All encapsulators implement the IEncapsulator interface.</p>"},{"location":"Modules/Encapsulator/#gradysim.encapsulator.interface.IEncapsulator","title":"<code>gradysim.encapsulator.interface.IEncapsulator</code>","text":"<p>               Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Defines a generic interface that all encapsulators should implement. Encapsulator's main task is to wrap nodes absorbing effects from the environment and propagating them to the node and injecting a provider instance so that the nodes can interact with the environment.</p> Source code in <code>gradysim/encapsulator/interface.py</code> <pre><code>class IEncapsulator(ABC, Generic[T]):\n    \"\"\"\n    Defines a generic interface that all encapsulators should implement. Encapsulator's main task is to wrap nodes\n    absorbing effects from the environment and propagating them to the node and injecting a provider instance so\n    that the nodes can interact with the environment.\n    \"\"\"\n    protocol: T\n\n    @abstractmethod\n    def encapsulate(self, protocol: Type[T]) -&gt; None:\n        \"\"\"\n        Wraps a protocol. Should instantiate it and inject a provider instance into it. Every IEncapsulator instance\n        wraps a single protocol only.\n\n        Args:\n            protocol: The type of protocol being instantiated\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def initialize(self):\n        \"\"\"\n        Wraps the protocols initialize function\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def handle_timer(self, timer: str):\n        \"\"\"\n        Wraps the protocols handler_timer function\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def handle_packet(self, message: str):\n        \"\"\"\n        Wraps the protocols handle_packet function\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def handle_telemetry(self, telemetry: Telemetry):\n        \"\"\"\n        Wraps the protocols handle_telemetry function\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def finish(self):\n        \"\"\"\n        Wraps the protocols finish function\n        \"\"\"\n        pass\n</code></pre>"},{"location":"Modules/Encapsulator/#gradysim.encapsulator.interface.IEncapsulator.encapsulate","title":"<code>encapsulate(protocol)</code>  <code>abstractmethod</code>","text":"<p>Wraps a protocol. Should instantiate it and inject a provider instance into it. Every IEncapsulator instance wraps a single protocol only.</p> <p>Parameters:</p> Name Type Description Default <code>protocol</code> <code>Type[T]</code> <p>The type of protocol being instantiated</p> required Source code in <code>gradysim/encapsulator/interface.py</code> <pre><code>@abstractmethod\ndef encapsulate(self, protocol: Type[T]) -&gt; None:\n    \"\"\"\n    Wraps a protocol. Should instantiate it and inject a provider instance into it. Every IEncapsulator instance\n    wraps a single protocol only.\n\n    Args:\n        protocol: The type of protocol being instantiated\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Modules/Encapsulator/#gradysim.encapsulator.interface.IEncapsulator.finish","title":"<code>finish()</code>  <code>abstractmethod</code>","text":"<p>Wraps the protocols finish function</p> Source code in <code>gradysim/encapsulator/interface.py</code> <pre><code>@abstractmethod\ndef finish(self):\n    \"\"\"\n    Wraps the protocols finish function\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Modules/Encapsulator/#gradysim.encapsulator.interface.IEncapsulator.handle_packet","title":"<code>handle_packet(message)</code>  <code>abstractmethod</code>","text":"<p>Wraps the protocols handle_packet function</p> Source code in <code>gradysim/encapsulator/interface.py</code> <pre><code>@abstractmethod\ndef handle_packet(self, message: str):\n    \"\"\"\n    Wraps the protocols handle_packet function\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Modules/Encapsulator/#gradysim.encapsulator.interface.IEncapsulator.handle_telemetry","title":"<code>handle_telemetry(telemetry)</code>  <code>abstractmethod</code>","text":"<p>Wraps the protocols handle_telemetry function</p> Source code in <code>gradysim/encapsulator/interface.py</code> <pre><code>@abstractmethod\ndef handle_telemetry(self, telemetry: Telemetry):\n    \"\"\"\n    Wraps the protocols handle_telemetry function\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Modules/Encapsulator/#gradysim.encapsulator.interface.IEncapsulator.handle_timer","title":"<code>handle_timer(timer)</code>  <code>abstractmethod</code>","text":"<p>Wraps the protocols handler_timer function</p> Source code in <code>gradysim/encapsulator/interface.py</code> <pre><code>@abstractmethod\ndef handle_timer(self, timer: str):\n    \"\"\"\n    Wraps the protocols handler_timer function\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Modules/Encapsulator/#gradysim.encapsulator.interface.IEncapsulator.initialize","title":"<code>initialize()</code>  <code>abstractmethod</code>","text":"<p>Wraps the protocols initialize function</p> Source code in <code>gradysim/encapsulator/interface.py</code> <pre><code>@abstractmethod\ndef initialize(self):\n    \"\"\"\n    Wraps the protocols initialize function\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Modules/Encapsulator/interop/","title":"Interop","text":""},{"location":"Modules/Encapsulator/interop/#gradysim.encapsulator.interop","title":"<code>gradysim.encapsulator.interop</code>","text":"<p>Wraps the running protocol and prepares it for integration with the OMNeT++, in integrated-mode. It is injected with a InteropProvider instance that provides it with the necessary tools to interact with the OMNeT++ environment.</p> <p>The integration works by collecting all the consequences of the protocol's actions and returning them to the OMNeT++. Consequences are actions that the protocol wants to perform on the environment, such as sending a message or moving the node. The OMNeT++ environment then performs these actions is able to call protocol when it needs to, such as when a message is received or a timer fires.</p> <p>This encapsulator is instantiated by OMNeT++, the execution flow is only transferred to this code when an envet happens in the OMNeT++ simulation that warrants a call to the protocol. No code changes are necessary to run a protocol in this mode.</p>"},{"location":"Modules/Encapsulator/interop/#gradysim.encapsulator.interop.Consequence","title":"<code>Consequence = Tuple[ConsequenceType, Union[CommunicationCommand, MobilityCommand, TimerParams, TrackVariableParams]]</code>  <code>module-attribute</code>","text":"<p>A consequence is a tuple of a consequence type and a consequence payload. The payload is a different type for each consequence type</p>"},{"location":"Modules/Encapsulator/interop/#gradysim.encapsulator.interop.TimerParams","title":"<code>TimerParams = Tuple[str, float]</code>  <code>module-attribute</code>","text":"<p>Parameters to a timer consequence. The str is the timer and the float is the timestamp when the timer should fire</p>"},{"location":"Modules/Encapsulator/interop/#gradysim.encapsulator.interop.TrackVariableParams","title":"<code>TrackVariableParams = Tuple[str, Any]</code>  <code>module-attribute</code>","text":"<p>Parameters to a track variable consequence. The str is the variable name and the Any is the variable value</p>"},{"location":"Modules/Encapsulator/interop/#gradysim.encapsulator.interop.ConsequenceType","title":"<code>ConsequenceType</code>","text":"<p>               Bases: <code>int</code>, <code>Enum</code></p> <p>Enum representing the different types of consequences that can be returned by the protocol. Each consequence type serializes a different interaction the protocol wants to perform with the environment.</p> Source code in <code>gradysim/encapsulator/interop.py</code> <pre><code>class ConsequenceType(int, Enum):\n    \"\"\"\n    Enum representing the different types of consequences that can be returned by the protocol. Each consequence type\n    serializes a different interaction the protocol wants to perform with the environment.\n    \"\"\"\n    COMMUNICATION = 0\n    MOBILITY = 1\n    TIMER = 2\n    TRACK_VARIABLE = 3\n</code></pre>"},{"location":"Modules/Encapsulator/interop/#gradysim.encapsulator.interop.InteropEncapsulator","title":"<code>InteropEncapsulator</code>","text":"<p>               Bases: <code>IEncapsulator</code></p> <p>Encapsulator implementation for the OMNeT++ environment. The encapsulator wraps the protocol and prepares it for integration with the OMNeT++ environment. It is injected with a InteropProvider instance that provides it with the necessary tools to interact with the OMNeT++ environment.</p> Source code in <code>gradysim/encapsulator/interop.py</code> <pre><code>class InteropEncapsulator(IEncapsulator):\n    \"\"\"\n    Encapsulator implementation for the OMNeT++ environment. The encapsulator wraps the protocol and prepares it for\n    integration with the OMNeT++ environment. It is injected with a [InteropProvider][gradysim.encapsulator.interop.InteropProvider]\n    instance that provides it with the necessary tools to interact with the OMNeT++ environment.\n    \"\"\"\n    provider: InteropProvider\n\n    def __init__(self):\n        \"\"\"\n        Creates a new encapsulator instance\n        \"\"\"\n        self.provider = InteropProvider()\n\n    def encapsulate(self, protocol: Type[IProtocol]) -&gt; None:\n        \"\"\"\n        Instantiates the protocol and injects the provider into it\n\n        Args:\n            protocol: The type of protocol being encapsulated\n        \"\"\"\n        self.protocol = protocol.instantiate(self.provider)\n\n    def _collect_consequences(self) -&gt; List[Consequence]:\n        consequences = self.provider.consequences\n        self.provider.consequences = []\n        return consequences\n\n    def set_timestamp(self, timestamp: float):\n        \"\"\"\n        Sets the current simulation time in seconds. This method is called by the OMNeT++ environment before calling\n        the protocol's methods, to make sure the protocol has the correct time.\n        \"\"\"\n        self.provider.timestamp = timestamp\n\n    def set_id(self, id: int):\n        \"\"\"\n        Sets the node's unique identifier in the simulation. This method is called once by the OMNeT++ environment\n        before calling any of the protocol's methods, to make sure the protocol has the correct id.\n        \"\"\"\n        self.provider.id = id\n\n    def initialize(self) -&gt; List[Consequence]:\n        \"\"\"\n        Initializes the protocol. Called by the OMNeT++ environment before the simulation starts.\n\n        Returns:\n            A list of consequences that the protocol wants to perform on the environment from this call\n        \"\"\"\n        self.protocol.initialize()\n        return self._collect_consequences()\n\n    def handle_timer(self, timer: str) -&gt; List[Consequence]:\n        \"\"\"\n        Handles a timer event. Called by the OMNeT++ environment when a timer fires.\n\n        Args:\n            timer: The timer that fired\n\n        Returns:\n            A list of consequences that the protocol wants to perform on the environment from this call\n        \"\"\"\n        self.protocol.handle_timer(timer)\n        return self._collect_consequences()\n\n    def handle_packet(self, message: str) -&gt; List[Consequence]:\n        \"\"\"\n        Handles a message. Called by the OMNeT++ environment when a message is received.\n\n        Args:\n            message: Message being received\n\n        Returns:\n            A list of consequences that the protocol wants to perform on the environment from this call\n        \"\"\"\n        self.protocol.handle_packet(message)\n        return self._collect_consequences()\n\n    def handle_telemetry(self, telemetry: Telemetry) -&gt; List[Consequence]:\n        \"\"\"\n        Handles a telemetry event. Called by the OMNeT++ environment when a telemetry event happens.\n\n        Args:\n            telemetry: Telemetry event being received\n\n        Returns:\n            A list of consequences that the protocol wants to perform on the environment from this call\n        \"\"\"\n        self.protocol.handle_telemetry(telemetry)\n        return self._collect_consequences()\n\n    def finish(self) -&gt; List[Consequence]:\n        \"\"\"\n        Finalizes the protocol. Called by the OMNeT++ environment when the simulation is over.\n\n        Returns:\n            A list of consequences that the protocol wants to perform on the environment from this call\n        \"\"\"\n        self.protocol.finish()\n        return self._collect_consequences()\n</code></pre>"},{"location":"Modules/Encapsulator/interop/#gradysim.encapsulator.interop.InteropEncapsulator.__init__","title":"<code>__init__()</code>","text":"<p>Creates a new encapsulator instance</p> Source code in <code>gradysim/encapsulator/interop.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Creates a new encapsulator instance\n    \"\"\"\n    self.provider = InteropProvider()\n</code></pre>"},{"location":"Modules/Encapsulator/interop/#gradysim.encapsulator.interop.InteropEncapsulator.encapsulate","title":"<code>encapsulate(protocol)</code>","text":"<p>Instantiates the protocol and injects the provider into it</p> <p>Parameters:</p> Name Type Description Default <code>protocol</code> <code>Type[IProtocol]</code> <p>The type of protocol being encapsulated</p> required Source code in <code>gradysim/encapsulator/interop.py</code> <pre><code>def encapsulate(self, protocol: Type[IProtocol]) -&gt; None:\n    \"\"\"\n    Instantiates the protocol and injects the provider into it\n\n    Args:\n        protocol: The type of protocol being encapsulated\n    \"\"\"\n    self.protocol = protocol.instantiate(self.provider)\n</code></pre>"},{"location":"Modules/Encapsulator/interop/#gradysim.encapsulator.interop.InteropEncapsulator.finish","title":"<code>finish()</code>","text":"<p>Finalizes the protocol. Called by the OMNeT++ environment when the simulation is over.</p> <p>Returns:</p> Type Description <code>List[Consequence]</code> <p>A list of consequences that the protocol wants to perform on the environment from this call</p> Source code in <code>gradysim/encapsulator/interop.py</code> <pre><code>def finish(self) -&gt; List[Consequence]:\n    \"\"\"\n    Finalizes the protocol. Called by the OMNeT++ environment when the simulation is over.\n\n    Returns:\n        A list of consequences that the protocol wants to perform on the environment from this call\n    \"\"\"\n    self.protocol.finish()\n    return self._collect_consequences()\n</code></pre>"},{"location":"Modules/Encapsulator/interop/#gradysim.encapsulator.interop.InteropEncapsulator.handle_packet","title":"<code>handle_packet(message)</code>","text":"<p>Handles a message. Called by the OMNeT++ environment when a message is received.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Message being received</p> required <p>Returns:</p> Type Description <code>List[Consequence]</code> <p>A list of consequences that the protocol wants to perform on the environment from this call</p> Source code in <code>gradysim/encapsulator/interop.py</code> <pre><code>def handle_packet(self, message: str) -&gt; List[Consequence]:\n    \"\"\"\n    Handles a message. Called by the OMNeT++ environment when a message is received.\n\n    Args:\n        message: Message being received\n\n    Returns:\n        A list of consequences that the protocol wants to perform on the environment from this call\n    \"\"\"\n    self.protocol.handle_packet(message)\n    return self._collect_consequences()\n</code></pre>"},{"location":"Modules/Encapsulator/interop/#gradysim.encapsulator.interop.InteropEncapsulator.handle_telemetry","title":"<code>handle_telemetry(telemetry)</code>","text":"<p>Handles a telemetry event. Called by the OMNeT++ environment when a telemetry event happens.</p> <p>Parameters:</p> Name Type Description Default <code>telemetry</code> <code>Telemetry</code> <p>Telemetry event being received</p> required <p>Returns:</p> Type Description <code>List[Consequence]</code> <p>A list of consequences that the protocol wants to perform on the environment from this call</p> Source code in <code>gradysim/encapsulator/interop.py</code> <pre><code>def handle_telemetry(self, telemetry: Telemetry) -&gt; List[Consequence]:\n    \"\"\"\n    Handles a telemetry event. Called by the OMNeT++ environment when a telemetry event happens.\n\n    Args:\n        telemetry: Telemetry event being received\n\n    Returns:\n        A list of consequences that the protocol wants to perform on the environment from this call\n    \"\"\"\n    self.protocol.handle_telemetry(telemetry)\n    return self._collect_consequences()\n</code></pre>"},{"location":"Modules/Encapsulator/interop/#gradysim.encapsulator.interop.InteropEncapsulator.handle_timer","title":"<code>handle_timer(timer)</code>","text":"<p>Handles a timer event. Called by the OMNeT++ environment when a timer fires.</p> <p>Parameters:</p> Name Type Description Default <code>timer</code> <code>str</code> <p>The timer that fired</p> required <p>Returns:</p> Type Description <code>List[Consequence]</code> <p>A list of consequences that the protocol wants to perform on the environment from this call</p> Source code in <code>gradysim/encapsulator/interop.py</code> <pre><code>def handle_timer(self, timer: str) -&gt; List[Consequence]:\n    \"\"\"\n    Handles a timer event. Called by the OMNeT++ environment when a timer fires.\n\n    Args:\n        timer: The timer that fired\n\n    Returns:\n        A list of consequences that the protocol wants to perform on the environment from this call\n    \"\"\"\n    self.protocol.handle_timer(timer)\n    return self._collect_consequences()\n</code></pre>"},{"location":"Modules/Encapsulator/interop/#gradysim.encapsulator.interop.InteropEncapsulator.initialize","title":"<code>initialize()</code>","text":"<p>Initializes the protocol. Called by the OMNeT++ environment before the simulation starts.</p> <p>Returns:</p> Type Description <code>List[Consequence]</code> <p>A list of consequences that the protocol wants to perform on the environment from this call</p> Source code in <code>gradysim/encapsulator/interop.py</code> <pre><code>def initialize(self) -&gt; List[Consequence]:\n    \"\"\"\n    Initializes the protocol. Called by the OMNeT++ environment before the simulation starts.\n\n    Returns:\n        A list of consequences that the protocol wants to perform on the environment from this call\n    \"\"\"\n    self.protocol.initialize()\n    return self._collect_consequences()\n</code></pre>"},{"location":"Modules/Encapsulator/interop/#gradysim.encapsulator.interop.InteropEncapsulator.set_id","title":"<code>set_id(id)</code>","text":"<p>Sets the node's unique identifier in the simulation. This method is called once by the OMNeT++ environment before calling any of the protocol's methods, to make sure the protocol has the correct id.</p> Source code in <code>gradysim/encapsulator/interop.py</code> <pre><code>def set_id(self, id: int):\n    \"\"\"\n    Sets the node's unique identifier in the simulation. This method is called once by the OMNeT++ environment\n    before calling any of the protocol's methods, to make sure the protocol has the correct id.\n    \"\"\"\n    self.provider.id = id\n</code></pre>"},{"location":"Modules/Encapsulator/interop/#gradysim.encapsulator.interop.InteropEncapsulator.set_timestamp","title":"<code>set_timestamp(timestamp)</code>","text":"<p>Sets the current simulation time in seconds. This method is called by the OMNeT++ environment before calling the protocol's methods, to make sure the protocol has the correct time.</p> Source code in <code>gradysim/encapsulator/interop.py</code> <pre><code>def set_timestamp(self, timestamp: float):\n    \"\"\"\n    Sets the current simulation time in seconds. This method is called by the OMNeT++ environment before calling\n    the protocol's methods, to make sure the protocol has the correct time.\n    \"\"\"\n    self.provider.timestamp = timestamp\n</code></pre>"},{"location":"Modules/Encapsulator/interop/#gradysim.encapsulator.interop.InteropProvider","title":"<code>InteropProvider</code>","text":"<p>               Bases: <code>IProvider</code></p> <p>Provider implementation for the OMNeT++ environment. The provider is injected into the protocol encapsulator and provides it with the necessary tools to interact with the environment.</p> Source code in <code>gradysim/encapsulator/interop.py</code> <pre><code>class InteropProvider(IProvider):\n    \"\"\"\n    Provider implementation for the OMNeT++ environment. The provider is injected into the protocol encapsulator and\n    provides it with the necessary tools to interact with the environment.\n    \"\"\"\n    consequences: List[Consequence]\n    timestamp: int\n    id: int\n\n    def __init__(self):\n        \"\"\"\n        Creates a new provider instance\n        \"\"\"\n        self.consequences = []\n        self.timestamp = 0\n        self.id = 0\n        self.tracked_variables = \\\n            _TrackedVariableContainer(lambda key, value: self.consequences.append((ConsequenceType.TRACK_VARIABLE,\n                                                                                   (key, value))))\n\n    def send_communication_command(self, command: CommunicationCommand) -&gt; None:\n        \"\"\"\n        Adds a communication command to the list of consequences\n\n        Args:\n            command: Command being issued\n        \"\"\"\n        self.consequences.append((ConsequenceType.COMMUNICATION, command))\n\n    def send_mobility_command(self, command: MobilityCommand) -&gt; None:\n        \"\"\"\n        Adds a mobility command to the list of consequences\n\n        Args:\n            command: Command being issued\n        \"\"\"\n        self.consequences.append((ConsequenceType.MOBILITY, command))\n\n    def schedule_timer(self, timer: str, timestamp: float) -&gt; None:\n        \"\"\"\n        Adds a timer consequence to the list of consequences\n\n        Args:\n            timer: The timer that will be fired\n            timestamp: The timestamp in simulation seconds when the timer will fire\n        \"\"\"\n        self.consequences.append((ConsequenceType.TIMER, (timer, timestamp)))\n\n    def cancel_timer(self, timer: str) -&gt; None:\n        raise NotImplementedError(\"Canceling timers is not supported in the OMNeT++ environment. \"\n                                  \"If you need this feature, please show your interest by opening an issue at \"\n                                  \"the github repository.\")\n\n    def current_time(self) -&gt; int:\n        \"\"\"\n        Returns the current simulation time in seconds\n\n        Returns: The current simulation time in seconds\n        \"\"\"\n        return self.timestamp\n\n    def get_id(self) -&gt; int:\n        \"\"\"\n        Returns the node's unique identifier in the simulation\n\n        Returns:\n            The node's unique identifier in the simulation\n        \"\"\"\n        return self.id\n</code></pre>"},{"location":"Modules/Encapsulator/interop/#gradysim.encapsulator.interop.InteropProvider.__init__","title":"<code>__init__()</code>","text":"<p>Creates a new provider instance</p> Source code in <code>gradysim/encapsulator/interop.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Creates a new provider instance\n    \"\"\"\n    self.consequences = []\n    self.timestamp = 0\n    self.id = 0\n    self.tracked_variables = \\\n        _TrackedVariableContainer(lambda key, value: self.consequences.append((ConsequenceType.TRACK_VARIABLE,\n                                                                               (key, value))))\n</code></pre>"},{"location":"Modules/Encapsulator/interop/#gradysim.encapsulator.interop.InteropProvider.current_time","title":"<code>current_time()</code>","text":"<p>Returns the current simulation time in seconds</p> <p>Returns: The current simulation time in seconds</p> Source code in <code>gradysim/encapsulator/interop.py</code> <pre><code>def current_time(self) -&gt; int:\n    \"\"\"\n    Returns the current simulation time in seconds\n\n    Returns: The current simulation time in seconds\n    \"\"\"\n    return self.timestamp\n</code></pre>"},{"location":"Modules/Encapsulator/interop/#gradysim.encapsulator.interop.InteropProvider.get_id","title":"<code>get_id()</code>","text":"<p>Returns the node's unique identifier in the simulation</p> <p>Returns:</p> Type Description <code>int</code> <p>The node's unique identifier in the simulation</p> Source code in <code>gradysim/encapsulator/interop.py</code> <pre><code>def get_id(self) -&gt; int:\n    \"\"\"\n    Returns the node's unique identifier in the simulation\n\n    Returns:\n        The node's unique identifier in the simulation\n    \"\"\"\n    return self.id\n</code></pre>"},{"location":"Modules/Encapsulator/interop/#gradysim.encapsulator.interop.InteropProvider.schedule_timer","title":"<code>schedule_timer(timer, timestamp)</code>","text":"<p>Adds a timer consequence to the list of consequences</p> <p>Parameters:</p> Name Type Description Default <code>timer</code> <code>str</code> <p>The timer that will be fired</p> required <code>timestamp</code> <code>float</code> <p>The timestamp in simulation seconds when the timer will fire</p> required Source code in <code>gradysim/encapsulator/interop.py</code> <pre><code>def schedule_timer(self, timer: str, timestamp: float) -&gt; None:\n    \"\"\"\n    Adds a timer consequence to the list of consequences\n\n    Args:\n        timer: The timer that will be fired\n        timestamp: The timestamp in simulation seconds when the timer will fire\n    \"\"\"\n    self.consequences.append((ConsequenceType.TIMER, (timer, timestamp)))\n</code></pre>"},{"location":"Modules/Encapsulator/interop/#gradysim.encapsulator.interop.InteropProvider.send_communication_command","title":"<code>send_communication_command(command)</code>","text":"<p>Adds a communication command to the list of consequences</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>CommunicationCommand</code> <p>Command being issued</p> required Source code in <code>gradysim/encapsulator/interop.py</code> <pre><code>def send_communication_command(self, command: CommunicationCommand) -&gt; None:\n    \"\"\"\n    Adds a communication command to the list of consequences\n\n    Args:\n        command: Command being issued\n    \"\"\"\n    self.consequences.append((ConsequenceType.COMMUNICATION, command))\n</code></pre>"},{"location":"Modules/Encapsulator/interop/#gradysim.encapsulator.interop.InteropProvider.send_mobility_command","title":"<code>send_mobility_command(command)</code>","text":"<p>Adds a mobility command to the list of consequences</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>MobilityCommand</code> <p>Command being issued</p> required Source code in <code>gradysim/encapsulator/interop.py</code> <pre><code>def send_mobility_command(self, command: MobilityCommand) -&gt; None:\n    \"\"\"\n    Adds a mobility command to the list of consequences\n\n    Args:\n        command: Command being issued\n    \"\"\"\n    self.consequences.append((ConsequenceType.MOBILITY, command))\n</code></pre>"},{"location":"Modules/Encapsulator/python/","title":"Python","text":""},{"location":"Modules/Encapsulator/python/#gradysim.encapsulator.python","title":"<code>gradysim.encapsulator.python</code>","text":"<p>Encapsulates protocols that run in prototype-mode. The encapsulator will wrap the protocol instance and handle interactions with the python simulator. It will also inject a provider instance that translates the protocol's calls into interactions with the python simulator.</p>"},{"location":"Modules/Encapsulator/python/#gradysim.encapsulator.python.PythonEncapsulator","title":"<code>PythonEncapsulator</code>","text":"<p>               Bases: <code>IEncapsulator</code></p> <p>Encapsulates the protocol to work with the python simulation.</p> Source code in <code>gradysim/encapsulator/python.py</code> <pre><code>class PythonEncapsulator(IEncapsulator):\n    \"\"\"\n    Encapsulates the protocol to work with the python simulation.\n    \"\"\"\n\n    def __init__(self,\n                 node: Node,\n                 **handlers: INodeHandler):\n        \"\"\"\n        Instantiates a python encapsulator\n\n        Args:\n            node: Node being encapsulated\n            handlers: Handlers being used in the simulation\n        \"\"\"\n        self.provider = PythonProvider(node, **handlers)\n\n    def encapsulate(self, protocol: Type[IProtocol]) -&gt; None:\n        \"\"\"\n        Encapsulates the protocol instance. Injencts a PythonProvider instance into it\n\n        Args:\n            protocol: Type of protocol being instantiated\n        \"\"\"\n        self.protocol = protocol.instantiate(self.provider)\n\n    def initialize(self) -&gt; None:\n        \"\"\"\n        Redirects the call to the protocol\n        \"\"\"\n        self.protocol.initialize()\n\n    def handle_timer(self, timer: str) -&gt; None:\n        \"\"\"\n        Redirects the call to the protocol\n        \"\"\"\n        self.protocol.handle_timer(timer)\n\n    def handle_packet(self, message: str) -&gt; None:\n        \"\"\"\n        Redirects the call to the protocol\n        \"\"\"\n        self.protocol.handle_packet(message)\n\n    def handle_telemetry(self, telemetry: Telemetry) -&gt; None:\n        \"\"\"\n        Redirects the call to the protocol\n        \"\"\"\n        self.protocol.handle_telemetry(telemetry)\n\n    def finish(self) -&gt; None:\n        \"\"\"\n        Redirects the call to the protocol\n        \"\"\"\n        self.protocol.finish()\n</code></pre>"},{"location":"Modules/Encapsulator/python/#gradysim.encapsulator.python.PythonEncapsulator.__init__","title":"<code>__init__(node, **handlers)</code>","text":"<p>Instantiates a python encapsulator</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>Node being encapsulated</p> required <code>handlers</code> <code>INodeHandler</code> <p>Handlers being used in the simulation</p> <code>{}</code> Source code in <code>gradysim/encapsulator/python.py</code> <pre><code>def __init__(self,\n             node: Node,\n             **handlers: INodeHandler):\n    \"\"\"\n    Instantiates a python encapsulator\n\n    Args:\n        node: Node being encapsulated\n        handlers: Handlers being used in the simulation\n    \"\"\"\n    self.provider = PythonProvider(node, **handlers)\n</code></pre>"},{"location":"Modules/Encapsulator/python/#gradysim.encapsulator.python.PythonEncapsulator.encapsulate","title":"<code>encapsulate(protocol)</code>","text":"<p>Encapsulates the protocol instance. Injencts a PythonProvider instance into it</p> <p>Parameters:</p> Name Type Description Default <code>protocol</code> <code>Type[IProtocol]</code> <p>Type of protocol being instantiated</p> required Source code in <code>gradysim/encapsulator/python.py</code> <pre><code>def encapsulate(self, protocol: Type[IProtocol]) -&gt; None:\n    \"\"\"\n    Encapsulates the protocol instance. Injencts a PythonProvider instance into it\n\n    Args:\n        protocol: Type of protocol being instantiated\n    \"\"\"\n    self.protocol = protocol.instantiate(self.provider)\n</code></pre>"},{"location":"Modules/Encapsulator/python/#gradysim.encapsulator.python.PythonEncapsulator.finish","title":"<code>finish()</code>","text":"<p>Redirects the call to the protocol</p> Source code in <code>gradysim/encapsulator/python.py</code> <pre><code>def finish(self) -&gt; None:\n    \"\"\"\n    Redirects the call to the protocol\n    \"\"\"\n    self.protocol.finish()\n</code></pre>"},{"location":"Modules/Encapsulator/python/#gradysim.encapsulator.python.PythonEncapsulator.handle_packet","title":"<code>handle_packet(message)</code>","text":"<p>Redirects the call to the protocol</p> Source code in <code>gradysim/encapsulator/python.py</code> <pre><code>def handle_packet(self, message: str) -&gt; None:\n    \"\"\"\n    Redirects the call to the protocol\n    \"\"\"\n    self.protocol.handle_packet(message)\n</code></pre>"},{"location":"Modules/Encapsulator/python/#gradysim.encapsulator.python.PythonEncapsulator.handle_telemetry","title":"<code>handle_telemetry(telemetry)</code>","text":"<p>Redirects the call to the protocol</p> Source code in <code>gradysim/encapsulator/python.py</code> <pre><code>def handle_telemetry(self, telemetry: Telemetry) -&gt; None:\n    \"\"\"\n    Redirects the call to the protocol\n    \"\"\"\n    self.protocol.handle_telemetry(telemetry)\n</code></pre>"},{"location":"Modules/Encapsulator/python/#gradysim.encapsulator.python.PythonEncapsulator.handle_timer","title":"<code>handle_timer(timer)</code>","text":"<p>Redirects the call to the protocol</p> Source code in <code>gradysim/encapsulator/python.py</code> <pre><code>def handle_timer(self, timer: str) -&gt; None:\n    \"\"\"\n    Redirects the call to the protocol\n    \"\"\"\n    self.protocol.handle_timer(timer)\n</code></pre>"},{"location":"Modules/Encapsulator/python/#gradysim.encapsulator.python.PythonEncapsulator.initialize","title":"<code>initialize()</code>","text":"<p>Redirects the call to the protocol</p> Source code in <code>gradysim/encapsulator/python.py</code> <pre><code>def initialize(self) -&gt; None:\n    \"\"\"\n    Redirects the call to the protocol\n    \"\"\"\n    self.protocol.initialize()\n</code></pre>"},{"location":"Modules/Encapsulator/python/#gradysim.encapsulator.python.PythonProvider","title":"<code>PythonProvider</code>","text":"<p>               Bases: <code>IProvider</code></p> <p>Handles protocols actions translating them into actions inside the python simulation</p> Source code in <code>gradysim/encapsulator/python.py</code> <pre><code>class PythonProvider(IProvider):\n    \"\"\"\n    Handles protocols actions translating them into actions inside the python simulation\n    \"\"\"\n    def __init__(self, node: Node, **handlers: INodeHandler):\n        \"\"\"\n        Instantiates a python provider\n\n        Args:\n            node: Node being encapsulated\n            handlers: Handlers being used in the simulation\n        \"\"\"\n        self.node = node\n        self.communication_handler: Optional[CommunicationHandler] = handlers.get('communication')\n        self.timer_handler: Optional[TimerHandler] = handlers.get('timer')\n        self.mobility_handler: Optional[MobilityHandler] = handlers.get('mobility')\n        self.handlers = handlers\n        self.tracked_variables = {}\n        self._logger = logging.getLogger()\n\n    def send_communication_command(self, command: CommunicationCommand) -&gt; None:\n        \"\"\"\n        Forwards a communication command to the communication handler. If the simulation is running with no communication\n        handler issues a warning and does nothing.\n\n        Args:\n            command: Communication command being sent\n        \"\"\"\n        if self.communication_handler is not None:\n            self.communication_handler.handle_command(command, self.node)\n        else:\n            self._logger.warning(\"Communication commands cannot be sent without a \"\n                                 \"communication handler is configured\")\n\n    def send_mobility_command(self, command: MobilityCommand) -&gt; None:\n        \"\"\"\n        Forwards a mobility command to the mobility handler. If the simulation is running without a mobility handler\n        issues a warning and does nothing.\n\n        Args:\n            command: Command being sent\n        \"\"\"\n        if self.mobility_handler is not None:\n            self.mobility_handler.handle_command(command, self.node)\n        else:\n            self._logger.warning(\"Mobility commands cannot be sent without a \"\n                                 \"mobility handler is configured\")\n\n    def schedule_timer(self, timer: str, timestamp: float) -&gt; None:\n        \"\"\"\n        Schedules a timer using the timer handler. If one is not present in the simulation issues a warning and does\n        nothing\n\n        Args:\n            timer: Timer being ser\n            timestamp: Timestamp when it should fire\n\n        Returns:\n\n        \"\"\"\n        if self.timer_handler is not None:\n            self.timer_handler.set_timer(timer, timestamp, self.node)\n        else:\n            self._logger.warning(\"Timer cannot be set with no timer handler configured\")\n\n    def cancel_timer(self, timer: str) -&gt; None:\n        \"\"\"\n        Cancels a timer using the timer handler. If one is not present in the simulation issues a warning and does\n        nothing\n\n        Args:\n            timer: Timer being cancelled\n\n        Returns:\n\n        \"\"\"\n        if self.timer_handler is not None:\n            self.timer_handler.cancel_timer(timer, self.node)\n        else:\n            self._logger.warning(\"Timer cannot be cancelled with no timer handler configured\")\n\n\n    def current_time(self) -&gt; float:\n        \"\"\"\n        Returns the current time consulted from the timer handler. If one is not present issues a warning and returns\n        zero.\n\n        Returns:\n            Simulation timestamp in seconds or zero if no timer handler is present\n        \"\"\"\n        if self.timer_handler is not None:\n            return self.timer_handler.get_current_time()\n        else:\n            self._logger.warning(\"Current time cannot be retrieved when no timer handler is configured. This function \"\n                                 \"will always return zero.\")\n            return 0\n\n    def get_id(self) -&gt; int:\n        \"\"\"\n        Returns the node's unique identifier in the simulation\n\n        Returns:\n            the node's unique identifier in the simulation\n        \"\"\"\n        return self.node.id\n</code></pre>"},{"location":"Modules/Encapsulator/python/#gradysim.encapsulator.python.PythonProvider.__init__","title":"<code>__init__(node, **handlers)</code>","text":"<p>Instantiates a python provider</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>Node being encapsulated</p> required <code>handlers</code> <code>INodeHandler</code> <p>Handlers being used in the simulation</p> <code>{}</code> Source code in <code>gradysim/encapsulator/python.py</code> <pre><code>def __init__(self, node: Node, **handlers: INodeHandler):\n    \"\"\"\n    Instantiates a python provider\n\n    Args:\n        node: Node being encapsulated\n        handlers: Handlers being used in the simulation\n    \"\"\"\n    self.node = node\n    self.communication_handler: Optional[CommunicationHandler] = handlers.get('communication')\n    self.timer_handler: Optional[TimerHandler] = handlers.get('timer')\n    self.mobility_handler: Optional[MobilityHandler] = handlers.get('mobility')\n    self.handlers = handlers\n    self.tracked_variables = {}\n    self._logger = logging.getLogger()\n</code></pre>"},{"location":"Modules/Encapsulator/python/#gradysim.encapsulator.python.PythonProvider.cancel_timer","title":"<code>cancel_timer(timer)</code>","text":"<p>Cancels a timer using the timer handler. If one is not present in the simulation issues a warning and does nothing</p> <p>Parameters:</p> Name Type Description Default <code>timer</code> <code>str</code> <p>Timer being cancelled</p> required <p>Returns:</p> Source code in <code>gradysim/encapsulator/python.py</code> <pre><code>def cancel_timer(self, timer: str) -&gt; None:\n    \"\"\"\n    Cancels a timer using the timer handler. If one is not present in the simulation issues a warning and does\n    nothing\n\n    Args:\n        timer: Timer being cancelled\n\n    Returns:\n\n    \"\"\"\n    if self.timer_handler is not None:\n        self.timer_handler.cancel_timer(timer, self.node)\n    else:\n        self._logger.warning(\"Timer cannot be cancelled with no timer handler configured\")\n</code></pre>"},{"location":"Modules/Encapsulator/python/#gradysim.encapsulator.python.PythonProvider.current_time","title":"<code>current_time()</code>","text":"<p>Returns the current time consulted from the timer handler. If one is not present issues a warning and returns zero.</p> <p>Returns:</p> Type Description <code>float</code> <p>Simulation timestamp in seconds or zero if no timer handler is present</p> Source code in <code>gradysim/encapsulator/python.py</code> <pre><code>def current_time(self) -&gt; float:\n    \"\"\"\n    Returns the current time consulted from the timer handler. If one is not present issues a warning and returns\n    zero.\n\n    Returns:\n        Simulation timestamp in seconds or zero if no timer handler is present\n    \"\"\"\n    if self.timer_handler is not None:\n        return self.timer_handler.get_current_time()\n    else:\n        self._logger.warning(\"Current time cannot be retrieved when no timer handler is configured. This function \"\n                             \"will always return zero.\")\n        return 0\n</code></pre>"},{"location":"Modules/Encapsulator/python/#gradysim.encapsulator.python.PythonProvider.get_id","title":"<code>get_id()</code>","text":"<p>Returns the node's unique identifier in the simulation</p> <p>Returns:</p> Type Description <code>int</code> <p>the node's unique identifier in the simulation</p> Source code in <code>gradysim/encapsulator/python.py</code> <pre><code>def get_id(self) -&gt; int:\n    \"\"\"\n    Returns the node's unique identifier in the simulation\n\n    Returns:\n        the node's unique identifier in the simulation\n    \"\"\"\n    return self.node.id\n</code></pre>"},{"location":"Modules/Encapsulator/python/#gradysim.encapsulator.python.PythonProvider.schedule_timer","title":"<code>schedule_timer(timer, timestamp)</code>","text":"<p>Schedules a timer using the timer handler. If one is not present in the simulation issues a warning and does nothing</p> <p>Parameters:</p> Name Type Description Default <code>timer</code> <code>str</code> <p>Timer being ser</p> required <code>timestamp</code> <code>float</code> <p>Timestamp when it should fire</p> required <p>Returns:</p> Source code in <code>gradysim/encapsulator/python.py</code> <pre><code>def schedule_timer(self, timer: str, timestamp: float) -&gt; None:\n    \"\"\"\n    Schedules a timer using the timer handler. If one is not present in the simulation issues a warning and does\n    nothing\n\n    Args:\n        timer: Timer being ser\n        timestamp: Timestamp when it should fire\n\n    Returns:\n\n    \"\"\"\n    if self.timer_handler is not None:\n        self.timer_handler.set_timer(timer, timestamp, self.node)\n    else:\n        self._logger.warning(\"Timer cannot be set with no timer handler configured\")\n</code></pre>"},{"location":"Modules/Encapsulator/python/#gradysim.encapsulator.python.PythonProvider.send_communication_command","title":"<code>send_communication_command(command)</code>","text":"<p>Forwards a communication command to the communication handler. If the simulation is running with no communication handler issues a warning and does nothing.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>CommunicationCommand</code> <p>Communication command being sent</p> required Source code in <code>gradysim/encapsulator/python.py</code> <pre><code>def send_communication_command(self, command: CommunicationCommand) -&gt; None:\n    \"\"\"\n    Forwards a communication command to the communication handler. If the simulation is running with no communication\n    handler issues a warning and does nothing.\n\n    Args:\n        command: Communication command being sent\n    \"\"\"\n    if self.communication_handler is not None:\n        self.communication_handler.handle_command(command, self.node)\n    else:\n        self._logger.warning(\"Communication commands cannot be sent without a \"\n                             \"communication handler is configured\")\n</code></pre>"},{"location":"Modules/Encapsulator/python/#gradysim.encapsulator.python.PythonProvider.send_mobility_command","title":"<code>send_mobility_command(command)</code>","text":"<p>Forwards a mobility command to the mobility handler. If the simulation is running without a mobility handler issues a warning and does nothing.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>MobilityCommand</code> <p>Command being sent</p> required Source code in <code>gradysim/encapsulator/python.py</code> <pre><code>def send_mobility_command(self, command: MobilityCommand) -&gt; None:\n    \"\"\"\n    Forwards a mobility command to the mobility handler. If the simulation is running without a mobility handler\n    issues a warning and does nothing.\n\n    Args:\n        command: Command being sent\n    \"\"\"\n    if self.mobility_handler is not None:\n        self.mobility_handler.handle_command(command, self.node)\n    else:\n        self._logger.warning(\"Mobility commands cannot be sent without a \"\n                             \"mobility handler is configured\")\n</code></pre>"},{"location":"Modules/Protocol/","title":"Introduction","text":""},{"location":"Modules/Protocol/#gradysim.protocol","title":"<code>gradysim.protocol</code>","text":"<p>Use this module to create protocols. What GrADyS-SIM NextGen calls protocols is the logic that powers network nodes. Each network node has a protocol instance that is responsible for the node's behavior. Protocols define how a node reacts to its environment and enable it to interact with it.</p> <p>Protocols are environment agnostic, meaning they are not coupled to a specific environment. This allows for the same protocol to be used in different environments. For example, a protocol that defines how a node reacts to its environment can be used in different simulation environments and even in a real-world environment.</p> <p>Protocols are created by subclassing the IProtocol interface. The IProtocol interface defines the methods that a protocol must implement. These methods are reactive in nature, meaning they are called to react to events that occur in the environment. For example, a protocol may implement a method that is called when a node  receives a message from another node. The protocol can then react to the message by sending a message back to the  sender or by sending a message to another node.</p> <p>The protocol interface also guides how the protocol can affect its environment, through a IProvider instance that is injected into the protocol when it is instantiated. The IProvider instance provides the protocol with the necessary tools to interact with the environment. It enables the protocol to send messages to other nodes, schedule timers, and more.</p> <p>Messages are sent using the CommunicationCommand class. It instructs the node's communication module to perform some communication action, generally sending a message to another node. The node's communication module is not known by the protocol and shouldn't be its concern. The protocol only needs to know how to send messages and the IProvider instance provides it with the necessary tools to do so.</p> <p>The protocol can affect its node's mobility by sending MobilityCommand via the IProvider instance. The MobilityCommand class instructs the node's mobility module to perform some mobility action, generally moving the node to a new location. The node's mobility module is not known by the protocol and shouldn't be its concern. The protocol only needs to know how to move the node and the IProvider instance provides it with the necessary tools to do so.</p> <p>The protocol can also schedule timers using the IProvider instance. Timers are scheduled using the schedule_timer() method. The method takes a timer and a timestamp as arguments. These timers can be cancelled using the cancel_timer() method.</p>"},{"location":"Modules/Protocol/#gradysim.protocol.interface.IProtocol","title":"<code>gradysim.protocol.interface.IProtocol</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Subclass this interface to define a protocol. All abstract methods must be implemented, they can be empty in case no action is necessary. These methods define how a node reacts to its environment. You should use them to implement the logic that powers your node. Following this interface you will need to implement your protocol's logic in a event-based fashion.</p> <p>The IProvider interface accessible through the <code>provider</code> attribute provides the protocol with the necessary tools to interact with the environment.</p> <p>Protocols that follow this interface can run in any of the execution-modes supported by GrADyS-SIM NextGen.</p> Source code in <code>gradysim/protocol/interface.py</code> <pre><code>class IProtocol(ABC):\n    \"\"\"\n    Subclass this interface to define a protocol. All abstract methods must be implemented, they can be empty in case\n    no action is necessary. These methods define how a node reacts to its environment. You should use them to implement\n    the logic that powers your node. Following this interface you will need to implement your protocol's logic in a\n    event-based fashion.\n\n    The IProvider interface accessible through the `provider` attribute provides the protocol with the necessary tools\n    to interact with the environment.\n\n    Protocols that follow this interface can run in any of the [execution-modes][] supported by GrADyS-SIM NextGen.\n    \"\"\"\n\n    provider: IProvider\n    \"\"\"\n    IProvider instance that will provide protocol\n    with necessary tools to interact with the environment.\n    \"\"\"\n\n    @classmethod\n    def instantiate(cls, provider: IProvider) -&gt; 'IProtocol':\n        \"\"\"\n        Called when the protocol is instantiated before the simulator starts. The protocol's __init__() method is not\n        called, instead this method is used to initialize the protocol.\n\n        Args:\n            provider: the IProvider instance that will provide the protocol\n                with necessary tools to interact with the environment\n\n        Returns:\n            the instantiated protocol\n        \"\"\"\n        protocol = cls()\n        protocol.provider = provider\n        return protocol\n\n    @abstractmethod\n    def initialize(self) -&gt; None:\n        \"\"\"\n        This is the first function called when the simulator begins. The initialize()\n        methods for each network node are called in arbitrary order so don't rely on other\n        protocols having already been initialized.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def handle_timer(self, timer: str) -&gt; None:\n        \"\"\"\n        Called when a timer fires. The timer is identified by a string. This is the same string that was passed to the\n        provider's schedule_timer() method when the timer was scheduled.\n\n        Args:\n            timer: the timer that fired\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def handle_packet(self, message: str) -&gt; None:\n        \"\"\"\n        Called when a packet is received from another node. The packet contains a message which can be an identifier,\n        some serialized data, or anything else that can be represented as a string.\n\n        Args:\n            message: the message contained in the packet\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def handle_telemetry(self, telemetry: Telemetry) -&gt; None:\n        \"\"\"\n        Regularly called by the mobility module with information about the state of the node's mobility. Use this data\n        if your protocol should react to the node's mobility.\n\n        Args:\n            telemetry: the telemetry data\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def finish(self) -&gt; None:\n        \"\"\"\n        Called when the simulator finishes. The finish() method of every node in the simulator is called in arbitrary\n        order.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"Modules/Protocol/#gradysim.protocol.interface.IProtocol.provider","title":"<code>provider: IProvider</code>  <code>instance-attribute</code>","text":"<p>IProvider instance that will provide protocol with necessary tools to interact with the environment.</p>"},{"location":"Modules/Protocol/#gradysim.protocol.interface.IProtocol.finish","title":"<code>finish()</code>  <code>abstractmethod</code>","text":"<p>Called when the simulator finishes. The finish() method of every node in the simulator is called in arbitrary order.</p> Source code in <code>gradysim/protocol/interface.py</code> <pre><code>@abstractmethod\ndef finish(self) -&gt; None:\n    \"\"\"\n    Called when the simulator finishes. The finish() method of every node in the simulator is called in arbitrary\n    order.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Modules/Protocol/#gradysim.protocol.interface.IProtocol.handle_packet","title":"<code>handle_packet(message)</code>  <code>abstractmethod</code>","text":"<p>Called when a packet is received from another node. The packet contains a message which can be an identifier, some serialized data, or anything else that can be represented as a string.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>the message contained in the packet</p> required Source code in <code>gradysim/protocol/interface.py</code> <pre><code>@abstractmethod\ndef handle_packet(self, message: str) -&gt; None:\n    \"\"\"\n    Called when a packet is received from another node. The packet contains a message which can be an identifier,\n    some serialized data, or anything else that can be represented as a string.\n\n    Args:\n        message: the message contained in the packet\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Modules/Protocol/#gradysim.protocol.interface.IProtocol.handle_telemetry","title":"<code>handle_telemetry(telemetry)</code>  <code>abstractmethod</code>","text":"<p>Regularly called by the mobility module with information about the state of the node's mobility. Use this data if your protocol should react to the node's mobility.</p> <p>Parameters:</p> Name Type Description Default <code>telemetry</code> <code>Telemetry</code> <p>the telemetry data</p> required Source code in <code>gradysim/protocol/interface.py</code> <pre><code>@abstractmethod\ndef handle_telemetry(self, telemetry: Telemetry) -&gt; None:\n    \"\"\"\n    Regularly called by the mobility module with information about the state of the node's mobility. Use this data\n    if your protocol should react to the node's mobility.\n\n    Args:\n        telemetry: the telemetry data\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Modules/Protocol/#gradysim.protocol.interface.IProtocol.handle_timer","title":"<code>handle_timer(timer)</code>  <code>abstractmethod</code>","text":"<p>Called when a timer fires. The timer is identified by a string. This is the same string that was passed to the provider's schedule_timer() method when the timer was scheduled.</p> <p>Parameters:</p> Name Type Description Default <code>timer</code> <code>str</code> <p>the timer that fired</p> required Source code in <code>gradysim/protocol/interface.py</code> <pre><code>@abstractmethod\ndef handle_timer(self, timer: str) -&gt; None:\n    \"\"\"\n    Called when a timer fires. The timer is identified by a string. This is the same string that was passed to the\n    provider's schedule_timer() method when the timer was scheduled.\n\n    Args:\n        timer: the timer that fired\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Modules/Protocol/#gradysim.protocol.interface.IProtocol.initialize","title":"<code>initialize()</code>  <code>abstractmethod</code>","text":"<p>This is the first function called when the simulator begins. The initialize() methods for each network node are called in arbitrary order so don't rely on other protocols having already been initialized.</p> Source code in <code>gradysim/protocol/interface.py</code> <pre><code>@abstractmethod\ndef initialize(self) -&gt; None:\n    \"\"\"\n    This is the first function called when the simulator begins. The initialize()\n    methods for each network node are called in arbitrary order so don't rely on other\n    protocols having already been initialized.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Modules/Protocol/#gradysim.protocol.interface.IProtocol.instantiate","title":"<code>instantiate(provider)</code>  <code>classmethod</code>","text":"<p>Called when the protocol is instantiated before the simulator starts. The protocol's init() method is not called, instead this method is used to initialize the protocol.</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>IProvider</code> <p>the IProvider instance that will provide the protocol with necessary tools to interact with the environment</p> required <p>Returns:</p> Type Description <code>IProtocol</code> <p>the instantiated protocol</p> Source code in <code>gradysim/protocol/interface.py</code> <pre><code>@classmethod\ndef instantiate(cls, provider: IProvider) -&gt; 'IProtocol':\n    \"\"\"\n    Called when the protocol is instantiated before the simulator starts. The protocol's __init__() method is not\n    called, instead this method is used to initialize the protocol.\n\n    Args:\n        provider: the IProvider instance that will provide the protocol\n            with necessary tools to interact with the environment\n\n    Returns:\n        the instantiated protocol\n    \"\"\"\n    protocol = cls()\n    protocol.provider = provider\n    return protocol\n</code></pre>"},{"location":"Modules/Protocol/#gradysim.protocol.interface.IProvider","title":"<code>gradysim.protocol.interface.IProvider</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Interface that all protocols use to interact with their environment. The IProvider instance provides the protocol with the necessary tools to interact with the environment. It enables the protocol to send messages to other nodes, schedule timers, and more.</p> Source code in <code>gradysim/protocol/interface.py</code> <pre><code>class IProvider(ABC):\n    \"\"\"\n    Interface that all protocols use to interact with their environment. The IProvider instance provides the protocol\n    with the necessary tools to interact with the environment. It enables the protocol to send messages to other nodes,\n    schedule timers, and more.\n    \"\"\"\n\n    @abstractmethod\n    def send_communication_command(self, command: CommunicationCommand) -&gt; None:\n        \"\"\"\n        Sends a communication command to the node's communication module\n\n        Args:\n            command: the communication command to send\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def send_mobility_command(self, command: MobilityCommand) -&gt; None:\n        \"\"\"\n        Sends a mobility command to the node's mobility module\n\n        Args:\n            command: the mobility command to send\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def schedule_timer(self, timer: str, timestamp: float) -&gt; None:\n        \"\"\"\n        Schedules a timer that should fire at a specified timestamp\n\n        Args:\n            timer: the timer to schedule. Use this string to identify the timer when it fires, associate it with some\n                serialized data, or anything else that can be represented as a string.\n            timestamp: the timestamp in simulation seconds at which the timer should fire.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def cancel_timer(self, timer: str) -&gt; None:\n        \"\"\"\n        Cancels a timer that was previously scheduled. If a timer with the given identifier is not scheduled,\n        this method does nothing. If multiple timers with the same identifier are scheduled, all of them are canceled.\n\n        Args:\n            timer: identifier of the timer to cancel\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def current_time(self) -&gt; float:\n        \"\"\"\n        Returns the current simulator time in seconds\n\n        Returns:\n            the current simulator time in seconds\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def get_id(self) -&gt; int:\n        \"\"\"\n        Returns the node's unique identifier in the simulation\n\n        Returns:\n            the node's unique identifier in the simulation\n        \"\"\"\n        pass\n\n    # TODO: Document this\n    tracked_variables: Dict[str, Any]\n</code></pre>"},{"location":"Modules/Protocol/#gradysim.protocol.interface.IProvider.cancel_timer","title":"<code>cancel_timer(timer)</code>  <code>abstractmethod</code>","text":"<p>Cancels a timer that was previously scheduled. If a timer with the given identifier is not scheduled, this method does nothing. If multiple timers with the same identifier are scheduled, all of them are canceled.</p> <p>Parameters:</p> Name Type Description Default <code>timer</code> <code>str</code> <p>identifier of the timer to cancel</p> required Source code in <code>gradysim/protocol/interface.py</code> <pre><code>@abstractmethod\ndef cancel_timer(self, timer: str) -&gt; None:\n    \"\"\"\n    Cancels a timer that was previously scheduled. If a timer with the given identifier is not scheduled,\n    this method does nothing. If multiple timers with the same identifier are scheduled, all of them are canceled.\n\n    Args:\n        timer: identifier of the timer to cancel\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Modules/Protocol/#gradysim.protocol.interface.IProvider.current_time","title":"<code>current_time()</code>  <code>abstractmethod</code>","text":"<p>Returns the current simulator time in seconds</p> <p>Returns:</p> Type Description <code>float</code> <p>the current simulator time in seconds</p> Source code in <code>gradysim/protocol/interface.py</code> <pre><code>@abstractmethod\ndef current_time(self) -&gt; float:\n    \"\"\"\n    Returns the current simulator time in seconds\n\n    Returns:\n        the current simulator time in seconds\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Modules/Protocol/#gradysim.protocol.interface.IProvider.get_id","title":"<code>get_id()</code>  <code>abstractmethod</code>","text":"<p>Returns the node's unique identifier in the simulation</p> <p>Returns:</p> Type Description <code>int</code> <p>the node's unique identifier in the simulation</p> Source code in <code>gradysim/protocol/interface.py</code> <pre><code>@abstractmethod\ndef get_id(self) -&gt; int:\n    \"\"\"\n    Returns the node's unique identifier in the simulation\n\n    Returns:\n        the node's unique identifier in the simulation\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Modules/Protocol/#gradysim.protocol.interface.IProvider.schedule_timer","title":"<code>schedule_timer(timer, timestamp)</code>  <code>abstractmethod</code>","text":"<p>Schedules a timer that should fire at a specified timestamp</p> <p>Parameters:</p> Name Type Description Default <code>timer</code> <code>str</code> <p>the timer to schedule. Use this string to identify the timer when it fires, associate it with some serialized data, or anything else that can be represented as a string.</p> required <code>timestamp</code> <code>float</code> <p>the timestamp in simulation seconds at which the timer should fire.</p> required Source code in <code>gradysim/protocol/interface.py</code> <pre><code>@abstractmethod\ndef schedule_timer(self, timer: str, timestamp: float) -&gt; None:\n    \"\"\"\n    Schedules a timer that should fire at a specified timestamp\n\n    Args:\n        timer: the timer to schedule. Use this string to identify the timer when it fires, associate it with some\n            serialized data, or anything else that can be represented as a string.\n        timestamp: the timestamp in simulation seconds at which the timer should fire.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Modules/Protocol/#gradysim.protocol.interface.IProvider.send_communication_command","title":"<code>send_communication_command(command)</code>  <code>abstractmethod</code>","text":"<p>Sends a communication command to the node's communication module</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>CommunicationCommand</code> <p>the communication command to send</p> required Source code in <code>gradysim/protocol/interface.py</code> <pre><code>@abstractmethod\ndef send_communication_command(self, command: CommunicationCommand) -&gt; None:\n    \"\"\"\n    Sends a communication command to the node's communication module\n\n    Args:\n        command: the communication command to send\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Modules/Protocol/#gradysim.protocol.interface.IProvider.send_mobility_command","title":"<code>send_mobility_command(command)</code>  <code>abstractmethod</code>","text":"<p>Sends a mobility command to the node's mobility module</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>MobilityCommand</code> <p>the mobility command to send</p> required Source code in <code>gradysim/protocol/interface.py</code> <pre><code>@abstractmethod\ndef send_mobility_command(self, command: MobilityCommand) -&gt; None:\n    \"\"\"\n    Sends a mobility command to the node's mobility module\n\n    Args:\n        command: the mobility command to send\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Modules/Protocol/position/","title":"Position","text":""},{"location":"Modules/Protocol/position/#gradysim.protocol.position","title":"<code>gradysim.protocol.position</code>","text":"<p>This module contains some helpers useful when working with positions. Positions are used to localize the nodes inside the python simulation.</p>"},{"location":"Modules/Protocol/position/#gradysim.protocol.position.Position","title":"<code>Position = Tuple[float, float, float]</code>  <code>module-attribute</code>","text":"<p>Represents a node's position inside the simulation. It is a tuple of three floating point numbers representing the euclidean coordinates of the node.</p>"},{"location":"Modules/Protocol/position/#gradysim.protocol.position.squared_distance","title":"<code>squared_distance(start, end)</code>","text":"<p>Calculates the squared distance between two positions.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Position</code> <p>First position</p> required <code>end</code> <code>Position</code> <p>Second position</p> required <p>Returns:</p> Type Description <code>float</code> <p>The distance squared</p> Source code in <code>gradysim/protocol/position.py</code> <pre><code>def squared_distance(start: Position, end: Position) -&gt; float:\n    \"\"\"\n    Calculates the squared distance between two positions.\n\n    Args:\n        start: First position\n        end: Second position\n\n    Returns:\n        The distance squared\n    \"\"\"\n    return (end[0] - start[0]) ** 2 + (end[1] - start[1]) ** 2 + (end[2] - start[2]) ** 2\n</code></pre>"},{"location":"Modules/Protocol/messages/","title":"Introduction","text":""},{"location":"Modules/Protocol/messages/#gradysim.protocol.messages","title":"<code>gradysim.protocol.messages</code>","text":"<p>This module defines messages used to exchange information between modules. Communication and mobility commands are messages that are sent to the communication and mobility modules respectively. Telemetry is a message that is sent from the mobility module to the protocol. It contains information about the node's mobility.</p>"},{"location":"Modules/Protocol/messages/communication/","title":"Communication","text":""},{"location":"Modules/Protocol/messages/communication/#gradysim.protocol.messages.communication","title":"<code>gradysim.protocol.messages.communication</code>","text":"<p>This file contains definitions for the communication commands. These commands are sent to the communication module to instruct it to perform some communication action, generally sending a message to another node.</p>"},{"location":"Modules/Protocol/messages/communication/#gradysim.protocol.messages.communication.CommunicationCommand","title":"<code>CommunicationCommand</code>  <code>dataclass</code>","text":"<p>Represents a communication command. Communication commands are sent to the communication module to instruct it to perform some communication action, generally sending a message to another node.</p> Source code in <code>gradysim/protocol/messages/communication.py</code> <pre><code>@dataclass\nclass CommunicationCommand:\n    \"\"\"\n    Represents a communication command. Communication commands are sent to the communication module to instruct it to\n    perform some communication action, generally sending a message to another node.\n    \"\"\"\n    command_type: CommunicationCommandType\n    \"\"\"The type of the communication command\"\"\"\n\n    message: str\n    \"\"\"The message to send\"\"\"\n\n    destination: Optional[int] = None\n    \"\"\"The destination node ID. It's not necessary for a broadcast message\"\"\"\n</code></pre>"},{"location":"Modules/Protocol/messages/communication/#gradysim.protocol.messages.communication.CommunicationCommand.command_type","title":"<code>command_type: CommunicationCommandType</code>  <code>instance-attribute</code>","text":"<p>The type of the communication command</p>"},{"location":"Modules/Protocol/messages/communication/#gradysim.protocol.messages.communication.CommunicationCommand.destination","title":"<code>destination: Optional[int] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The destination node ID. It's not necessary for a broadcast message</p>"},{"location":"Modules/Protocol/messages/communication/#gradysim.protocol.messages.communication.CommunicationCommand.message","title":"<code>message: str</code>  <code>instance-attribute</code>","text":"<p>The message to send</p>"},{"location":"Modules/Protocol/messages/communication/#gradysim.protocol.messages.communication.CommunicationCommandType","title":"<code>CommunicationCommandType</code>","text":"<p>               Bases: <code>int</code>, <code>Enum</code></p> <p>Enum that defines the types of communication commands</p> Source code in <code>gradysim/protocol/messages/communication.py</code> <pre><code>class CommunicationCommandType(int, Enum):\n    \"\"\"\n    Enum that defines the types of communication commands\n    \"\"\"\n    SEND = 0\n    \"\"\"Send a message to a specific node\"\"\"\n    BROADCAST = 1\n    \"\"\"Send a message to all nodes\"\"\"\n</code></pre>"},{"location":"Modules/Protocol/messages/communication/#gradysim.protocol.messages.communication.CommunicationCommandType.BROADCAST","title":"<code>BROADCAST = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Send a message to all nodes</p>"},{"location":"Modules/Protocol/messages/communication/#gradysim.protocol.messages.communication.CommunicationCommandType.SEND","title":"<code>SEND = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Send a message to a specific node</p>"},{"location":"Modules/Protocol/messages/mobility/","title":"Mobility","text":""},{"location":"Modules/Protocol/messages/mobility/#gradysim.protocol.messages.mobility","title":"<code>gradysim.protocol.messages.mobility</code>","text":"<p>This file defines mobility commands. Mobility commands are sent to the mobility module to instruct it to perform some mobility action, like moving the node to a new location.</p>"},{"location":"Modules/Protocol/messages/mobility/#gradysim.protocol.messages.mobility.GotoCoordsMobilityCommand","title":"<code>GotoCoordsMobilityCommand</code>","text":"<p>               Bases: <code>MobilityCommand</code></p> <p>Represents a mobility command that instructs the mobility module to move the node to a new location. The new location is specified by its x, y, and z coordinates.</p> Source code in <code>gradysim/protocol/messages/mobility.py</code> <pre><code>class GotoCoordsMobilityCommand(MobilityCommand):\n    \"\"\"\n    Represents a mobility command that instructs the mobility module to move the node to a new location. The new\n    location is specified by its x, y, and z coordinates.\n    \"\"\"\n\n    def __init__(self, x: float, y: float, z: float):\n        \"\"\"\n        Initializes a GoToCoordsMobilityCommand\n\n        Args:\n            x: x coords of the new location\n            y: y coords of the new location\n            z: z coords of the new location\n        \"\"\"\n\n        super().__init__(MobilityCommandType.GOTO_COORDS, x, y, z)\n</code></pre>"},{"location":"Modules/Protocol/messages/mobility/#gradysim.protocol.messages.mobility.GotoCoordsMobilityCommand.__init__","title":"<code>__init__(x, y, z)</code>","text":"<p>Initializes a GoToCoordsMobilityCommand</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>x coords of the new location</p> required <code>y</code> <code>float</code> <p>y coords of the new location</p> required <code>z</code> <code>float</code> <p>z coords of the new location</p> required Source code in <code>gradysim/protocol/messages/mobility.py</code> <pre><code>def __init__(self, x: float, y: float, z: float):\n    \"\"\"\n    Initializes a GoToCoordsMobilityCommand\n\n    Args:\n        x: x coords of the new location\n        y: y coords of the new location\n        z: z coords of the new location\n    \"\"\"\n\n    super().__init__(MobilityCommandType.GOTO_COORDS, x, y, z)\n</code></pre>"},{"location":"Modules/Protocol/messages/mobility/#gradysim.protocol.messages.mobility.GotoGeoCoordsMobilityCommand","title":"<code>GotoGeoCoordsMobilityCommand</code>","text":"<p>               Bases: <code>MobilityCommand</code></p> <p>Represents a mobility command that instructs the mobility module to move the node to a new location. The new location is specified by its x, y, and z coordinates.</p> Source code in <code>gradysim/protocol/messages/mobility.py</code> <pre><code>class GotoGeoCoordsMobilityCommand(MobilityCommand):\n    \"\"\"\n    Represents a mobility command that instructs the mobility module to move the node to a new location. The new\n    location is specified by its x, y, and z coordinates.\n    \"\"\"\n\n    def __init__(self, lat: float, lon: float, alt: float):\n        \"\"\"\n        Initializes a GoToCoordsMobilityCommand\n\n        Args:\n            lat: The latitude of the desired location\n            lon: The longitude of the desired location\n            alt: The altitude of the desired location\n        \"\"\"\n\n        super().__init__(MobilityCommandType.GOTO_GEO_COORDS, lat, lon, alt)\n</code></pre>"},{"location":"Modules/Protocol/messages/mobility/#gradysim.protocol.messages.mobility.GotoGeoCoordsMobilityCommand.__init__","title":"<code>__init__(lat, lon, alt)</code>","text":"<p>Initializes a GoToCoordsMobilityCommand</p> <p>Parameters:</p> Name Type Description Default <code>lat</code> <code>float</code> <p>The latitude of the desired location</p> required <code>lon</code> <code>float</code> <p>The longitude of the desired location</p> required <code>alt</code> <code>float</code> <p>The altitude of the desired location</p> required Source code in <code>gradysim/protocol/messages/mobility.py</code> <pre><code>def __init__(self, lat: float, lon: float, alt: float):\n    \"\"\"\n    Initializes a GoToCoordsMobilityCommand\n\n    Args:\n        lat: The latitude of the desired location\n        lon: The longitude of the desired location\n        alt: The altitude of the desired location\n    \"\"\"\n\n    super().__init__(MobilityCommandType.GOTO_GEO_COORDS, lat, lon, alt)\n</code></pre>"},{"location":"Modules/Protocol/messages/mobility/#gradysim.protocol.messages.mobility.MobilityCommand","title":"<code>MobilityCommand</code>  <code>dataclass</code>","text":"<p>Represents a mobility command. Mobility commands are sent to the mobility module to instruct it to perform some mobility action, like moving the node to a new location. The mobility command has 6 generic parameters whose meaning changes depending on the command type. You shouldn't use this class directly, use one of the subclasses instead (e.g. GotoCoordsMobilityCommand) to have properly typed parameters.</p> Source code in <code>gradysim/protocol/messages/mobility.py</code> <pre><code>@dataclass\nclass MobilityCommand:\n    \"\"\"\n    Represents a mobility command. Mobility commands are sent to the mobility module to instruct it to perform some\n    mobility action, like moving the node to a new location. The mobility command has 6 generic parameters whose\n    meaning changes depending on the command type. You shouldn't use this class directly, use one of the subclasses\n    instead (e.g. GotoCoordsMobilityCommand) to have properly typed parameters.\n    \"\"\"\n\n    command_type: MobilityCommandType\n    \"\"\"The type of the mobility command\"\"\"\n\n    param_1: float = 0\n    \"\"\"The first parameter of the mobility command, it's meaning changes depending on the command type\"\"\"\n\n    param_2: float = 0\n    \"\"\"The second parameter of the mobility command, it's meaning changes depending on the command type\"\"\"\n\n    param_3: float = 0\n    \"\"\"The third parameter of the mobility command, it's meaning changes depending on the command type\"\"\"\n\n    param_4: float = 0\n    \"\"\"The fourth parameter of the mobility command, it's meaning changes depending on the command type\"\"\"\n\n    param_5: float = 0\n    \"\"\"The fifth parameter of the mobility command, it's meaning changes depending on the command type\"\"\"\n\n    param_6: float = 0\n    \"\"\"The sixth parameter of the mobility command, it's meaning changes depending on the command type\"\"\"\n</code></pre>"},{"location":"Modules/Protocol/messages/mobility/#gradysim.protocol.messages.mobility.MobilityCommand.command_type","title":"<code>command_type: MobilityCommandType</code>  <code>instance-attribute</code>","text":"<p>The type of the mobility command</p>"},{"location":"Modules/Protocol/messages/mobility/#gradysim.protocol.messages.mobility.MobilityCommand.param_1","title":"<code>param_1: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The first parameter of the mobility command, it's meaning changes depending on the command type</p>"},{"location":"Modules/Protocol/messages/mobility/#gradysim.protocol.messages.mobility.MobilityCommand.param_2","title":"<code>param_2: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The second parameter of the mobility command, it's meaning changes depending on the command type</p>"},{"location":"Modules/Protocol/messages/mobility/#gradysim.protocol.messages.mobility.MobilityCommand.param_3","title":"<code>param_3: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The third parameter of the mobility command, it's meaning changes depending on the command type</p>"},{"location":"Modules/Protocol/messages/mobility/#gradysim.protocol.messages.mobility.MobilityCommand.param_4","title":"<code>param_4: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The fourth parameter of the mobility command, it's meaning changes depending on the command type</p>"},{"location":"Modules/Protocol/messages/mobility/#gradysim.protocol.messages.mobility.MobilityCommand.param_5","title":"<code>param_5: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The fifth parameter of the mobility command, it's meaning changes depending on the command type</p>"},{"location":"Modules/Protocol/messages/mobility/#gradysim.protocol.messages.mobility.MobilityCommand.param_6","title":"<code>param_6: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The sixth parameter of the mobility command, it's meaning changes depending on the command type</p>"},{"location":"Modules/Protocol/messages/mobility/#gradysim.protocol.messages.mobility.MobilityCommandType","title":"<code>MobilityCommandType</code>","text":"<p>               Bases: <code>int</code>, <code>Enum</code></p> <p>Enum that defines the types of mobility commands</p> Source code in <code>gradysim/protocol/messages/mobility.py</code> <pre><code>class MobilityCommandType(int, Enum):\n    \"\"\"\n    Enum that defines the types of mobility commands\n    \"\"\"\n    GOTO_COORDS = 1\n    \"\"\"Move the node to a new location specified by its x, y, and z euclidean coordinates\"\"\"\n\n    GOTO_GEO_COORDS = 2\n    \"\"\"Move the node to a new location specified by its latitude, longitude, and altitude\"\"\"\n\n    SET_SPEED = 3\n    \"\"\"Set the node's speed in m/s\"\"\"\n</code></pre>"},{"location":"Modules/Protocol/messages/mobility/#gradysim.protocol.messages.mobility.MobilityCommandType.GOTO_COORDS","title":"<code>GOTO_COORDS = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Move the node to a new location specified by its x, y, and z euclidean coordinates</p>"},{"location":"Modules/Protocol/messages/mobility/#gradysim.protocol.messages.mobility.MobilityCommandType.GOTO_GEO_COORDS","title":"<code>GOTO_GEO_COORDS = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Move the node to a new location specified by its latitude, longitude, and altitude</p>"},{"location":"Modules/Protocol/messages/mobility/#gradysim.protocol.messages.mobility.MobilityCommandType.SET_SPEED","title":"<code>SET_SPEED = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Set the node's speed in m/s</p>"},{"location":"Modules/Protocol/messages/mobility/#gradysim.protocol.messages.mobility.SetSpeedMobilityCommand","title":"<code>SetSpeedMobilityCommand</code>","text":"<p>               Bases: <code>MobilityCommand</code></p> <p>Represents a mobility command that sets the node's speed. The only parameter of this command is the desired speed in m/s.</p> Source code in <code>gradysim/protocol/messages/mobility.py</code> <pre><code>class SetSpeedMobilityCommand(MobilityCommand):\n    \"\"\"\n    Represents a mobility command that sets the node's speed. The only parameter of this command is the desired speed\n    in m/s.\n    \"\"\"\n\n    def __init__(self, speed: float):\n        \"\"\"\n        Initializes a SetSpeedMobilityCommand\n\n        Args:\n            speed: The desired speed in m/s\n        \"\"\"\n        super().__init__(MobilityCommandType.SET_SPEED, speed)\n</code></pre>"},{"location":"Modules/Protocol/messages/mobility/#gradysim.protocol.messages.mobility.SetSpeedMobilityCommand.__init__","title":"<code>__init__(speed)</code>","text":"<p>Initializes a SetSpeedMobilityCommand</p> <p>Parameters:</p> Name Type Description Default <code>speed</code> <code>float</code> <p>The desired speed in m/s</p> required Source code in <code>gradysim/protocol/messages/mobility.py</code> <pre><code>def __init__(self, speed: float):\n    \"\"\"\n    Initializes a SetSpeedMobilityCommand\n\n    Args:\n        speed: The desired speed in m/s\n    \"\"\"\n    super().__init__(MobilityCommandType.SET_SPEED, speed)\n</code></pre>"},{"location":"Modules/Protocol/plugins/","title":"Introduction","text":""},{"location":"Modules/Protocol/plugins/#gradysim.protocol.plugin","title":"<code>gradysim.protocol.plugin</code>","text":"<p>Plugins are a way to extend the functionality of the protocol. They don't follow a specific interface so learning how to use them should be done in a case-by-case basis. Generally they in some way they add new functionality to the protocol built on top of the primitives available to the protocol. They can be used to simplify the implementation of the protocol's mobility or communication logic, for example.</p>"},{"location":"Modules/Protocol/plugins/dispatcher/","title":"Dispatcher","text":""},{"location":"Modules/Protocol/plugins/dispatcher/#gradysim.protocol.plugin.dispatcher","title":"<code>gradysim.protocol.plugin.dispatcher</code>","text":"<p>This module contains a function that creates a dispatcher which wraps a protocol instance and it's methods. Implements  a call chain for each of the protocol interface's methods.</p> <p>Use this module through the create_dispatcher][gradysim.protocol.plugin.dispatcher.create_dispatcher] method, never instantiate the ProtocolWrapper directly.</p> <p>This module is useful if you want to implement an plugin on or some other functionality that relies on overriding the protocol's methods. Protocols using this plugin will still be compatible with all execution modes as only the protocol itself is tampered with and not any of the layers that allow it to run on different environments.</p> <p>Beware that this module uses monkey patching and may result in broken protocols if someone else tries to tamper with the protocol's methods.</p>"},{"location":"Modules/Protocol/plugins/dispatcher/#gradysim.protocol.plugin.dispatcher.DispatchReturn","title":"<code>DispatchReturn</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Return value for the dispatched funcions. INTERRUPT should be returned if your handler completely handled the call and it shouldn't be passed forward. CONTINUE should be called if the call should continue down the call chain.</p> Source code in <code>gradysim/protocol/plugin/dispatcher.py</code> <pre><code>class DispatchReturn(Enum):\n    \"\"\"\n    Return value for the dispatched funcions. INTERRUPT should be returned if your handler completely handled\n    the call and it shouldn't be passed forward. CONTINUE should be called if the call should continue down\n    the call chain.\n    \"\"\"\n    INTERRUPT = 1\n    CONTINUE = 2\n</code></pre>"},{"location":"Modules/Protocol/plugins/dispatcher/#gradysim.protocol.plugin.dispatcher.ProtocolWrapper","title":"<code>ProtocolWrapper</code>","text":"<p>Do not use this class directly, instead use create_dispatcher.</p> <p>Wraps the protocol's calls into a call chain. Instead of going directly to the protocol's methods calls to the protocol interface will be passed down a chain of registered handlers. The protocol's own method is at the end of the chain. Methods should return a value in the DispatchReturn Enum, INTERRUPT do interrupt the chain and CONTINUE if the message should be passed through.</p> Source code in <code>gradysim/protocol/plugin/dispatcher.py</code> <pre><code>class ProtocolWrapper:\n    \"\"\"\n    Do not use this class directly, instead use\n    [create_dispatcher][gradysim.protocol.plugin.dispatcher.create_dispatcher].\n\n    Wraps the protocol's calls into a call chain. Instead of going directly to the protocol's methods calls to the\n    protocol interface will be passed down a chain of registered handlers. The protocol's own method is at the end\n    of the chain. Methods should return a value in the DispatchReturn Enum, INTERRUPT do interrupt the chain and\n    CONTINUE if the message should be passed through.\n    \"\"\"\n    _protocol: IProtocol\n\n    _handle_initialize_chain: List[Callable[[IProtocol, int], None]]\n    _handle_timer_chain: List[Callable[[IProtocol, str], DispatchReturn]]\n    _handle_telemetry_chain: List[Callable[[IProtocol, Telemetry], DispatchReturn]]\n    _handle_packet_chain: List[Callable[[IProtocol, str], DispatchReturn]]\n    _finish_queue_chain: List[Callable[[], None]]\n\n    def __init__(self, protocol: IProtocol):\n        \"\"\"\n        Instantiates a protocol wrapper. Should not be instantiated directly, create a dispatcher using the\n        [create_dispatcher][gradysim.protocol.plugin.dispatcher.create_dispatcher] method.\n\n        **Do not instantiate this class directly**\n\n        Args:\n            protocol: Protocol whose calls will be wrapped\n        \"\"\"\n        self._protocol = protocol\n\n        self._handle_initialize_chain = []\n        self._handle_timer_chain = []\n        self._handle_telemetry_chain = []\n        self._handle_packet_chain = []\n        self._finish_queue_chain = []\n\n        _wrap_functionality(protocol, 'initialize', self._handle_initialize_chain)\n        _wrap_functionality(protocol, 'handle_timer', self._handle_timer_chain)\n        _wrap_functionality(protocol, 'handle_telemetry', self._handle_telemetry_chain)\n        _wrap_functionality(protocol, 'handle_packet', self._handle_packet_chain)\n        _wrap_functionality(protocol, 'finish', self._finish_queue_chain)\n\n    def register_initialize(self, handler: Callable[[IProtocol, int], None]) -&gt; None:\n        \"\"\"\n        Registers a handler for the [initialize][gradysim.protocol.interface.IProtocol.initialize] method. Handlers should\n        have the same signature as the initialize method. DispatcherReturn is not supported for this method, the call\n        chain is always followed.\n\n        Args:\n            handler: Handler being registered\n        \"\"\"\n        self._handle_initialize_chain.insert(0, handler)\n\n    def register_handle_timer(self, handler: Callable[[IProtocol, str], DispatchReturn]) -&gt; None:\n        \"\"\"\n        Registers a handler for the [handle_timer][gradysim.protocol.interface.IProtocol.handle_timer] method. Handlers should\n        have the same signature as the handle_timer method but return a value in the DispatcherReturn enum.\n\n        Args:\n            handler: Handler being registered\n        \"\"\"\n        self._handle_timer_chain.insert(0, handler)\n\n    def register_handle_telemetry(self, handler: Callable[[IProtocol, Telemetry], DispatchReturn]) -&gt; None:\n        \"\"\"\n        Registers a handler for the [handle_telemetry][gradysim.protocol.interface.IProtocol.handle_telemetry] method. Handlers\n        should have the same signature as the handle_telemetry method but return a value in the DispatcherReturn enum.\n\n        Args:\n            handler: Handler being registered\n        \"\"\"\n        self._handle_telemetry_chain.insert(0, handler)\n\n    def register_handle_packet(self, handler: Callable[[IProtocol, str], DispatchReturn]) -&gt; None:\n        \"\"\"\n        Registers a handler for the [handle_packet][gradysim.protocol.interface.IProtocol.handle_packet] method. Handlers should\n        have the same signature as the handle_packet method but return a value in the DispatcherReturn enum.\n\n        Args:\n            handler: Handler being registered\n        \"\"\"\n        self._handle_packet_chain.insert(0, handler)\n\n    def register_finish(self, handler: Callable[[IProtocol], None]) -&gt; None:\n        \"\"\"\n        Registers a handler for the [handle_timer][gradysim.protocol.interface.IProtocol.finish] method. Handlers should\n        have the same signature as the finish. This method doesn't support returning DispatchReturn values, the\n        call chain is always followed.\n\n        Not following this chain, since it is only called once, could result in improper finalization of protocols and\n        other handlers.\n\n        Args:\n            handler: Handler being registered\n        \"\"\"\n        self._finish_queue_chain.insert(0, handler)\n\n    def unregister_initialize(self, handler: Callable[[IProtocol, int], None]) -&gt; None:\n        \"\"\"\n        Unregisters a handle_initialize handler. Raises ValueError if handler was not registered\n\n        Args:\n            handler: Handler instance being unregistered\n        \"\"\"\n        self._handle_initialize_chain.remove(handler)\n\n    def unregister_handle_timer(self, handler: Callable[[IProtocol, str], DispatchReturn]) -&gt; None:\n        \"\"\"\n        Unregisters a handle_timer handler. Raises ValueError if handler was not registered\n\n        Args:\n            handler: Handler instance being unregistered\n        \"\"\"\n        self._handle_timer_chain.remove(handler)\n\n    def unregister_handle_telemetry(self, handler: Callable[[IProtocol, Telemetry], DispatchReturn]) -&gt; None:\n        \"\"\"\n        Unregisters a handle_timer handler. Raises ValueError if handler was not registered\n\n        Args:\n            handler: Handler instance being unregistered\n        \"\"\"\n        self._handle_telemetry_chain.remove(handler)\n\n    def unregister_handle_packet(self, handler: Callable[[IProtocol, str], DispatchReturn]) -&gt; None:\n        \"\"\"\n        Unregisters a handle_timer handler. Raises ValueError if handler was not registered\n\n        Args:\n            handler: Handler instance being unregistered\n        \"\"\"\n        self._handle_packet_chain.remove(handler)\n\n    def unregister_finish(self, handler: Callable[[IProtocol], None]) -&gt; None:\n        \"\"\"\n        Unregisters a handle_timer handler. Raises ValueError if handler was not registered\n\n        Args:\n            handler: Handler instance being unregistered\n        \"\"\"\n        self._finish_queue_chain.remove(handler)\n</code></pre>"},{"location":"Modules/Protocol/plugins/dispatcher/#gradysim.protocol.plugin.dispatcher.ProtocolWrapper.__init__","title":"<code>__init__(protocol)</code>","text":"<p>Instantiates a protocol wrapper. Should not be instantiated directly, create a dispatcher using the create_dispatcher method.</p> <p>Do not instantiate this class directly</p> <p>Parameters:</p> Name Type Description Default <code>protocol</code> <code>IProtocol</code> <p>Protocol whose calls will be wrapped</p> required Source code in <code>gradysim/protocol/plugin/dispatcher.py</code> <pre><code>def __init__(self, protocol: IProtocol):\n    \"\"\"\n    Instantiates a protocol wrapper. Should not be instantiated directly, create a dispatcher using the\n    [create_dispatcher][gradysim.protocol.plugin.dispatcher.create_dispatcher] method.\n\n    **Do not instantiate this class directly**\n\n    Args:\n        protocol: Protocol whose calls will be wrapped\n    \"\"\"\n    self._protocol = protocol\n\n    self._handle_initialize_chain = []\n    self._handle_timer_chain = []\n    self._handle_telemetry_chain = []\n    self._handle_packet_chain = []\n    self._finish_queue_chain = []\n\n    _wrap_functionality(protocol, 'initialize', self._handle_initialize_chain)\n    _wrap_functionality(protocol, 'handle_timer', self._handle_timer_chain)\n    _wrap_functionality(protocol, 'handle_telemetry', self._handle_telemetry_chain)\n    _wrap_functionality(protocol, 'handle_packet', self._handle_packet_chain)\n    _wrap_functionality(protocol, 'finish', self._finish_queue_chain)\n</code></pre>"},{"location":"Modules/Protocol/plugins/dispatcher/#gradysim.protocol.plugin.dispatcher.ProtocolWrapper.register_finish","title":"<code>register_finish(handler)</code>","text":"<p>Registers a handler for the handle_timer method. Handlers should have the same signature as the finish. This method doesn't support returning DispatchReturn values, the call chain is always followed.</p> <p>Not following this chain, since it is only called once, could result in improper finalization of protocols and other handlers.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>Callable[[IProtocol], None]</code> <p>Handler being registered</p> required Source code in <code>gradysim/protocol/plugin/dispatcher.py</code> <pre><code>def register_finish(self, handler: Callable[[IProtocol], None]) -&gt; None:\n    \"\"\"\n    Registers a handler for the [handle_timer][gradysim.protocol.interface.IProtocol.finish] method. Handlers should\n    have the same signature as the finish. This method doesn't support returning DispatchReturn values, the\n    call chain is always followed.\n\n    Not following this chain, since it is only called once, could result in improper finalization of protocols and\n    other handlers.\n\n    Args:\n        handler: Handler being registered\n    \"\"\"\n    self._finish_queue_chain.insert(0, handler)\n</code></pre>"},{"location":"Modules/Protocol/plugins/dispatcher/#gradysim.protocol.plugin.dispatcher.ProtocolWrapper.register_handle_packet","title":"<code>register_handle_packet(handler)</code>","text":"<p>Registers a handler for the handle_packet method. Handlers should have the same signature as the handle_packet method but return a value in the DispatcherReturn enum.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>Callable[[IProtocol, str], DispatchReturn]</code> <p>Handler being registered</p> required Source code in <code>gradysim/protocol/plugin/dispatcher.py</code> <pre><code>def register_handle_packet(self, handler: Callable[[IProtocol, str], DispatchReturn]) -&gt; None:\n    \"\"\"\n    Registers a handler for the [handle_packet][gradysim.protocol.interface.IProtocol.handle_packet] method. Handlers should\n    have the same signature as the handle_packet method but return a value in the DispatcherReturn enum.\n\n    Args:\n        handler: Handler being registered\n    \"\"\"\n    self._handle_packet_chain.insert(0, handler)\n</code></pre>"},{"location":"Modules/Protocol/plugins/dispatcher/#gradysim.protocol.plugin.dispatcher.ProtocolWrapper.register_handle_telemetry","title":"<code>register_handle_telemetry(handler)</code>","text":"<p>Registers a handler for the handle_telemetry method. Handlers should have the same signature as the handle_telemetry method but return a value in the DispatcherReturn enum.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>Callable[[IProtocol, Telemetry], DispatchReturn]</code> <p>Handler being registered</p> required Source code in <code>gradysim/protocol/plugin/dispatcher.py</code> <pre><code>def register_handle_telemetry(self, handler: Callable[[IProtocol, Telemetry], DispatchReturn]) -&gt; None:\n    \"\"\"\n    Registers a handler for the [handle_telemetry][gradysim.protocol.interface.IProtocol.handle_telemetry] method. Handlers\n    should have the same signature as the handle_telemetry method but return a value in the DispatcherReturn enum.\n\n    Args:\n        handler: Handler being registered\n    \"\"\"\n    self._handle_telemetry_chain.insert(0, handler)\n</code></pre>"},{"location":"Modules/Protocol/plugins/dispatcher/#gradysim.protocol.plugin.dispatcher.ProtocolWrapper.register_handle_timer","title":"<code>register_handle_timer(handler)</code>","text":"<p>Registers a handler for the handle_timer method. Handlers should have the same signature as the handle_timer method but return a value in the DispatcherReturn enum.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>Callable[[IProtocol, str], DispatchReturn]</code> <p>Handler being registered</p> required Source code in <code>gradysim/protocol/plugin/dispatcher.py</code> <pre><code>def register_handle_timer(self, handler: Callable[[IProtocol, str], DispatchReturn]) -&gt; None:\n    \"\"\"\n    Registers a handler for the [handle_timer][gradysim.protocol.interface.IProtocol.handle_timer] method. Handlers should\n    have the same signature as the handle_timer method but return a value in the DispatcherReturn enum.\n\n    Args:\n        handler: Handler being registered\n    \"\"\"\n    self._handle_timer_chain.insert(0, handler)\n</code></pre>"},{"location":"Modules/Protocol/plugins/dispatcher/#gradysim.protocol.plugin.dispatcher.ProtocolWrapper.register_initialize","title":"<code>register_initialize(handler)</code>","text":"<p>Registers a handler for the initialize method. Handlers should have the same signature as the initialize method. DispatcherReturn is not supported for this method, the call chain is always followed.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>Callable[[IProtocol, int], None]</code> <p>Handler being registered</p> required Source code in <code>gradysim/protocol/plugin/dispatcher.py</code> <pre><code>def register_initialize(self, handler: Callable[[IProtocol, int], None]) -&gt; None:\n    \"\"\"\n    Registers a handler for the [initialize][gradysim.protocol.interface.IProtocol.initialize] method. Handlers should\n    have the same signature as the initialize method. DispatcherReturn is not supported for this method, the call\n    chain is always followed.\n\n    Args:\n        handler: Handler being registered\n    \"\"\"\n    self._handle_initialize_chain.insert(0, handler)\n</code></pre>"},{"location":"Modules/Protocol/plugins/dispatcher/#gradysim.protocol.plugin.dispatcher.ProtocolWrapper.unregister_finish","title":"<code>unregister_finish(handler)</code>","text":"<p>Unregisters a handle_timer handler. Raises ValueError if handler was not registered</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>Callable[[IProtocol], None]</code> <p>Handler instance being unregistered</p> required Source code in <code>gradysim/protocol/plugin/dispatcher.py</code> <pre><code>def unregister_finish(self, handler: Callable[[IProtocol], None]) -&gt; None:\n    \"\"\"\n    Unregisters a handle_timer handler. Raises ValueError if handler was not registered\n\n    Args:\n        handler: Handler instance being unregistered\n    \"\"\"\n    self._finish_queue_chain.remove(handler)\n</code></pre>"},{"location":"Modules/Protocol/plugins/dispatcher/#gradysim.protocol.plugin.dispatcher.ProtocolWrapper.unregister_handle_packet","title":"<code>unregister_handle_packet(handler)</code>","text":"<p>Unregisters a handle_timer handler. Raises ValueError if handler was not registered</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>Callable[[IProtocol, str], DispatchReturn]</code> <p>Handler instance being unregistered</p> required Source code in <code>gradysim/protocol/plugin/dispatcher.py</code> <pre><code>def unregister_handle_packet(self, handler: Callable[[IProtocol, str], DispatchReturn]) -&gt; None:\n    \"\"\"\n    Unregisters a handle_timer handler. Raises ValueError if handler was not registered\n\n    Args:\n        handler: Handler instance being unregistered\n    \"\"\"\n    self._handle_packet_chain.remove(handler)\n</code></pre>"},{"location":"Modules/Protocol/plugins/dispatcher/#gradysim.protocol.plugin.dispatcher.ProtocolWrapper.unregister_handle_telemetry","title":"<code>unregister_handle_telemetry(handler)</code>","text":"<p>Unregisters a handle_timer handler. Raises ValueError if handler was not registered</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>Callable[[IProtocol, Telemetry], DispatchReturn]</code> <p>Handler instance being unregistered</p> required Source code in <code>gradysim/protocol/plugin/dispatcher.py</code> <pre><code>def unregister_handle_telemetry(self, handler: Callable[[IProtocol, Telemetry], DispatchReturn]) -&gt; None:\n    \"\"\"\n    Unregisters a handle_timer handler. Raises ValueError if handler was not registered\n\n    Args:\n        handler: Handler instance being unregistered\n    \"\"\"\n    self._handle_telemetry_chain.remove(handler)\n</code></pre>"},{"location":"Modules/Protocol/plugins/dispatcher/#gradysim.protocol.plugin.dispatcher.ProtocolWrapper.unregister_handle_timer","title":"<code>unregister_handle_timer(handler)</code>","text":"<p>Unregisters a handle_timer handler. Raises ValueError if handler was not registered</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>Callable[[IProtocol, str], DispatchReturn]</code> <p>Handler instance being unregistered</p> required Source code in <code>gradysim/protocol/plugin/dispatcher.py</code> <pre><code>def unregister_handle_timer(self, handler: Callable[[IProtocol, str], DispatchReturn]) -&gt; None:\n    \"\"\"\n    Unregisters a handle_timer handler. Raises ValueError if handler was not registered\n\n    Args:\n        handler: Handler instance being unregistered\n    \"\"\"\n    self._handle_timer_chain.remove(handler)\n</code></pre>"},{"location":"Modules/Protocol/plugins/dispatcher/#gradysim.protocol.plugin.dispatcher.ProtocolWrapper.unregister_initialize","title":"<code>unregister_initialize(handler)</code>","text":"<p>Unregisters a handle_initialize handler. Raises ValueError if handler was not registered</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>Callable[[IProtocol, int], None]</code> <p>Handler instance being unregistered</p> required Source code in <code>gradysim/protocol/plugin/dispatcher.py</code> <pre><code>def unregister_initialize(self, handler: Callable[[IProtocol, int], None]) -&gt; None:\n    \"\"\"\n    Unregisters a handle_initialize handler. Raises ValueError if handler was not registered\n\n    Args:\n        handler: Handler instance being unregistered\n    \"\"\"\n    self._handle_initialize_chain.remove(handler)\n</code></pre>"},{"location":"Modules/Protocol/plugins/dispatcher/#gradysim.protocol.plugin.dispatcher.create_dispatcher","title":"<code>create_dispatcher(protocol)</code>","text":"<p>Creates a dispatcher which wraps a protocol instance and it's methods. Implements a call chain for each of the protocol interface's methods. The class returned from this function can be used to add functions to the call chain of those wrapped methods. The original method implementation is not lost.</p> <p>Is a protocol that was already wrapped is passed as an argument, return the wrapper for that protocol.</p> <p>Beware that this module uses monkey patching and may result in broken protocols if someone else tries to tamper with the protocol's methods.</p> <p>If you want to implement an plugin or some other behaviour that requires overriding protocol's methods you should use this function</p> <p>Parameters:</p> Name Type Description Default <code>protocol</code> <code>IProtocol</code> <p>Protocol being wrapped</p> required <p>Returns:</p> Type Description <code>ProtocolWrapper</code> <p>ProtocolWrapper instance that allows methods to be added to the call chain</p> Source code in <code>gradysim/protocol/plugin/dispatcher.py</code> <pre><code>def create_dispatcher(protocol: IProtocol) -&gt; ProtocolWrapper:\n    \"\"\"\n    Creates a dispatcher which wraps a protocol instance and it's methods. Implements a call chain for each of the\n    protocol interface's methods. The class returned from this function can be used to add functions to the call chain\n    of those wrapped methods. The original method implementation is not lost.\n\n    Is a protocol that was already wrapped is passed as an argument, return the wrapper for that protocol.\n\n    Beware that this module uses monkey patching and may result in broken protocols if someone else tries to tamper with\n    the protocol's methods.\n\n    If you want to implement an plugin or some other behaviour that requires overriding protocol's\n    methods you should use this function\n\n    Args:\n        protocol: Protocol being wrapped\n\n    Returns:\n        ProtocolWrapper instance that allows methods to be added to the call chain\n    \"\"\"\n    global _protocol_wrappers\n    if protocol not in _protocol_wrappers:\n        _protocol_wrappers[protocol] = ProtocolWrapper(protocol)\n\n    return _protocol_wrappers[protocol]\n</code></pre>"},{"location":"Modules/Protocol/plugins/follow_mobility/","title":"Follow Mobility","text":""},{"location":"Modules/Protocol/plugins/follow_mobility/#gradysim.protocol.plugin.follow_mobility","title":"<code>gradysim.protocol.plugin.follow_mobility</code>","text":"<p>This module declares two plugin for the protocol: a leader and a follower. The leader broadcasts its position and the follower follows it.</p> <p>Beware that this plugin controls your protocol's mobility to implement its behaviour, so you should not use any other mobility plugin with it or implement any mobility behaviour in your protocol. The MobilityLeaderPlugin does not affect the node's movement and thus should be fine to use with other mobility plugin or mobility behaviour.</p>"},{"location":"Modules/Protocol/plugins/follow_mobility/#gradysim.protocol.plugin.follow_mobility.BROADCAST_TIMER_TAG","title":"<code>BROADCAST_TIMER_TAG = 'FollowMobilityPlugin__leader_broadcast_timer'</code>  <code>module-attribute</code>","text":"<p>The leader will broadcast its position using a timer with this name, make sure it doesn't conflict with other timers</p>"},{"location":"Modules/Protocol/plugins/follow_mobility/#gradysim.protocol.plugin.follow_mobility.FOLLOWER_TAG","title":"<code>FOLLOWER_TAG = 'FollowMobilityPlugin__follower'</code>  <code>module-attribute</code>","text":""},{"location":"Modules/Protocol/plugins/follow_mobility/#gradysim.protocol.plugin.follow_mobility.LEADER_TAG","title":"<code>LEADER_TAG = 'FollowMobilityPlugin__leader'</code>  <code>module-attribute</code>","text":"<p>The leader will broadcast its position using a packet with this tag, make sure it doesn't conflict with other packets</p>"},{"location":"Modules/Protocol/plugins/follow_mobility/#gradysim.protocol.plugin.follow_mobility.MobilityFollowerConfiguration","title":"<code>MobilityFollowerConfiguration</code>  <code>dataclass</code>","text":"Source code in <code>gradysim/protocol/plugin/follow_mobility.py</code> <pre><code>@dataclass\nclass MobilityFollowerConfiguration:\n    scanning_interval: float = 0.5\n    \"\"\"\n    Interval between leader scans, in simulation seconds. The follower will update the list of leaders and the current \n    leader.\n    \"\"\"\n\n    leader_timeout: float = 2\n    \"\"\"\n    After this amount of simulation seconds without receiving a broadcast from the leader, we consider it\n    disconnected\n    \"\"\"\n\n    auto_follow: bool = True\n    \"\"\"\n    Automatically follows the first leader available if set to True. If set to False, the user must call \n    follow_leader manually. If True the user can still call follow_leader to follow a specific leader, but if connection\n    to that leader is lost the follower will automatically follow the first leader available.\n    \"\"\"\n</code></pre>"},{"location":"Modules/Protocol/plugins/follow_mobility/#gradysim.protocol.plugin.follow_mobility.MobilityFollowerConfiguration.auto_follow","title":"<code>auto_follow: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Automatically follows the first leader available if set to True. If set to False, the user must call  follow_leader manually. If True the user can still call follow_leader to follow a specific leader, but if connection to that leader is lost the follower will automatically follow the first leader available.</p>"},{"location":"Modules/Protocol/plugins/follow_mobility/#gradysim.protocol.plugin.follow_mobility.MobilityFollowerConfiguration.leader_timeout","title":"<code>leader_timeout: float = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>After this amount of simulation seconds without receiving a broadcast from the leader, we consider it disconnected</p>"},{"location":"Modules/Protocol/plugins/follow_mobility/#gradysim.protocol.plugin.follow_mobility.MobilityFollowerConfiguration.scanning_interval","title":"<code>scanning_interval: float = 0.5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Interval between leader scans, in simulation seconds. The follower will update the list of leaders and the current  leader.</p>"},{"location":"Modules/Protocol/plugins/follow_mobility/#gradysim.protocol.plugin.follow_mobility.MobilityFollowerPlugin","title":"<code>MobilityFollowerPlugin</code>","text":"Source code in <code>gradysim/protocol/plugin/follow_mobility.py</code> <pre><code>class MobilityFollowerPlugin:\n    _leader: Optional[int] = None\n    _leader_position: Optional[Position] = None\n\n    _relative_position: Position = (0, 0, 0)\n\n    _last_leader_broadcast: Dict[int, float]\n\n    def __init__(self, protocol: IProtocol,\n                 configuration: MobilityFollowerConfiguration = MobilityFollowerConfiguration()):\n        self._config = configuration\n\n        self._protocol = protocol\n        self._dispatcher = create_dispatcher(protocol)\n\n        self._last_leader_broadcast = {}\n\n        self._initialize_following()\n        self._initialize_scanning()\n\n    def _initialize_following(self):\n        \"\"\"Initializes leader following behaviour\"\"\"\n\n        def follow_handler(_instance: IProtocol, message: str):\n            if not message.startswith(LEADER_TAG):\n                return DispatchReturn.CONTINUE\n\n            leader_payload = json.loads(message[len(f\"{LEADER_TAG}:\"):])\n            leader_id = leader_payload[\"id\"]\n            self._last_leader_broadcast[leader_id] = self._protocol.provider.current_time()\n\n            if leader_id == self._leader:\n                self._leader_position = leader_payload[\"position\"]\n\n                # Going to the leader's position at relative coordinates\n                destination = (coord + relative_coord\n                               for coord, relative_coord in zip(self._leader_position, self._relative_position))\n                mobility_command = GotoCoordsMobilityCommand(*destination)\n                self._protocol.provider.send_mobility_command(mobility_command)\n\n                # Informing the leader that we are following him\n                command = CommunicationCommand(\n                    CommunicationCommandType.SEND,\n                    f\"{FOLLOWER_TAG}:{self._protocol.provider.get_id()}\",\n                    leader_id\n                )\n                self._protocol.provider.send_communication_command(command)\n\n            return DispatchReturn.INTERRUPT\n\n        self._dispatcher.register_handle_packet(follow_handler)\n\n    def _initialize_scanning(self):\n        \"\"\"Periodically updates the list of current leaders\"\"\"\n\n        def scan_handler(_instance: IProtocol, timer: str):\n            if timer != FOLLOWER_TIMER_TAG:\n                return DispatchReturn.CONTINUE\n\n            self._last_leader_broadcast = {\n                leader_id: last_broadcast\n                for leader_id, last_broadcast in self._last_leader_broadcast.items()\n                if self._protocol.provider.current_time() - last_broadcast &lt; self._config.leader_timeout\n            }\n\n            if self._leader is not None and self._leader not in self._last_leader_broadcast:\n                self._leader = None\n                self._leader_position = None\n\n            if self._leader is None and len(self.available_leaders) &gt; 0:\n                self.follow_leader(list(self.available_leaders)[0])\n\n            self._protocol.provider.schedule_timer(\n                FOLLOWER_TIMER_TAG,\n                self._protocol.provider.current_time() + self._config.scanning_interval\n            )\n            return DispatchReturn.INTERRUPT\n\n        self._dispatcher.register_handle_timer(scan_handler)\n\n        self._protocol.provider.schedule_timer(FOLLOWER_TIMER_TAG, self._config.scanning_interval)\n\n    @property\n    def available_leaders(self) -&gt; Set[int]:\n        return set(self._last_leader_broadcast.keys())\n\n    @property\n    def current_leader(self) -&gt; Optional[int]:\n        return self._leader\n\n    @property\n    def relative_position(self) -&gt; Position:\n        return self._relative_position\n\n    @property\n    def current_leader_position(self) -&gt; Optional[Position]:\n        return self._leader_position\n\n    def follow_leader(self, leader_id: int) -&gt; None:\n        if leader_id not in self.available_leaders:\n            raise FollowMobilityException(f\"Leader {leader_id} is not available\")\n        self._leader = leader_id\n\n    def set_relative_position(self, position: Position) -&gt; None:\n        self._relative_position = position\n</code></pre>"},{"location":"Modules/Protocol/plugins/follow_mobility/#gradysim.protocol.plugin.follow_mobility.MobilityLeaderConfiguration","title":"<code>MobilityLeaderConfiguration</code>  <code>dataclass</code>","text":"Source code in <code>gradysim/protocol/plugin/follow_mobility.py</code> <pre><code>@dataclass\nclass MobilityLeaderConfiguration:\n    broadcast_interval: float = 0.02\n    \"\"\"The interval at which the leader broadcasts its position\"\"\"\n\n    follower_timeout: float = 5\n    \"\"\"\n    If we don't receive a message from a follower for this amount of simulation seconds we consider it disconnected\n    \"\"\"\n</code></pre>"},{"location":"Modules/Protocol/plugins/follow_mobility/#gradysim.protocol.plugin.follow_mobility.MobilityLeaderConfiguration.broadcast_interval","title":"<code>broadcast_interval: float = 0.02</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The interval at which the leader broadcasts its position</p>"},{"location":"Modules/Protocol/plugins/follow_mobility/#gradysim.protocol.plugin.follow_mobility.MobilityLeaderConfiguration.follower_timeout","title":"<code>follower_timeout: float = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If we don't receive a message from a follower for this amount of simulation seconds we consider it disconnected</p>"},{"location":"Modules/Protocol/plugins/follow_mobility/#gradysim.protocol.plugin.follow_mobility.MobilityLeaderPlugin","title":"<code>MobilityLeaderPlugin</code>","text":"Source code in <code>gradysim/protocol/plugin/follow_mobility.py</code> <pre><code>class MobilityLeaderPlugin:\n    _position: Position\n\n    _last_connection_from_follower: Dict[int, float]\n    \"\"\"Last broadcast round in which a follower was connected\"\"\"\n\n    def __init__(self, protocol: IProtocol, configuration: MobilityLeaderConfiguration = MobilityLeaderConfiguration()):\n        self._config = configuration\n        self._protocol = protocol\n        self._dispatcher = create_dispatcher(protocol)\n        self._last_connection_from_follower = {}\n        self._position = (0, 0, 0)\n        self.is_broadcasting = False\n\n        self._initialize_position_watching()\n        self._initialize_broadcast()\n        self._initialize_listening()\n\n    @property\n    def followers(self) -&gt; Set[int]:\n        return set(self._last_connection_from_follower.keys())\n\n    def _cull_disconnected_followers(self) -&gt; None:\n        \"\"\"Culls disconnected followers\"\"\"\n        self._last_connection_from_follower = {\n            follower_id: last_broadcast_round\n            for follower_id, last_broadcast_round in self._last_connection_from_follower.items()\n            if self._broadcast_round - last_broadcast_round &lt; self._config.follower_timeout\n        }\n\n    def _initialize_position_watching(self) -&gt; None:\n        \"\"\"Listens for position updates from the position module\"\"\"\n\n        def position_handler(_instance: IProtocol, telemetry: Telemetry) -&gt; DispatchReturn:\n            self._position = telemetry.current_position\n            return DispatchReturn.CONTINUE\n\n        self._dispatcher.register_handle_telemetry(position_handler)\n\n    def _initialize_broadcast(self) -&gt; None:\n        \"\"\"Initializes position broadcast\"\"\"\n\n        def broadcast_handler(_instance: IProtocol, timer: str):\n            if timer != BROADCAST_TIMER_TAG:\n                return DispatchReturn.CONTINUE\n\n            leader_payload = {\n                \"id\": self._protocol.provider.get_id(),\n                \"position\": self._position\n            }\n\n            command = CommunicationCommand(\n                CommunicationCommandType.BROADCAST,\n                f\"{LEADER_TAG}:{json.dumps(leader_payload)}\"\n            )\n            self._protocol.provider.send_communication_command(command)\n\n            self._cull_disconnected_followers()\n\n            self._broadcast_round += 1\n\n            self._protocol.provider.schedule_timer(\n                BROADCAST_TIMER_TAG,\n                self._protocol.provider.current_time() + self._config.broadcast_interval\n            )\n            return DispatchReturn.INTERRUPT\n\n        self._dispatcher.register_handle_timer(broadcast_handler)\n\n        self._protocol.provider.schedule_timer(BROADCAST_TIMER_TAG, self._config.broadcast_interval)\n        self.is_broadcasting = True\n        self._broadcast_round = 0\n\n    def _initialize_listening(self) -&gt; None:\n        \"\"\"Listens for messages from followers\"\"\"\n\n        def listen_handler(_instance: IProtocol, message: str):\n            if not message.startswith(FOLLOWER_TAG):\n                return DispatchReturn.CONTINUE\n\n            follower_id = int(message.split(\":\")[1])\n            self._last_connection_from_follower[follower_id] = self._broadcast_round\n\n            return DispatchReturn.INTERRUPT\n\n        self._dispatcher.register_handle_packet(listen_handler)\n</code></pre>"},{"location":"Modules/Protocol/plugins/mission_mobility/","title":"Mission Mobility","text":""},{"location":"Modules/Protocol/plugins/mission_mobility/#gradysim.protocol.plugin.mission_mobility","title":"<code>gradysim.protocol.plugin.mission_mobility</code>","text":""},{"location":"Modules/Protocol/plugins/mission_mobility/#gradysim.protocol.plugin.mission_mobility.MissionMobilityConfiguration","title":"<code>MissionMobilityConfiguration</code>  <code>dataclass</code>","text":"Source code in <code>gradysim/protocol/plugin/mission_mobility.py</code> <pre><code>@dataclass\nclass MissionMobilityConfiguration:\n    speed: float = 5\n    \"\"\"Speed in m/s the node will travel at during the mission\"\"\"\n\n    loop_mission: LoopMission = LoopMission.NO\n    \"\"\"\n    Configures how the mission should loop. If NO, the mission will end after reaching the final waypoint, this means\n    that you would need to call start_mission again if you want it to follow another mission. If RESTART, the node will\n    travel to the first waypoint of the mission and start the mission again. If REVERSE, will travel the mission in \n    reverse until the first waypoint, when it will start travelling the mission normally again.\n    \"\"\"\n\n    tolerance: float = 0.5\n    \"\"\"\n    If the node is within this distance of a waypoint it is considered to have reached it.\n    \"\"\"\n</code></pre>"},{"location":"Modules/Protocol/plugins/mission_mobility/#gradysim.protocol.plugin.mission_mobility.MissionMobilityConfiguration.loop_mission","title":"<code>loop_mission: LoopMission = LoopMission.NO</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Configures how the mission should loop. If NO, the mission will end after reaching the final waypoint, this means that you would need to call start_mission again if you want it to follow another mission. If RESTART, the node will travel to the first waypoint of the mission and start the mission again. If REVERSE, will travel the mission in  reverse until the first waypoint, when it will start travelling the mission normally again.</p>"},{"location":"Modules/Protocol/plugins/mission_mobility/#gradysim.protocol.plugin.mission_mobility.MissionMobilityConfiguration.speed","title":"<code>speed: float = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Speed in m/s the node will travel at during the mission</p>"},{"location":"Modules/Protocol/plugins/mission_mobility/#gradysim.protocol.plugin.mission_mobility.MissionMobilityConfiguration.tolerance","title":"<code>tolerance: float = 0.5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If the node is within this distance of a waypoint it is considered to have reached it.</p>"},{"location":"Modules/Protocol/plugins/mission_mobility/#gradysim.protocol.plugin.mission_mobility.MissionMobilityPlugin","title":"<code>MissionMobilityPlugin</code>","text":"<p>Use this plugin if you want your node to follow a fixed list of positions, or waypoints. The waypoints will be followed in order after they are received by the start_mission method. You can stop the mission at any time using stop_mission. The current_waypoint, is_reversed and is_idle properties can be used to check the current mission status.</p> <p>Beware that if any mobility commands are sent by your protocol or any of its plugin while a mission is in progress, the mission is in high risk of breaking. If sending a mobility command is necessary, stop the mission and restart it.</p> Source code in <code>gradysim/protocol/plugin/mission_mobility.py</code> <pre><code>class MissionMobilityPlugin:\n    \"\"\"\n    Use this plugin if you want your node to follow a fixed list of positions, or waypoints. The waypoints will be\n    followed in order after they are received by the start_mission method. You can stop the mission\n    at any time using stop_mission. The current_waypoint, is_reversed and is_idle properties can be used to check\n    the current mission status.\n\n    Beware that if any mobility commands are sent by your protocol or any of its plugin while a mission is in progress,\n    the mission is in high risk of breaking. If sending a mobility command is necessary, stop the mission and restart\n    it.\n    \"\"\"\n\n    def __init__(self,\n                 protocol: IProtocol,\n                 configuration: MissionMobilityConfiguration = MissionMobilityConfiguration()):\n        self._dispatcher = create_dispatcher(protocol)\n        self._instance = protocol\n        self._config = configuration\n        self._logger = logging.getLogger()\n\n        self._initialize_telemetry_handling()\n\n    _current_mission: Optional[List[Position]] = None\n    _is_reversed: bool = False\n    _is_idle: bool = True\n    _current_waypoint: Optional[int] = None\n\n    def _initialize_telemetry_handling(self) -&gt; None:\n        def telemetry_handler(_instance: IProtocol, telemetry: Telemetry) -&gt; DispatchReturn:\n            if self._current_mission is None:\n                return DispatchReturn.CONTINUE\n\n\n            if self._has_reached_target(telemetry.current_position):\n                self._progress_current_waypoint()\n                self._travel_to_current_waypoint()\n\n        self._dispatcher.register_handle_telemetry(telemetry_handler)\n\n    def _has_reached_target(self, current_position: Position):\n        if self._current_waypoint is None:\n            return False\n\n        target_position = self._current_mission[self._current_waypoint]\n        return squared_distance(current_position, target_position) &lt;= self._config.tolerance ** 2\n\n    def _progress_current_waypoint(self):\n        if self._current_mission is None:\n            return\n\n        if self._is_reversed:\n            self._current_waypoint -= 1\n        else:\n            self._current_waypoint += 1\n\n        if self._has_overran_bounds():\n            if self._config.loop_mission == LoopMission.NO:\n                self.stop_mission()\n            elif self._config.loop_mission == LoopMission.RESTART:\n                self._current_waypoint = 0\n            elif self._config.loop_mission == LoopMission.REVERSE and self._is_reversed:\n                self._current_waypoint = 0\n                self._is_reversed = False\n            elif self._config.loop_mission == LoopMission.REVERSE and not self._is_reversed:\n                self._current_waypoint = len(self._current_mission) - 2\n                self._is_reversed = True\n\n        if self._current_waypoint is not None:\n            if self._is_reversed:\n                self._logger.info(f\"Mission: Going to waypoint {self._current_waypoint} (REVERSED)\")\n            else:\n                self._logger.info(f\"Mission: Going to waypoint {self._current_waypoint}\")\n\n    def _has_overran_bounds(self) -&gt; bool:\n        if self._current_mission is None:\n            return False\n\n        if self._is_reversed:\n            return self._current_waypoint &lt; 0\n        else:\n            return self._current_waypoint &gt;= len(self._current_mission)\n\n    def _travel_to_current_waypoint(self):\n        if self._current_waypoint is None:\n            return\n\n        mobility_command = GotoCoordsMobilityCommand(*self._current_mission[self._current_waypoint])\n        self._instance.provider.send_mobility_command(mobility_command)\n\n    def start_mission_with_waypoint_file(self, mission_file_path: str) -&gt; None:\n        \"\"\"\n        Loads a mission from a text file and afterwards calls the start mission function.\n\n        The file should have the following format:\n\n        -8.0,-4.0,0.0\n        4.0,-4.0,0.0\n        4.0,8.0,0.0\n\n        The coordinates are listed in the x,y,z order and seperated by a , .\n\n        Args:\n            mission_file_path: Text file of positions the mission will follow.\n        \"\"\"\n        mission : List[Position] = []\n\n        try:\n            with open(mission_file_path, 'r') as file:\n                for line in file:\n                    x, y, z = map(float, line.split(sep=','))\n                    mission.append((x, y, z))\n        except FileNotFoundError:\n            print(f\"Error: File '{mission_file_path}' not found.\")\n            exit(1)\n        except ValueError:\n            print(f\"Error: Invalid format in file '{mission_file_path}'. Each line should contain three space-separated coordinates.\")\n            exit(1)\n\n        self.start_mission(mission=mission)\n\n    def start_mission(self, mission: List[Position]) -&gt; None:\n        \"\"\"\n        Starts a mission, the node will travel to each position in the list in order and stop at the last position,\n        unless the loop_mission option is set to True, in which case the node will travel the mission backwards after\n        reaching the last position and restart it after reaching the first position.\n\n        Args:\n            mission: Sequence of positions the node will follow.\n        \"\"\"\n        self._current_mission = mission    \n        self._is_reversed = False\n        self._is_idle = False\n        self._current_waypoint = 0\n        self._travel_to_current_waypoint()\n\n        speed_command = SetSpeedMobilityCommand(self._config.speed)\n        self._instance.provider.send_mobility_command(speed_command)\n\n        self._logger.info(\"Mission: Starting mission\")\n\n    def stop_mission(self) -&gt; None:\n        \"\"\"\n        Stops the current mission if there is one. If there is not, does nothing.\n        \"\"\"\n        self._current_mission = None\n        self._is_reversed = False\n        self._is_idle = True\n        self._current_waypoint = None\n\n        self._logger.info(\"Mission: Stopping mission\")\n\n    def set_current_waypoint(self, waypoint: int) -&gt; None:\n        \"\"\"\n        Manually sets the index of the waypoint in the mission that should be followed immediately. The mission will\n        progress normally after this. If the mission is reversed, it will keep being followed in reverse direction.\n\n        If there is no mission going on, will raise MissionMobilityPluginException.\n\n        If waypoint is outsidef the mission bounds a MissionMobilityPluginException will be raised\n\n        Args:\n            waypoint: Index of the waypoint that should be followed next\n        \"\"\"\n        if self._current_mission is None:\n            raise MissionMobilityPluginException(\"Could not set waypoint: No mission in progress\")\n\n        if waypoint &lt; 0 or waypoint &gt;= len(self._current_mission):\n            raise MissionMobilityPluginException(f\"Could not set waypoint: Waypoint index {waypoint} is not in mission \"\n                                                f\"bounds [0, {len(self._current_mission) - 1}]\")\n\n        self._current_waypoint = waypoint\n        self._travel_to_current_waypoint()\n\n    def set_reversed(self, reversed: bool) -&gt; None:\n        \"\"\"\n        Sets the reversed state of the mission. If True the node will start travelling the mission in reverse order\n        and when False in normal order. When this method is called while the node is travelling between to a waypoint,\n        the movement will be updated immediately. This means that if the node was previously traveling un-reversed, it\n        will turn around and go where it came from.\n\n        This method is only relevant when LoopMission.REVERSE is configured, in any other case this will raise\n        MissionMobilityPluginException.\n\n        Args:\n            reversed: True if the node should reverse and False otherwise\n        \"\"\"\n        if self._current_mission is None:\n            raise MissionMobilityPluginException(\"Could not set reversed: No mission in progress\")\n\n        if self._config.loop_mission != LoopMission.REVERSE:\n            raise MissionMobilityPluginException(f\"Could not set reversed: Not supported loop \"\n                                                f\"option {self._config.loop_mission.name}. \"\n                                                f\"Only supported when loop_mission is LoopMission.REVERSE\")\n\n        old_value = self._is_reversed\n        self._is_reversed = reversed\n\n        if old_value != reversed:\n            self._progress_current_waypoint()\n            self._travel_to_current_waypoint()\n\n\n    @property\n    def current_waypoint(self) -&gt; Optional[int]:\n        \"\"\"\n        Current waypoint the mission is travelling to. If no mission is ongoing, returns None\n\n        Returns:\n            Current waypoint\n        \"\"\"\n        return self._current_waypoint\n\n    @property\n    def is_reversed(self) -&gt; bool:\n        \"\"\"\n        If True the mission is being travelled in reverse direction because of LoopMission.REVERT. False otherwise.\n\n        If no mission is ongoing returns False\n\n        Returns:\n            If the mission is being travelled in reverse\n        \"\"\"\n        return self._is_reversed\n\n    @property\n    def is_idle(self) -&gt; bool:\n        \"\"\"\n        Returns True if the node is not following a mission. False if there is a mission in progress\n\n        If no mission is ongoing returns True\n\n        Returns:\n            Whether there is a mission happening\n        \"\"\"\n        return self._is_idle\n</code></pre>"},{"location":"Modules/Protocol/plugins/mission_mobility/#gradysim.protocol.plugin.mission_mobility.MissionMobilityPlugin.current_waypoint","title":"<code>current_waypoint: Optional[int]</code>  <code>property</code>","text":"<p>Current waypoint the mission is travelling to. If no mission is ongoing, returns None</p> <p>Returns:</p> Type Description <code>Optional[int]</code> <p>Current waypoint</p>"},{"location":"Modules/Protocol/plugins/mission_mobility/#gradysim.protocol.plugin.mission_mobility.MissionMobilityPlugin.is_idle","title":"<code>is_idle: bool</code>  <code>property</code>","text":"<p>Returns True if the node is not following a mission. False if there is a mission in progress</p> <p>If no mission is ongoing returns True</p> <p>Returns:</p> Type Description <code>bool</code> <p>Whether there is a mission happening</p>"},{"location":"Modules/Protocol/plugins/mission_mobility/#gradysim.protocol.plugin.mission_mobility.MissionMobilityPlugin.is_reversed","title":"<code>is_reversed: bool</code>  <code>property</code>","text":"<p>If True the mission is being travelled in reverse direction because of LoopMission.REVERT. False otherwise.</p> <p>If no mission is ongoing returns False</p> <p>Returns:</p> Type Description <code>bool</code> <p>If the mission is being travelled in reverse</p>"},{"location":"Modules/Protocol/plugins/mission_mobility/#gradysim.protocol.plugin.mission_mobility.MissionMobilityPlugin.set_current_waypoint","title":"<code>set_current_waypoint(waypoint)</code>","text":"<p>Manually sets the index of the waypoint in the mission that should be followed immediately. The mission will progress normally after this. If the mission is reversed, it will keep being followed in reverse direction.</p> <p>If there is no mission going on, will raise MissionMobilityPluginException.</p> <p>If waypoint is outsidef the mission bounds a MissionMobilityPluginException will be raised</p> <p>Parameters:</p> Name Type Description Default <code>waypoint</code> <code>int</code> <p>Index of the waypoint that should be followed next</p> required Source code in <code>gradysim/protocol/plugin/mission_mobility.py</code> <pre><code>def set_current_waypoint(self, waypoint: int) -&gt; None:\n    \"\"\"\n    Manually sets the index of the waypoint in the mission that should be followed immediately. The mission will\n    progress normally after this. If the mission is reversed, it will keep being followed in reverse direction.\n\n    If there is no mission going on, will raise MissionMobilityPluginException.\n\n    If waypoint is outsidef the mission bounds a MissionMobilityPluginException will be raised\n\n    Args:\n        waypoint: Index of the waypoint that should be followed next\n    \"\"\"\n    if self._current_mission is None:\n        raise MissionMobilityPluginException(\"Could not set waypoint: No mission in progress\")\n\n    if waypoint &lt; 0 or waypoint &gt;= len(self._current_mission):\n        raise MissionMobilityPluginException(f\"Could not set waypoint: Waypoint index {waypoint} is not in mission \"\n                                            f\"bounds [0, {len(self._current_mission) - 1}]\")\n\n    self._current_waypoint = waypoint\n    self._travel_to_current_waypoint()\n</code></pre>"},{"location":"Modules/Protocol/plugins/mission_mobility/#gradysim.protocol.plugin.mission_mobility.MissionMobilityPlugin.set_reversed","title":"<code>set_reversed(reversed)</code>","text":"<p>Sets the reversed state of the mission. If True the node will start travelling the mission in reverse order and when False in normal order. When this method is called while the node is travelling between to a waypoint, the movement will be updated immediately. This means that if the node was previously traveling un-reversed, it will turn around and go where it came from.</p> <p>This method is only relevant when LoopMission.REVERSE is configured, in any other case this will raise MissionMobilityPluginException.</p> <p>Parameters:</p> Name Type Description Default <code>reversed</code> <code>bool</code> <p>True if the node should reverse and False otherwise</p> required Source code in <code>gradysim/protocol/plugin/mission_mobility.py</code> <pre><code>def set_reversed(self, reversed: bool) -&gt; None:\n    \"\"\"\n    Sets the reversed state of the mission. If True the node will start travelling the mission in reverse order\n    and when False in normal order. When this method is called while the node is travelling between to a waypoint,\n    the movement will be updated immediately. This means that if the node was previously traveling un-reversed, it\n    will turn around and go where it came from.\n\n    This method is only relevant when LoopMission.REVERSE is configured, in any other case this will raise\n    MissionMobilityPluginException.\n\n    Args:\n        reversed: True if the node should reverse and False otherwise\n    \"\"\"\n    if self._current_mission is None:\n        raise MissionMobilityPluginException(\"Could not set reversed: No mission in progress\")\n\n    if self._config.loop_mission != LoopMission.REVERSE:\n        raise MissionMobilityPluginException(f\"Could not set reversed: Not supported loop \"\n                                            f\"option {self._config.loop_mission.name}. \"\n                                            f\"Only supported when loop_mission is LoopMission.REVERSE\")\n\n    old_value = self._is_reversed\n    self._is_reversed = reversed\n\n    if old_value != reversed:\n        self._progress_current_waypoint()\n        self._travel_to_current_waypoint()\n</code></pre>"},{"location":"Modules/Protocol/plugins/mission_mobility/#gradysim.protocol.plugin.mission_mobility.MissionMobilityPlugin.start_mission","title":"<code>start_mission(mission)</code>","text":"<p>Starts a mission, the node will travel to each position in the list in order and stop at the last position, unless the loop_mission option is set to True, in which case the node will travel the mission backwards after reaching the last position and restart it after reaching the first position.</p> <p>Parameters:</p> Name Type Description Default <code>mission</code> <code>List[Position]</code> <p>Sequence of positions the node will follow.</p> required Source code in <code>gradysim/protocol/plugin/mission_mobility.py</code> <pre><code>def start_mission(self, mission: List[Position]) -&gt; None:\n    \"\"\"\n    Starts a mission, the node will travel to each position in the list in order and stop at the last position,\n    unless the loop_mission option is set to True, in which case the node will travel the mission backwards after\n    reaching the last position and restart it after reaching the first position.\n\n    Args:\n        mission: Sequence of positions the node will follow.\n    \"\"\"\n    self._current_mission = mission    \n    self._is_reversed = False\n    self._is_idle = False\n    self._current_waypoint = 0\n    self._travel_to_current_waypoint()\n\n    speed_command = SetSpeedMobilityCommand(self._config.speed)\n    self._instance.provider.send_mobility_command(speed_command)\n\n    self._logger.info(\"Mission: Starting mission\")\n</code></pre>"},{"location":"Modules/Protocol/plugins/mission_mobility/#gradysim.protocol.plugin.mission_mobility.MissionMobilityPlugin.start_mission_with_waypoint_file","title":"<code>start_mission_with_waypoint_file(mission_file_path)</code>","text":"<p>Loads a mission from a text file and afterwards calls the start mission function.</p> <p>The file should have the following format:</p> <p>-8.0,-4.0,0.0 4.0,-4.0,0.0 4.0,8.0,0.0</p> <p>The coordinates are listed in the x,y,z order and seperated by a , .</p> <p>Parameters:</p> Name Type Description Default <code>mission_file_path</code> <code>str</code> <p>Text file of positions the mission will follow.</p> required Source code in <code>gradysim/protocol/plugin/mission_mobility.py</code> <pre><code>def start_mission_with_waypoint_file(self, mission_file_path: str) -&gt; None:\n    \"\"\"\n    Loads a mission from a text file and afterwards calls the start mission function.\n\n    The file should have the following format:\n\n    -8.0,-4.0,0.0\n    4.0,-4.0,0.0\n    4.0,8.0,0.0\n\n    The coordinates are listed in the x,y,z order and seperated by a , .\n\n    Args:\n        mission_file_path: Text file of positions the mission will follow.\n    \"\"\"\n    mission : List[Position] = []\n\n    try:\n        with open(mission_file_path, 'r') as file:\n            for line in file:\n                x, y, z = map(float, line.split(sep=','))\n                mission.append((x, y, z))\n    except FileNotFoundError:\n        print(f\"Error: File '{mission_file_path}' not found.\")\n        exit(1)\n    except ValueError:\n        print(f\"Error: Invalid format in file '{mission_file_path}'. Each line should contain three space-separated coordinates.\")\n        exit(1)\n\n    self.start_mission(mission=mission)\n</code></pre>"},{"location":"Modules/Protocol/plugins/mission_mobility/#gradysim.protocol.plugin.mission_mobility.MissionMobilityPlugin.stop_mission","title":"<code>stop_mission()</code>","text":"<p>Stops the current mission if there is one. If there is not, does nothing.</p> Source code in <code>gradysim/protocol/plugin/mission_mobility.py</code> <pre><code>def stop_mission(self) -&gt; None:\n    \"\"\"\n    Stops the current mission if there is one. If there is not, does nothing.\n    \"\"\"\n    self._current_mission = None\n    self._is_reversed = False\n    self._is_idle = True\n    self._current_waypoint = None\n\n    self._logger.info(\"Mission: Stopping mission\")\n</code></pre>"},{"location":"Modules/Protocol/plugins/radio/","title":"Radio","text":""},{"location":"Modules/Protocol/plugins/radio/#gradysim.protocol.plugin.radio","title":"<code>gradysim.protocol.plugin.radio</code>","text":"<p>This module declares a plugin for the protocol that allows a protocol to instantiate multiple radios, each with their own communication characteristics. This plugin is only available in a Python simulation environment and will raise an error if used in other environments. Alternative implementations should be provided for other simulation environments,</p>"},{"location":"Modules/Protocol/plugins/radio/#gradysim.protocol.plugin.radio.Radio","title":"<code>Radio</code>","text":"<p>A plugin that allows a protocol to instantiate multiple radios, each with their own communication characteristics.</p> <p>Multiple radios can be instantiated in a single protocol. Messages sent through the radio will use the radio's communication characteristics, such as transmission range. Messages sent through other radios or directly through the protocol will not be affected by the radio's characteristics.</p> <p>This plugin is only available in a Python simulation environment and will raise an error if used in other environments. Alternative implementations should be provided for other simulation environments, ones that interface with real hardware radios or other communication systems.</p> <p>Warning</p> <p>This plugin can only be used in a Python simulation environment.</p> Source code in <code>gradysim/protocol/plugin/radio.py</code> <pre><code>class Radio:\n    \"\"\"\n    A plugin that allows a protocol to instantiate multiple radios, each with their own communication characteristics.\n\n    Multiple radios can be instantiated in a single protocol. Messages sent through the radio will use the radio's\n    communication characteristics, such as transmission range. Messages sent through other radios or directly through\n    the protocol will not be affected by the radio's characteristics.\n\n    This plugin is only available in a Python simulation environment and will raise an error if used in other\n    environments. Alternative implementations should be provided for other simulation environments, ones that\n    interface with real hardware radios or other communication systems.\n\n    !!!warning\n        This plugin can only be used in a Python simulation environment.\n    \"\"\"\n\n    def __init__(self, protocol: IProtocol, radio_configuration: RadioConfiguration):\n        \"\"\"\n        Initializes the Radio plugin.\n        \"\"\"\n        self._radio_configuration = radio_configuration\n\n        provider = protocol.provider\n        if not isinstance(provider, PythonProvider):\n            raise TypeError(\"Radio plugin can only be used in a Python simulation environment.\")\n        self._provider = provider\n\n        self._communication_controller = CommunicationController(protocol)\n\n    def set_configuration(self, radio_configuration: RadioConfiguration) -&gt; None:\n        \"\"\"\n        Sets a new configuration for the radio.\n\n        Args:\n            radio_configuration: The new configuration for the radio.\n        \"\"\"\n        self._radio_configuration = radio_configuration\n\n    def send_communication_command(self, command: CommunicationCommand) -&gt; None:\n        \"\"\"\n        Sends a message via the radio.\n\n        Args:\n            command: The communication command to send. Same CommunicationCommand used in [IProvider][gradysim.protocol.interface.IProvider]\n        \"\"\"\n        previous_range = self._communication_controller.get_transmission_range()\n        if previous_range is None:\n            raise RuntimeError(\"Cannot use radio: No communication handler detected.\")\n        self._communication_controller.set_transmission_range(self._radio_configuration.range)\n        self._provider.send_communication_command(command)\n        self._communication_controller.set_transmission_range(previous_range)\n</code></pre>"},{"location":"Modules/Protocol/plugins/radio/#gradysim.protocol.plugin.radio.Radio.__init__","title":"<code>__init__(protocol, radio_configuration)</code>","text":"<p>Initializes the Radio plugin.</p> Source code in <code>gradysim/protocol/plugin/radio.py</code> <pre><code>def __init__(self, protocol: IProtocol, radio_configuration: RadioConfiguration):\n    \"\"\"\n    Initializes the Radio plugin.\n    \"\"\"\n    self._radio_configuration = radio_configuration\n\n    provider = protocol.provider\n    if not isinstance(provider, PythonProvider):\n        raise TypeError(\"Radio plugin can only be used in a Python simulation environment.\")\n    self._provider = provider\n\n    self._communication_controller = CommunicationController(protocol)\n</code></pre>"},{"location":"Modules/Protocol/plugins/radio/#gradysim.protocol.plugin.radio.Radio.send_communication_command","title":"<code>send_communication_command(command)</code>","text":"<p>Sends a message via the radio.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>CommunicationCommand</code> <p>The communication command to send. Same CommunicationCommand used in IProvider</p> required Source code in <code>gradysim/protocol/plugin/radio.py</code> <pre><code>def send_communication_command(self, command: CommunicationCommand) -&gt; None:\n    \"\"\"\n    Sends a message via the radio.\n\n    Args:\n        command: The communication command to send. Same CommunicationCommand used in [IProvider][gradysim.protocol.interface.IProvider]\n    \"\"\"\n    previous_range = self._communication_controller.get_transmission_range()\n    if previous_range is None:\n        raise RuntimeError(\"Cannot use radio: No communication handler detected.\")\n    self._communication_controller.set_transmission_range(self._radio_configuration.range)\n    self._provider.send_communication_command(command)\n    self._communication_controller.set_transmission_range(previous_range)\n</code></pre>"},{"location":"Modules/Protocol/plugins/radio/#gradysim.protocol.plugin.radio.Radio.set_configuration","title":"<code>set_configuration(radio_configuration)</code>","text":"<p>Sets a new configuration for the radio.</p> <p>Parameters:</p> Name Type Description Default <code>radio_configuration</code> <code>RadioConfiguration</code> <p>The new configuration for the radio.</p> required Source code in <code>gradysim/protocol/plugin/radio.py</code> <pre><code>def set_configuration(self, radio_configuration: RadioConfiguration) -&gt; None:\n    \"\"\"\n    Sets a new configuration for the radio.\n\n    Args:\n        radio_configuration: The new configuration for the radio.\n    \"\"\"\n    self._radio_configuration = radio_configuration\n</code></pre>"},{"location":"Modules/Protocol/plugins/random_mobility/","title":"Random Mobility","text":""},{"location":"Modules/Protocol/plugins/random_mobility/#gradysim.protocol.plugin.random_mobility","title":"<code>gradysim.protocol.plugin.random_mobility</code>","text":"<p>A common use case of network simulations is to simulate a network of mobile nodes whose mobility is random. This plugin provides a simple way to implement random mobility in your protocol.</p>"},{"location":"Modules/Protocol/plugins/random_mobility/#gradysim.protocol.plugin.random_mobility.RandomMobilityConfig","title":"<code>RandomMobilityConfig</code>  <code>dataclass</code>","text":"<p>Configuration class for the RandomMobilityPlugin class.</p> Source code in <code>gradysim/protocol/plugin/random_mobility.py</code> <pre><code>@dataclass\nclass RandomMobilityConfig:\n    \"\"\"\n    Configuration class for the [RandomMobilityPlugin][gradysim.protocol.plugin.random_mobility.RandomMobilityPlugin] class.\n    \"\"\"\n\n    x_range: Tuple[float, float] = (-50, 50)\n    \"\"\"Random waypoints will be drawn from this range for the x coordinate\"\"\"\n\n    y_range: Tuple[float, float] = (-50, 50)\n    \"\"\"Random waypoints will be drawn from this range for the y coordinate\"\"\"\n\n    z_range: Tuple[float, float] = (0, 50)\n    \"\"\"Random waypoints will be drawn from this range for the z coordinate\"\"\"\n\n    tolerance: float = 1\n    \"\"\"\n    Tolerance in meters for considering a waypoint as reached. When the node is within this distance from the\n    waypoint, it will be considered as reached and a new waypoint will be drawn, if a random trip is ongoing.\n    \"\"\"\n</code></pre>"},{"location":"Modules/Protocol/plugins/random_mobility/#gradysim.protocol.plugin.random_mobility.RandomMobilityConfig.tolerance","title":"<code>tolerance: float = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Tolerance in meters for considering a waypoint as reached. When the node is within this distance from the waypoint, it will be considered as reached and a new waypoint will be drawn, if a random trip is ongoing.</p>"},{"location":"Modules/Protocol/plugins/random_mobility/#gradysim.protocol.plugin.random_mobility.RandomMobilityConfig.x_range","title":"<code>x_range: Tuple[float, float] = (-50, 50)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Random waypoints will be drawn from this range for the x coordinate</p>"},{"location":"Modules/Protocol/plugins/random_mobility/#gradysim.protocol.plugin.random_mobility.RandomMobilityConfig.y_range","title":"<code>y_range: Tuple[float, float] = (-50, 50)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Random waypoints will be drawn from this range for the y coordinate</p>"},{"location":"Modules/Protocol/plugins/random_mobility/#gradysim.protocol.plugin.random_mobility.RandomMobilityConfig.z_range","title":"<code>z_range: Tuple[float, float] = (0, 50)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Random waypoints will be drawn from this range for the z coordinate</p>"},{"location":"Modules/Protocol/plugins/random_mobility/#gradysim.protocol.plugin.random_mobility.RandomMobilityPlugin","title":"<code>RandomMobilityPlugin</code>","text":"<p>Plugin for random mobility. This plugin will assist you in implementing random movement behaviour in your protocol.</p> <p>This plugin should be initialized by your protocol. To use it you should call the initiate_random_trip method to start a random trip. This method will make the node travel to a random waypoint and then draw a new waypoint when the node reaches it. This process will repeat until you call the finish_random_trip method.</p> <p>If you only want to make the node travel to a random waypoint once, you can use the travel_to_random_waypoint method.</p> Source code in <code>gradysim/protocol/plugin/random_mobility.py</code> <pre><code>class RandomMobilityPlugin:\n    \"\"\"\n    Plugin for random mobility. This plugin will assist you in implementing random movement behaviour in your\n    protocol.\n\n    This plugin should be initialized by your protocol. To use it you should call the\n    [initiate_random_trip][gradysim.protocol.plugin.random_mobility.RandomMobilityPlugin.initiate_random_trip] method to start\n    a random trip. This method will make the node travel to a random waypoint and then draw a new waypoint when the\n    node reaches it. This process will repeat until you call the\n    [finish_random_trip][gradysim.protocol.plugin.random_mobility.RandomMobilityPlugin.finish_random_trip] method.\n\n    If you only want to make the node travel to a random waypoint once, you can use the\n    [travel_to_random_waypoint][gradysim.protocol.plugin.random_mobility.RandomMobilityPlugin.travel_to_random_waypoint] method.\n    \"\"\"\n    def __init__(self, protocol: IProtocol, config: RandomMobilityConfig = RandomMobilityConfig()):\n        \"\"\"\n        Initializes the plugin\n\n        Args:\n            protocol: The protocol instance to which this plugin will be attached\n            config: Configuration for the plugin, if not specified, the default configuration will be used\n        \"\"\"\n        self._instance = protocol\n        self._config = config\n        self._logger = logging.getLogger()\n\n        self._dispatcher = create_dispatcher(protocol)\n\n    def travel_to_random_waypoint(self) -&gt; Position:\n        \"\"\"\n        Issues a mobility command that makes the node travel to a randomly drawn position within\n        the range specified in the configuration of this class.\n\n        Returns:\n            Node's new destination\n        \"\"\"\n        random_waypoint = (\n            random.uniform(*self._config.x_range),\n            random.uniform(*self._config.y_range),\n            random.uniform(*self._config.z_range)\n        )\n\n        command = MobilityCommand(\n            MobilityCommandType.GOTO_COORDS,\n            *random_waypoint\n        )\n\n        self._logger.info(f\"RandomMobilityPlugin: traveling to waypoint {random_waypoint}\")\n\n        self._instance.provider.send_mobility_command(command)\n        return random_waypoint\n\n    _current_target: Optional[Position]\n    _patched_handle_telemetry: Optional[Callable[[IProtocol, Telemetry], DispatchReturn]]\n    _trip_ongoing: bool\n\n    def initiate_random_trip(self) -&gt; None:\n        \"\"\"\n        Initiates a random trip. This means this node will draw a random waypoint, travel to it and repeat\n        this process until finish_random_trip is called.\n        \"\"\"\n        self._logger.info(\"RandomMobilityPlugin: Initiating a random trip\")\n        self._current_target = self.travel_to_random_waypoint()\n\n        def patched_handle_telemetry(instance: IProtocol, telemetry: Telemetry):\n            if squared_distance(telemetry.current_position, self._current_target) &lt;= \\\n                    (self._config.tolerance * self._config.tolerance):\n                self._current_target = self.travel_to_random_waypoint()\n\n            return DispatchReturn.CONTINUE\n\n        self._patched_handle_telemetry = patched_handle_telemetry\n        self._dispatcher.register_handle_telemetry(patched_handle_telemetry)\n        self._trip_ongoing = True\n\n    def finish_random_trip(self) -&gt; None:\n        \"\"\"\n        Finishes an ongoing random trip. If no trip is ongoing, this method does nothing.\n        \"\"\"\n        self._logger.info(\"RandomMobilityPlugin: Finishing a random trip\")\n        if self._trip_ongoing:\n            self._dispatcher.unregister_handle_telemetry(self._patched_handle_telemetry)\n            self._patched_handle_telemetry = None\n            self._trip_ongoing = False\n\n    @property\n    def trip_ongoing(self):\n        \"\"\"\n        Returns whether a random trip is ongoing or not\n        Returns:\n            True if a random trip is ongoing, False otherwise\n        \"\"\"\n        return self._trip_ongoing\n\n    @property\n    def current_target(self) -&gt; Optional[Position]:\n        \"\"\"\n        Returns the position the node is currently traveling to, or None if it isn't traveling anywhere.\n\n        Returns:\n            The position the node is currently traveling to, or None if it isn't traveling anywhere.\n        \"\"\"\n        return self._current_target\n</code></pre>"},{"location":"Modules/Protocol/plugins/random_mobility/#gradysim.protocol.plugin.random_mobility.RandomMobilityPlugin.current_target","title":"<code>current_target: Optional[Position]</code>  <code>property</code>","text":"<p>Returns the position the node is currently traveling to, or None if it isn't traveling anywhere.</p> <p>Returns:</p> Type Description <code>Optional[Position]</code> <p>The position the node is currently traveling to, or None if it isn't traveling anywhere.</p>"},{"location":"Modules/Protocol/plugins/random_mobility/#gradysim.protocol.plugin.random_mobility.RandomMobilityPlugin.trip_ongoing","title":"<code>trip_ongoing</code>  <code>property</code>","text":"<p>Returns whether a random trip is ongoing or not Returns:     True if a random trip is ongoing, False otherwise</p>"},{"location":"Modules/Protocol/plugins/random_mobility/#gradysim.protocol.plugin.random_mobility.RandomMobilityPlugin.__init__","title":"<code>__init__(protocol, config=RandomMobilityConfig())</code>","text":"<p>Initializes the plugin</p> <p>Parameters:</p> Name Type Description Default <code>protocol</code> <code>IProtocol</code> <p>The protocol instance to which this plugin will be attached</p> required <code>config</code> <code>RandomMobilityConfig</code> <p>Configuration for the plugin, if not specified, the default configuration will be used</p> <code>RandomMobilityConfig()</code> Source code in <code>gradysim/protocol/plugin/random_mobility.py</code> <pre><code>def __init__(self, protocol: IProtocol, config: RandomMobilityConfig = RandomMobilityConfig()):\n    \"\"\"\n    Initializes the plugin\n\n    Args:\n        protocol: The protocol instance to which this plugin will be attached\n        config: Configuration for the plugin, if not specified, the default configuration will be used\n    \"\"\"\n    self._instance = protocol\n    self._config = config\n    self._logger = logging.getLogger()\n\n    self._dispatcher = create_dispatcher(protocol)\n</code></pre>"},{"location":"Modules/Protocol/plugins/random_mobility/#gradysim.protocol.plugin.random_mobility.RandomMobilityPlugin.finish_random_trip","title":"<code>finish_random_trip()</code>","text":"<p>Finishes an ongoing random trip. If no trip is ongoing, this method does nothing.</p> Source code in <code>gradysim/protocol/plugin/random_mobility.py</code> <pre><code>def finish_random_trip(self) -&gt; None:\n    \"\"\"\n    Finishes an ongoing random trip. If no trip is ongoing, this method does nothing.\n    \"\"\"\n    self._logger.info(\"RandomMobilityPlugin: Finishing a random trip\")\n    if self._trip_ongoing:\n        self._dispatcher.unregister_handle_telemetry(self._patched_handle_telemetry)\n        self._patched_handle_telemetry = None\n        self._trip_ongoing = False\n</code></pre>"},{"location":"Modules/Protocol/plugins/random_mobility/#gradysim.protocol.plugin.random_mobility.RandomMobilityPlugin.initiate_random_trip","title":"<code>initiate_random_trip()</code>","text":"<p>Initiates a random trip. This means this node will draw a random waypoint, travel to it and repeat this process until finish_random_trip is called.</p> Source code in <code>gradysim/protocol/plugin/random_mobility.py</code> <pre><code>def initiate_random_trip(self) -&gt; None:\n    \"\"\"\n    Initiates a random trip. This means this node will draw a random waypoint, travel to it and repeat\n    this process until finish_random_trip is called.\n    \"\"\"\n    self._logger.info(\"RandomMobilityPlugin: Initiating a random trip\")\n    self._current_target = self.travel_to_random_waypoint()\n\n    def patched_handle_telemetry(instance: IProtocol, telemetry: Telemetry):\n        if squared_distance(telemetry.current_position, self._current_target) &lt;= \\\n                (self._config.tolerance * self._config.tolerance):\n            self._current_target = self.travel_to_random_waypoint()\n\n        return DispatchReturn.CONTINUE\n\n    self._patched_handle_telemetry = patched_handle_telemetry\n    self._dispatcher.register_handle_telemetry(patched_handle_telemetry)\n    self._trip_ongoing = True\n</code></pre>"},{"location":"Modules/Protocol/plugins/random_mobility/#gradysim.protocol.plugin.random_mobility.RandomMobilityPlugin.travel_to_random_waypoint","title":"<code>travel_to_random_waypoint()</code>","text":"<p>Issues a mobility command that makes the node travel to a randomly drawn position within the range specified in the configuration of this class.</p> <p>Returns:</p> Type Description <code>Position</code> <p>Node's new destination</p> Source code in <code>gradysim/protocol/plugin/random_mobility.py</code> <pre><code>def travel_to_random_waypoint(self) -&gt; Position:\n    \"\"\"\n    Issues a mobility command that makes the node travel to a randomly drawn position within\n    the range specified in the configuration of this class.\n\n    Returns:\n        Node's new destination\n    \"\"\"\n    random_waypoint = (\n        random.uniform(*self._config.x_range),\n        random.uniform(*self._config.y_range),\n        random.uniform(*self._config.z_range)\n    )\n\n    command = MobilityCommand(\n        MobilityCommandType.GOTO_COORDS,\n        *random_waypoint\n    )\n\n    self._logger.info(f\"RandomMobilityPlugin: traveling to waypoint {random_waypoint}\")\n\n    self._instance.provider.send_mobility_command(command)\n    return random_waypoint\n</code></pre>"},{"location":"Modules/Simulator/","title":"Introduction","text":""},{"location":"Modules/Simulator/#gradysim.simulator","title":"<code>gradysim.simulator</code>","text":"<p>The <code>simulator</code> module implements an event-based network simulation populated by nodes whose behaviours are implemented as protocols. Use this module to implement simulations that run in prototype-mode completely in python, easy to run and setup.</p> <p>This package implements a python event-based network simulator that is used to run protocols in prototype-mode. As an event-based simulator it is built around an event loop that is responsible for executing events in the simulator. You can use the simulation builder to create new simulations populated by nodes and enhanced by handlers that implement specific behaviour.</p>"},{"location":"Modules/Simulator/event/","title":"Event","text":""},{"location":"Modules/Simulator/event/#gradysim.simulator.event","title":"<code>gradysim.simulator.event</code>","text":"<p>As an event-based simulator one of the main components in the simulation is an event loop, that's the focus of this module. Events are compact classes containing a timestamp and a callback. Events are inserted into the event loop which is organized as a heap to keep the events with the smallest timestamps on top. At every simulation iteration the simulator class grabs the event with the smallest timestamp and executes its callback.</p> <p>Events are created by handlers. Protocols indirectly interact with them through the provider interface they have access to. These events, when executed, cause effects on the network nodes, mainly observed through calls to the protocol interface methods like handle_timer.</p>"},{"location":"Modules/Simulator/event/#gradysim.simulator.event.Event","title":"<code>Event</code>  <code>dataclass</code>","text":"<p>Dataclass representing a single event. Will be placed inside the simulation loop. Shouldn't be instantiated directly, but through the <code>EventLoop.schedule_event</code> method.</p> Source code in <code>gradysim/simulator/event.py</code> <pre><code>@dataclass\nclass Event:\n    \"\"\"\n    Dataclass representing a single event. Will be placed inside the simulation loop. Shouldn't be instantiated\n    directly, but through the `EventLoop.schedule_event` method.\n    \"\"\"\n\n    timestamp: float\n    \"\"\"Simulation time in seconds when the event will fire\"\"\"\n    callback: Callable\n    \"\"\"Any callable with no parameters. Will be executed when the event fires\"\"\"\n    context: str\n    \"\"\"\n    Context in which the event will be executed. \n    This is used in logging to identify where the callback is being executed.\n    \"\"\"\n\n    def __lt__(self, other):\n        return self.timestamp &lt; other.timestamp\n</code></pre>"},{"location":"Modules/Simulator/event/#gradysim.simulator.event.Event.callback","title":"<code>callback: Callable</code>  <code>instance-attribute</code>","text":"<p>Any callable with no parameters. Will be executed when the event fires</p>"},{"location":"Modules/Simulator/event/#gradysim.simulator.event.Event.context","title":"<code>context: str</code>  <code>instance-attribute</code>","text":"<p>Context in which the event will be executed.  This is used in logging to identify where the callback is being executed.</p>"},{"location":"Modules/Simulator/event/#gradysim.simulator.event.Event.timestamp","title":"<code>timestamp: float</code>  <code>instance-attribute</code>","text":"<p>Simulation time in seconds when the event will fire</p>"},{"location":"Modules/Simulator/event/#gradysim.simulator.event.EventLoop","title":"<code>EventLoop</code>","text":"<p>Event loop central to the event-based simulation. Is implemented as a min-heap populated by <code>Event</code> instances ordered by their timestamps. Generally only the <code>Simulator</code> will call the <code>pop_event</code> method, a handler should only need to use the <code>schedule_event</code> method.</p> Source code in <code>gradysim/simulator/event.py</code> <pre><code>class EventLoop:\n    \"\"\"\n    Event loop central to the event-based simulation. Is implemented as a min-heap populated by `Event` instances ordered\n    by their timestamps. Generally only the [`Simulator`][gradysim.simulator.simulation.Simulator] will call the `pop_event`\n    method, a handler should only need to use the `schedule_event` method.\n    \"\"\"\n    _event_heap: List[Event]\n    _current_time: float\n\n    def __init__(self):\n        \"\"\"\n        Creates an event loop\n        \"\"\"\n        self._event_heap = []\n        self._current_time = 0\n\n    def schedule_event(self, timestamp: float, callback: Callable, context: str = \"\") -&gt; None:\n        \"\"\"\n        Creates an event instance with the information provided as args and inserts it into the event heap.\n\n        Args:\n            timestamp: Simulation time in seconds when the event should fire\n            callback: Any callable with no arguments\n            context: Context where the callable executes. Useful for logging.\n        \"\"\"\n        if timestamp &lt; self.current_time:\n            raise EventLoopException(f\"Could not schedule event: tried to schedule at {timestamp} which is \"\n                                     f\"earlier than the current time {self.current_time}. \")\n\n        heapq.heappush(self._event_heap, Event(timestamp, callback, context))\n\n    def pop_event(self) -&gt; Event:\n        \"\"\"\n        Removes an event from the top of the event heap and returns it. If called when the event heap is empty it will\n        raise EventLoopException.\n\n        Returns: The event popped.\n\n        \"\"\"\n        if len(self._event_heap) == 0:\n            raise EventLoopException(\"Could not pop event: the event queue is empty\")\n\n        event = heapq.heappop(self._event_heap)\n        self._current_time = event.timestamp\n        return event\n\n    def peek_event(self) -&gt; Optional[Event]:\n        \"\"\"\n        Peeks at the event at the top of the event heap without removing it. Returns None if the event heap is empty.\n\n        Returns:\n            The event at the top of the event heap or None if it's empty\n        \"\"\"\n        if len(self._event_heap) == 0:\n            return None\n        return self._event_heap[0]\n\n    def clear(self) -&gt; None:\n        \"\"\"\n        Clears the event heap\n        \"\"\"\n        self._event_heap.clear()\n\n    @property\n    def current_time(self) -&gt; float:\n        \"\"\"\n        Returns the timestamp of the last event to be removed from the heap.\n        This represents the current simulation time.\n\n        Returns:\n            The current simulation fime\n        \"\"\"\n        return self._current_time\n\n    def __len__(self) -&gt; int:\n        \"\"\"\n        By calling len() on the EventLoop you can check how many events are queued in the event heap.\n\n        Returns:\n            Number of events in the event heap\n        \"\"\"\n        return len(self._event_heap)\n</code></pre>"},{"location":"Modules/Simulator/event/#gradysim.simulator.event.EventLoop.current_time","title":"<code>current_time: float</code>  <code>property</code>","text":"<p>Returns the timestamp of the last event to be removed from the heap. This represents the current simulation time.</p> <p>Returns:</p> Type Description <code>float</code> <p>The current simulation fime</p>"},{"location":"Modules/Simulator/event/#gradysim.simulator.event.EventLoop.__init__","title":"<code>__init__()</code>","text":"<p>Creates an event loop</p> Source code in <code>gradysim/simulator/event.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Creates an event loop\n    \"\"\"\n    self._event_heap = []\n    self._current_time = 0\n</code></pre>"},{"location":"Modules/Simulator/event/#gradysim.simulator.event.EventLoop.__len__","title":"<code>__len__()</code>","text":"<p>By calling len() on the EventLoop you can check how many events are queued in the event heap.</p> <p>Returns:</p> Type Description <code>int</code> <p>Number of events in the event heap</p> Source code in <code>gradysim/simulator/event.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"\n    By calling len() on the EventLoop you can check how many events are queued in the event heap.\n\n    Returns:\n        Number of events in the event heap\n    \"\"\"\n    return len(self._event_heap)\n</code></pre>"},{"location":"Modules/Simulator/event/#gradysim.simulator.event.EventLoop.clear","title":"<code>clear()</code>","text":"<p>Clears the event heap</p> Source code in <code>gradysim/simulator/event.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"\n    Clears the event heap\n    \"\"\"\n    self._event_heap.clear()\n</code></pre>"},{"location":"Modules/Simulator/event/#gradysim.simulator.event.EventLoop.peek_event","title":"<code>peek_event()</code>","text":"<p>Peeks at the event at the top of the event heap without removing it. Returns None if the event heap is empty.</p> <p>Returns:</p> Type Description <code>Optional[Event]</code> <p>The event at the top of the event heap or None if it's empty</p> Source code in <code>gradysim/simulator/event.py</code> <pre><code>def peek_event(self) -&gt; Optional[Event]:\n    \"\"\"\n    Peeks at the event at the top of the event heap without removing it. Returns None if the event heap is empty.\n\n    Returns:\n        The event at the top of the event heap or None if it's empty\n    \"\"\"\n    if len(self._event_heap) == 0:\n        return None\n    return self._event_heap[0]\n</code></pre>"},{"location":"Modules/Simulator/event/#gradysim.simulator.event.EventLoop.pop_event","title":"<code>pop_event()</code>","text":"<p>Removes an event from the top of the event heap and returns it. If called when the event heap is empty it will raise EventLoopException.</p> <p>Returns: The event popped.</p> Source code in <code>gradysim/simulator/event.py</code> <pre><code>def pop_event(self) -&gt; Event:\n    \"\"\"\n    Removes an event from the top of the event heap and returns it. If called when the event heap is empty it will\n    raise EventLoopException.\n\n    Returns: The event popped.\n\n    \"\"\"\n    if len(self._event_heap) == 0:\n        raise EventLoopException(\"Could not pop event: the event queue is empty\")\n\n    event = heapq.heappop(self._event_heap)\n    self._current_time = event.timestamp\n    return event\n</code></pre>"},{"location":"Modules/Simulator/event/#gradysim.simulator.event.EventLoop.schedule_event","title":"<code>schedule_event(timestamp, callback, context='')</code>","text":"<p>Creates an event instance with the information provided as args and inserts it into the event heap.</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>float</code> <p>Simulation time in seconds when the event should fire</p> required <code>callback</code> <code>Callable</code> <p>Any callable with no arguments</p> required <code>context</code> <code>str</code> <p>Context where the callable executes. Useful for logging.</p> <code>''</code> Source code in <code>gradysim/simulator/event.py</code> <pre><code>def schedule_event(self, timestamp: float, callback: Callable, context: str = \"\") -&gt; None:\n    \"\"\"\n    Creates an event instance with the information provided as args and inserts it into the event heap.\n\n    Args:\n        timestamp: Simulation time in seconds when the event should fire\n        callback: Any callable with no arguments\n        context: Context where the callable executes. Useful for logging.\n    \"\"\"\n    if timestamp &lt; self.current_time:\n        raise EventLoopException(f\"Could not schedule event: tried to schedule at {timestamp} which is \"\n                                 f\"earlier than the current time {self.current_time}. \")\n\n    heapq.heappush(self._event_heap, Event(timestamp, callback, context))\n</code></pre>"},{"location":"Modules/Simulator/log/","title":"Log","text":""},{"location":"Modules/Simulator/log/#gradysim.simulator.log","title":"<code>gradysim.simulator.log</code>","text":"<p>Logging is an important part of any software. It helps users and developers understand what is happening during the execution of the program. When running GrADyS-SIM NextGen in prototype-mode logging is automatically configured for you.</p> <p>The logger annotates the output with timing information and execution context to improve understanding.</p>"},{"location":"Modules/Simulator/log/#gradysim.simulator.log.SimulationFormatter","title":"<code>SimulationFormatter</code>","text":"<p>               Bases: <code>Formatter</code></p> <p>Custom logging formatter responsible for annotating the simulation logs with useful information about timing and execution context.</p> Source code in <code>gradysim/simulator/log.py</code> <pre><code>class SimulationFormatter(logging.Formatter):\n    \"\"\"\n    Custom logging formatter responsible for annotating the simulation logs with useful information about\n    timing and execution context.\n    \"\"\"\n    def __init__(self):\n        super().__init__(\"%(message)s\")\n\n    prefix: str = \"\"\n\n    def clear_iteration(self):\n        self.prefix = \"\"\n\n    def format(self, record: logging.LogRecord) -&gt; str:\n        log = super().format(record)\n        return f\"{record.levelname: &lt;8} {self.prefix}{log}\"\n</code></pre>"},{"location":"Modules/Simulator/log/#gradysim.simulator.log.setup_simulation_formatter","title":"<code>setup_simulation_formatter(debug, log_file)</code>","text":"<p>Sets up the logger for the simulation. Called before the simulation starts to configure the logger.</p> <p>Parameters:</p> Name Type Description Default <code>debug</code> <code>bool</code> <p>Include DEBUG level logs</p> required <code>log_file</code> <code>Optional[Path]</code> <p>Configure a logging handler to save logs in a file. Optional.</p> required <p>Returns:</p> Type Description <code>SimulationFormatter</code> <p>The formatter instance. Is returned because it needs to be updated with current simulation information.</p> Source code in <code>gradysim/simulator/log.py</code> <pre><code>def setup_simulation_formatter(debug: bool, log_file: Optional[Path]) -&gt; SimulationFormatter:\n    \"\"\"\n    Sets up the logger for the simulation. Called before the simulation starts to configure\n    the logger.\n\n    Args:\n        debug: Include DEBUG level logs\n        log_file: Configure a logging handler to save logs in a file. Optional.\n\n    Returns:\n        The formatter instance. Is returned because it needs to be updated with current simulation information.\n    \"\"\"\n    logger = logging.getLogger()\n\n    if debug:\n        logger.setLevel(logging.DEBUG)\n    else:\n        logger.setLevel(logging.INFO)\n\n    formatter = SimulationFormatter()\n    console_handler = logging.StreamHandler()\n    console_handler.setFormatter(formatter)\n    logger.addHandler(console_handler)\n\n    if log_file is not None:\n        file_handler = logging.FileHandler(log_file)\n        file_handler.setFormatter(formatter)\n        logger.addHandler(file_handler)\n\n    return formatter\n</code></pre>"},{"location":"Modules/Simulator/node/","title":"Node","text":""},{"location":"Modules/Simulator/node/#gradysim.simulator.node","title":"<code>gradysim.simulator.node</code>","text":"<p>This is a simple module containing declarations necessary to keep track of the nodes during the simulation</p>"},{"location":"Modules/Simulator/node/#gradysim.simulator.node.Node","title":"<code>Node</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Represents a node inside the python simulation. Holds the reference to the node's encapsulated protocol. This class is accessible to handlers.</p> Source code in <code>gradysim/simulator/node.py</code> <pre><code>class Node(Generic[T]):\n    \"\"\"\n    Represents a node inside the python simulation. Holds the reference to the node's encapsulated protocol.\n    This class is accessible to [handlers][gradysim.simulator.handler].\n    \"\"\"\n    id: int\n    \"\"\"Node's unique identifier\"\"\"\n\n    protocol_encapsulator: IEncapsulator[T]\n    \"\"\"Node's encapsulated protocol\"\"\"\n\n    position: Position\n    \"\"\"Node's position inside the simulation\"\"\"\n</code></pre>"},{"location":"Modules/Simulator/node/#gradysim.simulator.node.Node.id","title":"<code>id: int</code>  <code>instance-attribute</code>","text":"<p>Node's unique identifier</p>"},{"location":"Modules/Simulator/node/#gradysim.simulator.node.Node.position","title":"<code>position: Position</code>  <code>instance-attribute</code>","text":"<p>Node's position inside the simulation</p>"},{"location":"Modules/Simulator/node/#gradysim.simulator.node.Node.protocol_encapsulator","title":"<code>protocol_encapsulator: IEncapsulator[T]</code>  <code>instance-attribute</code>","text":"<p>Node's encapsulated protocol</p>"},{"location":"Modules/Simulator/simulation/","title":"Simulation","text":"<p>This page will go into details you the classes used to build and run a python simulation.</p> <p></p>"},{"location":"Modules/Simulator/simulation/#building-the-simulation","title":"Building the simulation","text":"<p>The preferred method of creating a python simulation is making use of the  SimulationBuilder class that provides  an API that helps you build your simulation scenario and properly instantiates  the Simulator class. A SimulationConfiguration is  passed to the builder during initialization for simulation-level configuration. </p> <p>To help you with positioning your nodes some utility methods are also provided.</p>"},{"location":"Modules/Simulator/simulation/#gradysim.simulator.simulation.SimulationConfiguration","title":"<code>gradysim.simulator.simulation.SimulationConfiguration</code>  <code>dataclass</code>","text":"<p>Simulation-level configurations. These will change how the simulation will be run.</p> Source code in <code>gradysim/simulator/simulation.py</code> <pre><code>@dataclass\nclass SimulationConfiguration:\n    \"\"\"\n    Simulation-level configurations. These will change how the simulation will be run.\n    \"\"\"\n    duration: Optional[float] = None\n    \"\"\"\n    Maximum duration of the simulation in seconds. The simulation will end when no more events scheduled before \n    `duration` are left. If `None`, no limit is set.\n    \"\"\"\n\n    max_iterations: Optional[int] = None\n    \"\"\"\n    Maximum number of simulation iterations. An iteration is counted every time an event is popped from the event-loop.\n    If `None`, no limit is set.\n    \"\"\"\n\n    real_time: Union[bool, float] = False\n    \"\"\"\n    Setting this to true will put the simulation in real-time mode. This means that the simulation will run synchronized\n    with real-world time. One simulation second will approximately equal to one real-world second. If set to a float\n    will run at that many times real-time. For example, setting this to 2 will make the simulation run twice as fast as\n    real-time. The float value must be greater than 0.\n    \"\"\"\n\n    debug: bool = False\n    \"\"\"\n    Setting this flag to true will enable additional logging. Helpful if you are having issues with the simulation.\n    \"\"\"\n\n    log_file: Optional[Path] = None\n    \"\"\"\n    Simulation logs will be saved in this path.\n    \"\"\"\n\n    execution_logging: bool = True\n    \"\"\"\n    Setting this flag to true will enable logging of the simulation execution. Even if disabled logging will still\n    happen at the end of the simulation. Disabling this can improve performance.\n    \"\"\"\n\n    profile: bool = False\n    \"\"\"\n    Setting this flag to true will enable profiling of the simulation. This will output to the logs profiling \n    information about the simulation execution. This can be useful to identify bottlenecks in the simulation.\n    \"\"\"\n</code></pre>"},{"location":"Modules/Simulator/simulation/#gradysim.simulator.simulation.SimulationConfiguration.debug","title":"<code>debug: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Setting this flag to true will enable additional logging. Helpful if you are having issues with the simulation.</p>"},{"location":"Modules/Simulator/simulation/#gradysim.simulator.simulation.SimulationConfiguration.duration","title":"<code>duration: Optional[float] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Maximum duration of the simulation in seconds. The simulation will end when no more events scheduled before  <code>duration</code> are left. If <code>None</code>, no limit is set.</p>"},{"location":"Modules/Simulator/simulation/#gradysim.simulator.simulation.SimulationConfiguration.execution_logging","title":"<code>execution_logging: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Setting this flag to true will enable logging of the simulation execution. Even if disabled logging will still happen at the end of the simulation. Disabling this can improve performance.</p>"},{"location":"Modules/Simulator/simulation/#gradysim.simulator.simulation.SimulationConfiguration.log_file","title":"<code>log_file: Optional[Path] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Simulation logs will be saved in this path.</p>"},{"location":"Modules/Simulator/simulation/#gradysim.simulator.simulation.SimulationConfiguration.max_iterations","title":"<code>max_iterations: Optional[int] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Maximum number of simulation iterations. An iteration is counted every time an event is popped from the event-loop. If <code>None</code>, no limit is set.</p>"},{"location":"Modules/Simulator/simulation/#gradysim.simulator.simulation.SimulationConfiguration.profile","title":"<code>profile: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Setting this flag to true will enable profiling of the simulation. This will output to the logs profiling  information about the simulation execution. This can be useful to identify bottlenecks in the simulation.</p>"},{"location":"Modules/Simulator/simulation/#gradysim.simulator.simulation.SimulationConfiguration.real_time","title":"<code>real_time: Union[bool, float] = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Setting this to true will put the simulation in real-time mode. This means that the simulation will run synchronized with real-world time. One simulation second will approximately equal to one real-world second. If set to a float will run at that many times real-time. For example, setting this to 2 will make the simulation run twice as fast as real-time. The float value must be greater than 0.</p>"},{"location":"Modules/Simulator/simulation/#gradysim.simulator.simulation.PositionScheme","title":"<code>gradysim.simulator.simulation.PositionScheme</code>","text":"<p>Collection of helpers for positioning your nodes within the simulation.</p> Source code in <code>gradysim/simulator/simulation.py</code> <pre><code>class PositionScheme:\n    \"\"\"\n    Collection of helpers for positioning your nodes within the simulation.\n    \"\"\"\n\n    @staticmethod\n    def random(x_range: Tuple[float, float] = (-10, 10),\n               y_range: Tuple[float, float] = (-10, 10),\n               z_range: Tuple[float, float] = (0, 10)) -&gt; Position:\n        \"\"\"\n        Generates a random position\n        Args:\n            x_range: Range of possible positions in the x axis\n            y_range: Range of possible positions in the y axis\n            z_range: Range of possible positions in the z axis\n\n        Returns:\n            A random position within the specified ranges\n        \"\"\"\n        return (\n            random.uniform(*x_range),\n            random.uniform(*y_range),\n            random.uniform(*z_range)\n        )\n</code></pre>"},{"location":"Modules/Simulator/simulation/#gradysim.simulator.simulation.PositionScheme.random","title":"<code>random(x_range=(-10, 10), y_range=(-10, 10), z_range=(0, 10))</code>  <code>staticmethod</code>","text":"<p>Generates a random position Args:     x_range: Range of possible positions in the x axis     y_range: Range of possible positions in the y axis     z_range: Range of possible positions in the z axis</p> <p>Returns:</p> Type Description <code>Position</code> <p>A random position within the specified ranges</p> Source code in <code>gradysim/simulator/simulation.py</code> <pre><code>@staticmethod\ndef random(x_range: Tuple[float, float] = (-10, 10),\n           y_range: Tuple[float, float] = (-10, 10),\n           z_range: Tuple[float, float] = (0, 10)) -&gt; Position:\n    \"\"\"\n    Generates a random position\n    Args:\n        x_range: Range of possible positions in the x axis\n        y_range: Range of possible positions in the y axis\n        z_range: Range of possible positions in the z axis\n\n    Returns:\n        A random position within the specified ranges\n    \"\"\"\n    return (\n        random.uniform(*x_range),\n        random.uniform(*y_range),\n        random.uniform(*z_range)\n    )\n</code></pre>"},{"location":"Modules/Simulator/simulation/#gradysim.simulator.simulation.SimulationBuilder","title":"<code>gradysim.simulator.simulation.SimulationBuilder</code>","text":"<p>Helper class to build python simulations. Use the <code>add_handler</code> and <code>add_node</code> methods to build your simulation scenario them call <code>build()</code> to get a simulation instance. Use this class instead of directly trying to instantiate a <code>Simulator</code> instance.</p> <p>A simulation is build through a fluent interface. This means that you after instantiating this builder class you will set up your simulation by calling methods on that instance gradually building up your simulation.</p> <p>All methods return the SimulationBuilder instance to help you with method chaining.</p> Source code in <code>gradysim/simulator/simulation.py</code> <pre><code>class SimulationBuilder:\n    \"\"\"\n    Helper class to build python simulations. Use the `add_handler` and `add_node` methods to build your simulation\n    scenario them call `build()` to get a simulation instance. Use this class instead of directly trying to instantiate\n    a `Simulator` instance.\n\n    A simulation is build through a fluent interface. This means that you after instantiating this builder class you\n    will set up your simulation by calling methods on that instance gradually building up your simulation.\n\n    All methods return the [SimulationBuilder][gradysim.simulator.simulation.SimulationBuilder] instance to help you with method chaining.\n    \"\"\"\n\n    def __init__(self,\n                 configuration: SimulationConfiguration = SimulationConfiguration()):\n        \"\"\"\n        Initializes the simulation builder\n\n        Args:\n            configuration: Configuration used for the simulation. The default values uses all default values from the `SimulationConfiguration` class\n        \"\"\"\n        self._configuration = configuration\n        self._handlers: Dict[str, INodeHandler] = {}\n        self._nodes_to_add: list[Tuple[Position, Type[IProtocol]]] = []\n\n    def add_handler(self, handler: INodeHandler) -&gt; 'SimulationBuilder':\n        \"\"\"\n        Adds a new handler to the simulation\n\n        Args:\n            handler: A handler instance\n\n        Returns:\n            The simulator builder instance. This is useful for method chaining\n        \"\"\"\n        self._handlers[handler.get_label()] = handler\n        return self\n\n    def add_node(self, protocol: Type[IProtocol], position: Position) -&gt; int:\n        \"\"\"\n        Adds a new node to the simulation\n\n        Args:\n            protocol: Type of protocol this node will run\n            position: Position of the node inside the simulation\n\n        Returns:\n            The id of the node created\n        \"\"\"\n        self._nodes_to_add.append((position, protocol))\n        return len(self._nodes_to_add) - 1\n\n    def build(self) -&gt; Simulator:\n        \"\"\"\n        Builds the simulation. Should only be called after you have already added all nodes and handlers. Nodes\n        and handlers added after this call will not affect the instance returned by this method.\n\n        Returns:\n            Simulator instance configured using the previously called methods\n        \"\"\"\n        simulator = Simulator(\n            self._handlers,\n            self._configuration\n        )\n        for index, node_to_add in enumerate(self._nodes_to_add):\n            simulator.create_node(node_to_add[0], node_to_add[1], index)\n\n        return simulator\n</code></pre>"},{"location":"Modules/Simulator/simulation/#gradysim.simulator.simulation.SimulationBuilder.__init__","title":"<code>__init__(configuration=SimulationConfiguration())</code>","text":"<p>Initializes the simulation builder</p> <p>Parameters:</p> Name Type Description Default <code>configuration</code> <code>SimulationConfiguration</code> <p>Configuration used for the simulation. The default values uses all default values from the <code>SimulationConfiguration</code> class</p> <code>SimulationConfiguration()</code> Source code in <code>gradysim/simulator/simulation.py</code> <pre><code>def __init__(self,\n             configuration: SimulationConfiguration = SimulationConfiguration()):\n    \"\"\"\n    Initializes the simulation builder\n\n    Args:\n        configuration: Configuration used for the simulation. The default values uses all default values from the `SimulationConfiguration` class\n    \"\"\"\n    self._configuration = configuration\n    self._handlers: Dict[str, INodeHandler] = {}\n    self._nodes_to_add: list[Tuple[Position, Type[IProtocol]]] = []\n</code></pre>"},{"location":"Modules/Simulator/simulation/#gradysim.simulator.simulation.SimulationBuilder.add_handler","title":"<code>add_handler(handler)</code>","text":"<p>Adds a new handler to the simulation</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>INodeHandler</code> <p>A handler instance</p> required <p>Returns:</p> Type Description <code>SimulationBuilder</code> <p>The simulator builder instance. This is useful for method chaining</p> Source code in <code>gradysim/simulator/simulation.py</code> <pre><code>def add_handler(self, handler: INodeHandler) -&gt; 'SimulationBuilder':\n    \"\"\"\n    Adds a new handler to the simulation\n\n    Args:\n        handler: A handler instance\n\n    Returns:\n        The simulator builder instance. This is useful for method chaining\n    \"\"\"\n    self._handlers[handler.get_label()] = handler\n    return self\n</code></pre>"},{"location":"Modules/Simulator/simulation/#gradysim.simulator.simulation.SimulationBuilder.add_node","title":"<code>add_node(protocol, position)</code>","text":"<p>Adds a new node to the simulation</p> <p>Parameters:</p> Name Type Description Default <code>protocol</code> <code>Type[IProtocol]</code> <p>Type of protocol this node will run</p> required <code>position</code> <code>Position</code> <p>Position of the node inside the simulation</p> required <p>Returns:</p> Type Description <code>int</code> <p>The id of the node created</p> Source code in <code>gradysim/simulator/simulation.py</code> <pre><code>def add_node(self, protocol: Type[IProtocol], position: Position) -&gt; int:\n    \"\"\"\n    Adds a new node to the simulation\n\n    Args:\n        protocol: Type of protocol this node will run\n        position: Position of the node inside the simulation\n\n    Returns:\n        The id of the node created\n    \"\"\"\n    self._nodes_to_add.append((position, protocol))\n    return len(self._nodes_to_add) - 1\n</code></pre>"},{"location":"Modules/Simulator/simulation/#gradysim.simulator.simulation.SimulationBuilder.build","title":"<code>build()</code>","text":"<p>Builds the simulation. Should only be called after you have already added all nodes and handlers. Nodes and handlers added after this call will not affect the instance returned by this method.</p> <p>Returns:</p> Type Description <code>Simulator</code> <p>Simulator instance configured using the previously called methods</p> Source code in <code>gradysim/simulator/simulation.py</code> <pre><code>def build(self) -&gt; Simulator:\n    \"\"\"\n    Builds the simulation. Should only be called after you have already added all nodes and handlers. Nodes\n    and handlers added after this call will not affect the instance returned by this method.\n\n    Returns:\n        Simulator instance configured using the previously called methods\n    \"\"\"\n    simulator = Simulator(\n        self._handlers,\n        self._configuration\n    )\n    for index, node_to_add in enumerate(self._nodes_to_add):\n        simulator.create_node(node_to_add[0], node_to_add[1], index)\n\n    return simulator\n</code></pre>"},{"location":"Modules/Simulator/simulation/#running-the-simulation","title":"Running the simulation","text":"<p>After calling the  SimulationBuilder.build() method  you will get a Simulator instance. This instance has already been pre-baked with  all the nodes and handlers you configured using your builder. This class will  manage your simulation which can be started by calling the  start_simulation() method. That's the only Simulator method a user  has to interact with.</p> <p>The python simulation has the following overall architecture (open in a new tab if you want to take a closer look):</p> <p></p> <p>The simulation will run until either no more events exist or one of the  termination conditions set in SimulationConfiguration  are fired. To better understand the simulation you can check how the EventLoop works.</p>"},{"location":"Modules/Simulator/simulation/#gradysim.simulator.simulation.Simulator","title":"<code>gradysim.simulator.simulation.Simulator</code>","text":"<p>Executes the python simulation by managing the event loop. This class is responsible for making sure handlers' get the event loop instance they need to function, implementing simulation-level configurations like termination conditions and configuring logging.</p> <p>You shouldn't instantiate this class directly, prefer to build it through SimulationBuilder.</p> Source code in <code>gradysim/simulator/simulation.py</code> <pre><code>class Simulator:\n    \"\"\"\n    Executes the python simulation by managing the event loop. This class is responsible for making sure handlers'\n    get the event loop instance they need to function, implementing simulation-level configurations like termination\n    conditions and configuring logging.\n\n    You shouldn't instantiate this class directly, prefer to build it through\n    [SimulationBuilder][gradysim.simulator.simulation.SimulationBuilder].\n    \"\"\"\n\n    def __init__(self, handlers: Dict[str, INodeHandler], configuration: SimulationConfiguration):\n        \"\"\"\n        Instantiates the simulation class. This constructor should not be called directly, prefer to use the\n        [SimulationBuilder][gradysim.simulator.simulation.SimulationBuilder] API to get a simulator instance.\n\n        Args:\n            handlers: Dictionary of handlers indexed by their labels\n            configuration: Simulation configuration\n        \"\"\"\n        self._event_loop = EventLoop()\n        self._nodes: Dict[int, Node] = {}\n        self._handlers: Dict[str, INodeHandler] = handlers\n\n        for handler in self._handlers.values():\n            handler.inject(self._event_loop)\n\n        self._configuration = configuration\n\n        if self._configuration.real_time &lt; 0:\n            raise ValueError(\"Real time must be greater than 0\")\n\n        self._iteration = 0\n        self._current_timestamp = 0\n\n        self._formatter = setup_simulation_formatter(configuration.debug, configuration.log_file)\n        self._logger = logging.getLogger()\n\n        self._initialized = False\n        self._finalized = False\n\n        self._profiling_context_total_count = {}\n        self._profiling_context_total_time = {}\n\n\n\n    def create_node(self, position: Position, protocol: Type[IProtocol], identifier: int) -&gt; Node:\n        \"\"\"\n        Creates a new simulation node, encapsulating it. You shouldn't call this method directly, prefer to use the\n        [SimulationBuilder][gradysim.simulator.simulation.SimulationBuilder] API.\n\n        Args:\n            position: Position where the node should be placed\n            protocol: Type of protocol this node will run\n            identifier: Identifier of the node\n\n        Returns:\n            The encapsulated node\n        \"\"\"\n        new_node = Node()\n        new_node.id = identifier\n        new_node.position = position\n\n        encapsulator = PythonEncapsulator(new_node, **self._handlers)\n        encapsulator.encapsulate(protocol)\n\n        new_node.protocol_encapsulator = encapsulator\n\n        for handler in self._handlers.values():\n            handler.register_node(new_node)\n\n        self._nodes[new_node.id] = new_node\n        return new_node\n\n    def get_node(self, identifier: int) -&gt; Node:\n        \"\"\"\n        Gets a node by its identifier\n\n        Args:\n            identifier: Identifier of the node\n\n        Returns:\n            The encapsulated node\n        \"\"\"\n        return self._nodes[identifier]\n\n    def scope_event(self, iteration: int, timestamp: float, context: str):\n        \"\"\"\n        Call this method to update the formatter's annotation with current information. This module is called by\n        the [Simulator][gradysim.simulator.simulation.Simulator].\n\n        Args:\n            iteration: Current iteration the simulation is at\n            timestamp: Simulation timestamp in seconds\n            context: Context of what's being currently executed in the simulation\n\n        Returns:\n\n        \"\"\"\n        if not self._configuration.execution_logging:\n            return\n\n        self._formatter.prefix = f\"[it={iteration} time={timedelta(seconds=timestamp)} | {context}] \"\n\n    def _initialize_simulation(self) -&gt; None:\n        self._initialized = True\n\n        self._old_logger_level = self._logger.level\n        if not self._configuration.execution_logging:\n            self._logger.setLevel(logging.WARNING)\n\n        for handler in self._handlers.values():\n            handler.initialize()\n\n        for node in self._nodes.values():\n            self.scope_event(0, 0, f\"{label_node(node)} Initialization\")\n            node.protocol_encapsulator.initialize()\n\n    def _finalize_simulation(self) -&gt; None:\n        if self._finalized:\n            return\n\n        for node in self._nodes.values():\n            self.scope_event(self._iteration, 0, f\"{label_node(node)} Finalization\")\n            node.protocol_encapsulator.finish()\n\n        for handler in self._handlers.values():\n            handler.finalize()\n\n        self._formatter.clear_iteration()\n        self._finalized = True\n\n        if self._configuration.profile:\n            self._logger.info(\"[--------- Profiling information ---------]\")\n            contexts = list(self._profiling_context_total_count.keys())\n            contexts.sort(key=lambda x: self._profiling_context_total_time[x],\n                          reverse=True)\n            for context in contexts:\n                self._logger.warning(f\"Context: {context}\\t\\t\"\n                                     f\"Total count: {self._profiling_context_total_count[context]}\\t\\t\"\n                                     f\"Total time: {self._profiling_context_total_time[context]}\\t\\t\"\n                                     f\"Average time: {self._profiling_context_total_time[context] / self._profiling_context_total_count[context]}\")\n\n        if not self._configuration.execution_logging:\n            self._logger.setLevel(self._old_logger_level)\n\n    def step_simulation(self) -&gt; bool:\n        \"\"\"\n        Performs a single step in the simulation. This method is useful if you want to run the simulation in a\n        non-blocking way. This method will run a single event from the event loop and then return, updating\n        the internal simulation state.\n\n        Returns:\n            False if the simulation is done, True otherwise\n        \"\"\"\n        if not self._initialized:\n            self._initialize_simulation()\n\n        if self.is_simulation_done():\n            self._finalize_simulation()\n            return False\n\n\n        event = self._event_loop.pop_event()\n        self.scope_event(self._iteration, event.timestamp, event.context)\n\n        if self._configuration.profile:\n            start_time = time.time()\n\n        event.callback()\n\n        if self._configuration.profile:\n            self._profiling_context_total_count[event.context] = (\n                    self._profiling_context_total_count.get(event.context, 0) + 1)\n            self._profiling_context_total_time[event.context] = (\n                    self._profiling_context_total_time.get(event.context, 0) + time.time() - start_time)\n\n        for handler in self._handlers.values():\n            handler.after_simulation_step(self._iteration, event.timestamp)\n\n        self._iteration += 1\n        self._current_timestamp = event.timestamp\n\n        is_done = self.is_simulation_done()\n\n        if is_done:\n            self._finalize_simulation()\n\n        return not is_done\n\n    def start_simulation(self) -&gt; None:\n        \"\"\"\n        Call this method to start the simulation. It is a blocking call and runs until either no event is left in the\n        event loop or a termination condition is met. If not termination condition is set and events are generated\n        infinitely this simulation will run forever.\n        \"\"\"\n        self._logger.info(\"[--------- Simulation started ---------]\")\n        start_time = time.time()\n\n        last_step_duration = 0\n        is_running = True\n        while is_running:\n            next_event = self._event_loop.peek_event()\n\n            if next_event is not None and self._configuration.real_time and not _FORCE_FAST_EXECUTION:\n                time_until_next_event = (next_event.timestamp - (self._current_timestamp + last_step_duration))\n                sleep_duration = time_until_next_event / self._configuration.real_time\n                if sleep_duration &gt; 0:\n                    time.sleep(sleep_duration)\n\n            step_start = time.time()\n            is_running = self.step_simulation()\n            last_step_duration = time.time() - step_start\n\n        self._logger.info(\"[--------- Simulation finished ---------]\")\n        total_time = time.time() - start_time\n\n        self._logger.info(f\"Real time elapsed: {timedelta(seconds=total_time)}\\t\"\n                          f\"Total iterations: {self._iteration}\\t\"\n                          f\"Simulation time: {timedelta(seconds=self._current_timestamp)}\")\n\n    def is_simulation_done(self) -&gt; bool:\n        \"\"\"\n        Checks if the simulation is done. The simulation is done if any of the termination conditions are met or\n        if there are no mode events\n\n        Returns:\n            True if the simulation is done, False otherwise\n        \"\"\"\n        if len(self._event_loop) == 0:\n            return True\n\n        if self._configuration.duration is not None:\n            current_time = self._event_loop.current_time\n\n            if current_time &gt; self._configuration.duration:\n                return True\n\n        if self._configuration.max_iterations is not None and self._iteration &gt;= self._configuration.max_iterations:\n            return True\n\n        return False\n</code></pre>"},{"location":"Modules/Simulator/simulation/#gradysim.simulator.simulation.Simulator.__init__","title":"<code>__init__(handlers, configuration)</code>","text":"<p>Instantiates the simulation class. This constructor should not be called directly, prefer to use the SimulationBuilder API to get a simulator instance.</p> <p>Parameters:</p> Name Type Description Default <code>handlers</code> <code>Dict[str, INodeHandler]</code> <p>Dictionary of handlers indexed by their labels</p> required <code>configuration</code> <code>SimulationConfiguration</code> <p>Simulation configuration</p> required Source code in <code>gradysim/simulator/simulation.py</code> <pre><code>def __init__(self, handlers: Dict[str, INodeHandler], configuration: SimulationConfiguration):\n    \"\"\"\n    Instantiates the simulation class. This constructor should not be called directly, prefer to use the\n    [SimulationBuilder][gradysim.simulator.simulation.SimulationBuilder] API to get a simulator instance.\n\n    Args:\n        handlers: Dictionary of handlers indexed by their labels\n        configuration: Simulation configuration\n    \"\"\"\n    self._event_loop = EventLoop()\n    self._nodes: Dict[int, Node] = {}\n    self._handlers: Dict[str, INodeHandler] = handlers\n\n    for handler in self._handlers.values():\n        handler.inject(self._event_loop)\n\n    self._configuration = configuration\n\n    if self._configuration.real_time &lt; 0:\n        raise ValueError(\"Real time must be greater than 0\")\n\n    self._iteration = 0\n    self._current_timestamp = 0\n\n    self._formatter = setup_simulation_formatter(configuration.debug, configuration.log_file)\n    self._logger = logging.getLogger()\n\n    self._initialized = False\n    self._finalized = False\n\n    self._profiling_context_total_count = {}\n    self._profiling_context_total_time = {}\n</code></pre>"},{"location":"Modules/Simulator/simulation/#gradysim.simulator.simulation.Simulator.create_node","title":"<code>create_node(position, protocol, identifier)</code>","text":"<p>Creates a new simulation node, encapsulating it. You shouldn't call this method directly, prefer to use the SimulationBuilder API.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>Position</code> <p>Position where the node should be placed</p> required <code>protocol</code> <code>Type[IProtocol]</code> <p>Type of protocol this node will run</p> required <code>identifier</code> <code>int</code> <p>Identifier of the node</p> required <p>Returns:</p> Type Description <code>Node</code> <p>The encapsulated node</p> Source code in <code>gradysim/simulator/simulation.py</code> <pre><code>def create_node(self, position: Position, protocol: Type[IProtocol], identifier: int) -&gt; Node:\n    \"\"\"\n    Creates a new simulation node, encapsulating it. You shouldn't call this method directly, prefer to use the\n    [SimulationBuilder][gradysim.simulator.simulation.SimulationBuilder] API.\n\n    Args:\n        position: Position where the node should be placed\n        protocol: Type of protocol this node will run\n        identifier: Identifier of the node\n\n    Returns:\n        The encapsulated node\n    \"\"\"\n    new_node = Node()\n    new_node.id = identifier\n    new_node.position = position\n\n    encapsulator = PythonEncapsulator(new_node, **self._handlers)\n    encapsulator.encapsulate(protocol)\n\n    new_node.protocol_encapsulator = encapsulator\n\n    for handler in self._handlers.values():\n        handler.register_node(new_node)\n\n    self._nodes[new_node.id] = new_node\n    return new_node\n</code></pre>"},{"location":"Modules/Simulator/simulation/#gradysim.simulator.simulation.Simulator.get_node","title":"<code>get_node(identifier)</code>","text":"<p>Gets a node by its identifier</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>int</code> <p>Identifier of the node</p> required <p>Returns:</p> Type Description <code>Node</code> <p>The encapsulated node</p> Source code in <code>gradysim/simulator/simulation.py</code> <pre><code>def get_node(self, identifier: int) -&gt; Node:\n    \"\"\"\n    Gets a node by its identifier\n\n    Args:\n        identifier: Identifier of the node\n\n    Returns:\n        The encapsulated node\n    \"\"\"\n    return self._nodes[identifier]\n</code></pre>"},{"location":"Modules/Simulator/simulation/#gradysim.simulator.simulation.Simulator.is_simulation_done","title":"<code>is_simulation_done()</code>","text":"<p>Checks if the simulation is done. The simulation is done if any of the termination conditions are met or if there are no mode events</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the simulation is done, False otherwise</p> Source code in <code>gradysim/simulator/simulation.py</code> <pre><code>def is_simulation_done(self) -&gt; bool:\n    \"\"\"\n    Checks if the simulation is done. The simulation is done if any of the termination conditions are met or\n    if there are no mode events\n\n    Returns:\n        True if the simulation is done, False otherwise\n    \"\"\"\n    if len(self._event_loop) == 0:\n        return True\n\n    if self._configuration.duration is not None:\n        current_time = self._event_loop.current_time\n\n        if current_time &gt; self._configuration.duration:\n            return True\n\n    if self._configuration.max_iterations is not None and self._iteration &gt;= self._configuration.max_iterations:\n        return True\n\n    return False\n</code></pre>"},{"location":"Modules/Simulator/simulation/#gradysim.simulator.simulation.Simulator.scope_event","title":"<code>scope_event(iteration, timestamp, context)</code>","text":"<p>Call this method to update the formatter's annotation with current information. This module is called by the Simulator.</p> <p>Parameters:</p> Name Type Description Default <code>iteration</code> <code>int</code> <p>Current iteration the simulation is at</p> required <code>timestamp</code> <code>float</code> <p>Simulation timestamp in seconds</p> required <code>context</code> <code>str</code> <p>Context of what's being currently executed in the simulation</p> required <p>Returns:</p> Source code in <code>gradysim/simulator/simulation.py</code> <pre><code>def scope_event(self, iteration: int, timestamp: float, context: str):\n    \"\"\"\n    Call this method to update the formatter's annotation with current information. This module is called by\n    the [Simulator][gradysim.simulator.simulation.Simulator].\n\n    Args:\n        iteration: Current iteration the simulation is at\n        timestamp: Simulation timestamp in seconds\n        context: Context of what's being currently executed in the simulation\n\n    Returns:\n\n    \"\"\"\n    if not self._configuration.execution_logging:\n        return\n\n    self._formatter.prefix = f\"[it={iteration} time={timedelta(seconds=timestamp)} | {context}] \"\n</code></pre>"},{"location":"Modules/Simulator/simulation/#gradysim.simulator.simulation.Simulator.start_simulation","title":"<code>start_simulation()</code>","text":"<p>Call this method to start the simulation. It is a blocking call and runs until either no event is left in the event loop or a termination condition is met. If not termination condition is set and events are generated infinitely this simulation will run forever.</p> Source code in <code>gradysim/simulator/simulation.py</code> <pre><code>def start_simulation(self) -&gt; None:\n    \"\"\"\n    Call this method to start the simulation. It is a blocking call and runs until either no event is left in the\n    event loop or a termination condition is met. If not termination condition is set and events are generated\n    infinitely this simulation will run forever.\n    \"\"\"\n    self._logger.info(\"[--------- Simulation started ---------]\")\n    start_time = time.time()\n\n    last_step_duration = 0\n    is_running = True\n    while is_running:\n        next_event = self._event_loop.peek_event()\n\n        if next_event is not None and self._configuration.real_time and not _FORCE_FAST_EXECUTION:\n            time_until_next_event = (next_event.timestamp - (self._current_timestamp + last_step_duration))\n            sleep_duration = time_until_next_event / self._configuration.real_time\n            if sleep_duration &gt; 0:\n                time.sleep(sleep_duration)\n\n        step_start = time.time()\n        is_running = self.step_simulation()\n        last_step_duration = time.time() - step_start\n\n    self._logger.info(\"[--------- Simulation finished ---------]\")\n    total_time = time.time() - start_time\n\n    self._logger.info(f\"Real time elapsed: {timedelta(seconds=total_time)}\\t\"\n                      f\"Total iterations: {self._iteration}\\t\"\n                      f\"Simulation time: {timedelta(seconds=self._current_timestamp)}\")\n</code></pre>"},{"location":"Modules/Simulator/simulation/#gradysim.simulator.simulation.Simulator.step_simulation","title":"<code>step_simulation()</code>","text":"<p>Performs a single step in the simulation. This method is useful if you want to run the simulation in a non-blocking way. This method will run a single event from the event loop and then return, updating the internal simulation state.</p> <p>Returns:</p> Type Description <code>bool</code> <p>False if the simulation is done, True otherwise</p> Source code in <code>gradysim/simulator/simulation.py</code> <pre><code>def step_simulation(self) -&gt; bool:\n    \"\"\"\n    Performs a single step in the simulation. This method is useful if you want to run the simulation in a\n    non-blocking way. This method will run a single event from the event loop and then return, updating\n    the internal simulation state.\n\n    Returns:\n        False if the simulation is done, True otherwise\n    \"\"\"\n    if not self._initialized:\n        self._initialize_simulation()\n\n    if self.is_simulation_done():\n        self._finalize_simulation()\n        return False\n\n\n    event = self._event_loop.pop_event()\n    self.scope_event(self._iteration, event.timestamp, event.context)\n\n    if self._configuration.profile:\n        start_time = time.time()\n\n    event.callback()\n\n    if self._configuration.profile:\n        self._profiling_context_total_count[event.context] = (\n                self._profiling_context_total_count.get(event.context, 0) + 1)\n        self._profiling_context_total_time[event.context] = (\n                self._profiling_context_total_time.get(event.context, 0) + time.time() - start_time)\n\n    for handler in self._handlers.values():\n        handler.after_simulation_step(self._iteration, event.timestamp)\n\n    self._iteration += 1\n    self._current_timestamp = event.timestamp\n\n    is_done = self.is_simulation_done()\n\n    if is_done:\n        self._finalize_simulation()\n\n    return not is_done\n</code></pre>"},{"location":"Modules/Simulator/Extension/","title":"Introduction","text":""},{"location":"Modules/Simulator/Extension/#gradysim.simulator.extension","title":"<code>gradysim.simulator.extension</code>","text":"<p>Simulator extensions or simply extensions are modules that extend the functionality of the python simulator. They are used to implement new features or to provide new ways to interact with the simulation environment.</p> <p>Extensions are implemented as classes that inherit from the Extension class. Extensions are attached to a protocol instance but have ways of interacting with the simulation environment that the protocol does not. In practice, extensions can directly access handlers and modify the simulation environment.</p> <p>Warning</p> <p>Extensions are attached to an initialized protocol. Instantiating an extension on an uninitialized protocol will raise a <code>ReferenceError</code>.</p> <p>Info</p> <p>Most extensions rely on a specific handler being present in the simulation. Check their own documentation to see which handlers they rely on.</p>"},{"location":"Modules/Simulator/Extension/#gradysim.simulator.extension.extension.Extension","title":"<code>gradysim.simulator.extension.extension.Extension</code>","text":"<p>Base class for all extensions. Extensions are classes that can be used to extend the functionality of the simulation environment. They are designed to be used by protocols to interact with the simulation environment in a more sophisticated way.</p> Source code in <code>gradysim/simulator/extension/extension.py</code> <pre><code>class Extension:\n    \"\"\"\n    Base class for all extensions. Extensions are classes that can be used to extend the functionality of the simulation\n    environment. They are designed to be used by protocols to interact with the simulation environment in a more\n    sophisticated way.\n    \"\"\"\n\n    _provider: Optional[PythonProvider]\n\n    def __init__(self, protocol: IProtocol):\n        provider = protocol.provider\n\n        if protocol.provider is None:\n            raise ReferenceError(\"Protocol provider is not initialized. Make sure you are not creating this extension \"\n                                 \"before the protocol's initialize method is called.\")\n\n        if not isinstance(provider, PythonProvider):\n            warnings.warn(\"Extensions can only be ran in a python simulation environment. \"\n                          \"Every functionality in this extension will be a no-op.\")\n            self._provider = None\n        else:\n            self._provider = provider\n</code></pre>"},{"location":"Modules/Simulator/Extension/camera/","title":"Camera","text":""},{"location":"Modules/Simulator/Extension/camera/#gradysim.simulator.extension.camera.CameraHardware","title":"<code>gradysim.simulator.extension.camera.CameraHardware</code>","text":"<p>               Bases: <code>Extension</code></p> <p>This extension simulates a camera hardware that can detect other nodes within its area of detection. The camera has a reach, field of view, and direction of facing. The camera is capable of taking pictures, returning the list of detected nodes within its area of detection.</p> <p>The area of detection is a cone whose point is at the node's position and base faces the direction the camera is pointing to, determined by the facing_inclination and facing_rotation attributes of the configuration. The cone's angle at the point is determined by the field_of_view attribute of the configuration. The cone's length, or the distance between its point and base, is determined by the cone_reach attribute of the configuration.</p> Source code in <code>gradysim/simulator/extension/camera.py</code> <pre><code>class CameraHardware(Extension):\n    \"\"\"\n    This extension simulates a camera hardware that can detect other nodes within its area of detection. The camera\n    has a reach, field of view, and direction of facing. The camera is capable of taking pictures, returning the list\n    of detected nodes within its area of detection.\n\n    The area of detection is a cone whose point is at the node's position and base faces the direction the camera is\n    pointing to, determined by the facing_inclination and facing_rotation attributes of the configuration. The cone's\n    angle at the point is determined by the field_of_view attribute of the configuration. The cone's length, or the\n    distance between its point and base, is determined by the cone_reach attribute of the configuration.\n    \"\"\"\n\n    def __init__(self, protocol: IProtocol, configuration: CameraConfiguration):\n        super().__init__(protocol)\n        if self._provider is not None:\n            self._mobility: Optional[MobilityHandler] = self._provider.handlers.get('mobility')\n        self._configuration = configuration\n\n        self._camera_vector = self._camera_direction_unit_vector()\n        self._camera_theta = math.radians(self._configuration.camera_theta)\n\n    def _camera_direction_unit_vector(self) -&gt; Tuple[float, float, float]:\n        \"\"\"\n        Returns the unit vector that represents the direction the camera is facing to\n        Returns:\n            A tuple representing the unit vector\n        \"\"\"\n        facing_inclination = math.radians(self._configuration.facing_elevation)\n        facing_rotation = math.radians(self._configuration.facing_rotation)\n\n        x = math.sin(facing_inclination) * math.cos(facing_rotation)\n        y = math.sin(facing_inclination) * math.sin(facing_rotation)\n        z = math.cos(facing_inclination)\n\n        return x, y, z\n\n    def take_picture(self) -&gt; List[DetectedNode]:\n        \"\"\"\n        This simulated camera hardware is able to detect other nodes within its are of detection. This method returns\n        the list of nodes currently inside the area of detection of the camera.\n        Returns:\n            A list of detected nodes\n        \"\"\"\n        if self._mobility is None:\n            return []\n\n        node_position = self._provider.node.position\n\n        other_nodes = [node for node in self._mobility.nodes.values() if node.id != self._provider.node.id]\n\n        detected_nodes = []\n        for node in other_nodes:\n            other_node_position = node.position\n            relative_vector = (\n                other_node_position[0] - node_position[0],\n                other_node_position[1] - node_position[1],\n                other_node_position[2] - node_position[2]\n            )\n\n            # Check if the node is within the camera's reach\n            distance = math.sqrt(relative_vector[0] ** 2 + relative_vector[1] ** 2 + relative_vector[2] ** 2)\n            if distance &gt; self._configuration.camera_reach:\n                continue\n\n            if distance &gt; 0:\n                # Check if the angle between vectors is less than theta\n                normalized_relative_vector = (\n                    relative_vector[0] / distance,\n                    relative_vector[1] / distance,\n                    relative_vector[2] / distance\n                )\n                dot_product = (\n                    self._camera_vector[0] * normalized_relative_vector[0] +\n                    self._camera_vector[1] * normalized_relative_vector[1] +\n                    self._camera_vector[2] * normalized_relative_vector[2]\n                )\n                angle = math.acos(dot_product) - 1e-6 # Tolerance\n                if angle &gt; self._camera_theta:\n                    continue\n\n            detected_nodes.append({\n                'position': other_node_position,\n                'type': 'node'\n            })\n\n        return detected_nodes\n\n    def change_facing(self, facing_elevation: float, facing_rotation: float):\n        \"\"\"\n        Changes the direction the camera is facing to\n        Args:\n            facing_elevation: The inclination of where the camera is pointing to in degrees, with 0 being at the ground\n            facing_rotation: The rotation of the camera in degrees, with zero being along the x-axis in the positive direction\n        \"\"\"\n        self._configuration.facing_elevation = facing_elevation\n        self._configuration.facing_rotation = facing_rotation\n        self._camera_vector = self._camera_direction_unit_vector()\n</code></pre>"},{"location":"Modules/Simulator/Extension/camera/#gradysim.simulator.extension.camera.CameraHardware.change_facing","title":"<code>change_facing(facing_elevation, facing_rotation)</code>","text":"<p>Changes the direction the camera is facing to Args:     facing_elevation: The inclination of where the camera is pointing to in degrees, with 0 being at the ground     facing_rotation: The rotation of the camera in degrees, with zero being along the x-axis in the positive direction</p> Source code in <code>gradysim/simulator/extension/camera.py</code> <pre><code>def change_facing(self, facing_elevation: float, facing_rotation: float):\n    \"\"\"\n    Changes the direction the camera is facing to\n    Args:\n        facing_elevation: The inclination of where the camera is pointing to in degrees, with 0 being at the ground\n        facing_rotation: The rotation of the camera in degrees, with zero being along the x-axis in the positive direction\n    \"\"\"\n    self._configuration.facing_elevation = facing_elevation\n    self._configuration.facing_rotation = facing_rotation\n    self._camera_vector = self._camera_direction_unit_vector()\n</code></pre>"},{"location":"Modules/Simulator/Extension/camera/#gradysim.simulator.extension.camera.CameraHardware.take_picture","title":"<code>take_picture()</code>","text":"<p>This simulated camera hardware is able to detect other nodes within its are of detection. This method returns the list of nodes currently inside the area of detection of the camera. Returns:     A list of detected nodes</p> Source code in <code>gradysim/simulator/extension/camera.py</code> <pre><code>def take_picture(self) -&gt; List[DetectedNode]:\n    \"\"\"\n    This simulated camera hardware is able to detect other nodes within its are of detection. This method returns\n    the list of nodes currently inside the area of detection of the camera.\n    Returns:\n        A list of detected nodes\n    \"\"\"\n    if self._mobility is None:\n        return []\n\n    node_position = self._provider.node.position\n\n    other_nodes = [node for node in self._mobility.nodes.values() if node.id != self._provider.node.id]\n\n    detected_nodes = []\n    for node in other_nodes:\n        other_node_position = node.position\n        relative_vector = (\n            other_node_position[0] - node_position[0],\n            other_node_position[1] - node_position[1],\n            other_node_position[2] - node_position[2]\n        )\n\n        # Check if the node is within the camera's reach\n        distance = math.sqrt(relative_vector[0] ** 2 + relative_vector[1] ** 2 + relative_vector[2] ** 2)\n        if distance &gt; self._configuration.camera_reach:\n            continue\n\n        if distance &gt; 0:\n            # Check if the angle between vectors is less than theta\n            normalized_relative_vector = (\n                relative_vector[0] / distance,\n                relative_vector[1] / distance,\n                relative_vector[2] / distance\n            )\n            dot_product = (\n                self._camera_vector[0] * normalized_relative_vector[0] +\n                self._camera_vector[1] * normalized_relative_vector[1] +\n                self._camera_vector[2] * normalized_relative_vector[2]\n            )\n            angle = math.acos(dot_product) - 1e-6 # Tolerance\n            if angle &gt; self._camera_theta:\n                continue\n\n        detected_nodes.append({\n            'position': other_node_position,\n            'type': 'node'\n        })\n\n    return detected_nodes\n</code></pre>"},{"location":"Modules/Simulator/Extension/communication_controller/","title":"Communication controller","text":""},{"location":"Modules/Simulator/Extension/communication_controller/#gradysim.simulator.extension.communication_controller.CommunicationController","title":"<code>gradysim.simulator.extension.communication_controller.CommunicationController</code>","text":"<p>               Bases: <code>Extension</code></p> <p>Controller for the communication handler. Can be used to send commands to the communication handler from a protocol. Commands affect the communication between nodes, such as changing the transmission range.</p> <p>Info</p> <p>Every method in this class is a no-op if a communication handler is not active. This includes when the protocol is not running on a python simulation environment.</p> <p>Warning</p> <p>This class is an extension and will raise an error if the protocol is not running on a python simulation.</p> Source code in <code>gradysim/simulator/extension/communication_controller.py</code> <pre><code>class CommunicationController(Extension):\n    \"\"\"\n    Controller for the communication handler. Can be used to send commands to the communication handler from a\n    protocol. Commands affect the communication between nodes, such as changing the transmission range.\n\n    !!!info\n        Every method in this class is a no-op if a communication handler is not active. This includes when the protocol\n        is not running on a python simulation environment.\n\n    !!!warning\n        This class is an [extension][gradysim.simulator.extension] and will raise an error if the protocol is not\n        running on a python simulation.\n    \"\"\"\n\n    def __init__(self, protocol: IProtocol):\n        super().__init__(protocol)\n        if self._provider is not None:\n            self._communication: Optional[CommunicationHandler] = self._provider.handlers.get(\"communication\")\n        if self._communication is None:\n            logging.warning(\"No communication handler detected. All commands will be no-ops.\")\n\n    def set_transmission_range(self, transmission_range: float):\n        \"\"\"\n        Sets the transmission range of the protocol. This only affects the range of transmission, meaning other nodes\n        will receive communication messages from this node if they are within this range; but not the reverse.\n\n        No-op if no communication handler is active.\n\n        Args:\n            transmission_range: The new transmission range of the protocol. Must be a positive number.\n\n        Raises:\n            ValueError: If the transmission range is a negative number.\n        \"\"\"\n        if transmission_range &lt; 0:\n            raise ValueError(\"Transmission range must be a positive number.\")\n\n        if self._communication is None:\n            logging.warning(\"No communication handler detected, command ignored.\")\n            return\n\n        self._communication.transmission_ranges[self._provider.get_id()] = transmission_range\n\n    def get_transmission_range(self) -&gt; Optional[float]:\n        \"\"\"\n        Gets the current transmission range of the protocol. If no communication handler is active, returns None.\n\n        Returns:\n            The transmission range of the protocol. If no communication handler is active, returns None\n        \"\"\"\n        if self._communication is None:\n            logging.warning(\"No communication handler detected, returning 0.\")\n            return None\n\n        return self._communication.transmission_ranges[self._provider.get_id()]\n</code></pre>"},{"location":"Modules/Simulator/Extension/communication_controller/#gradysim.simulator.extension.communication_controller.CommunicationController.get_transmission_range","title":"<code>get_transmission_range()</code>","text":"<p>Gets the current transmission range of the protocol. If no communication handler is active, returns None.</p> <p>Returns:</p> Type Description <code>Optional[float]</code> <p>The transmission range of the protocol. If no communication handler is active, returns None</p> Source code in <code>gradysim/simulator/extension/communication_controller.py</code> <pre><code>def get_transmission_range(self) -&gt; Optional[float]:\n    \"\"\"\n    Gets the current transmission range of the protocol. If no communication handler is active, returns None.\n\n    Returns:\n        The transmission range of the protocol. If no communication handler is active, returns None\n    \"\"\"\n    if self._communication is None:\n        logging.warning(\"No communication handler detected, returning 0.\")\n        return None\n\n    return self._communication.transmission_ranges[self._provider.get_id()]\n</code></pre>"},{"location":"Modules/Simulator/Extension/communication_controller/#gradysim.simulator.extension.communication_controller.CommunicationController.set_transmission_range","title":"<code>set_transmission_range(transmission_range)</code>","text":"<p>Sets the transmission range of the protocol. This only affects the range of transmission, meaning other nodes will receive communication messages from this node if they are within this range; but not the reverse.</p> <p>No-op if no communication handler is active.</p> <p>Parameters:</p> Name Type Description Default <code>transmission_range</code> <code>float</code> <p>The new transmission range of the protocol. Must be a positive number.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the transmission range is a negative number.</p> Source code in <code>gradysim/simulator/extension/communication_controller.py</code> <pre><code>def set_transmission_range(self, transmission_range: float):\n    \"\"\"\n    Sets the transmission range of the protocol. This only affects the range of transmission, meaning other nodes\n    will receive communication messages from this node if they are within this range; but not the reverse.\n\n    No-op if no communication handler is active.\n\n    Args:\n        transmission_range: The new transmission range of the protocol. Must be a positive number.\n\n    Raises:\n        ValueError: If the transmission range is a negative number.\n    \"\"\"\n    if transmission_range &lt; 0:\n        raise ValueError(\"Transmission range must be a positive number.\")\n\n    if self._communication is None:\n        logging.warning(\"No communication handler detected, command ignored.\")\n        return\n\n    self._communication.transmission_ranges[self._provider.get_id()] = transmission_range\n</code></pre>"},{"location":"Modules/Simulator/Extension/visualization_controller/","title":"Visualization controller","text":""},{"location":"Modules/Simulator/Extension/visualization_controller/#gradysim.simulator.extension.visualization_controller.VisualizationController","title":"<code>gradysim.simulator.extension.visualization_controller.VisualizationController</code>","text":"<p>               Bases: <code>Extension</code></p> <p>Controller for the visualization handler. Can be used to send commands to the visualization handler from a protocol. Commands can be used to affect the visualization, such as painting nodes or changing the environment's color.</p> <p>Info</p> <p>Every method in this class is a no-op if a visualization handler is not active. This includes when the protocol is not running on a python simulation environment.</p> <p>Warning</p> <p>This class is an extension and will raise an error if the protocol is not running on a python simulation.</p> Source code in <code>gradysim/simulator/extension/visualization_controller.py</code> <pre><code>class VisualizationController(Extension):\n    \"\"\"\n    Controller for the visualization handler. Can be used to send commands to the visualization handler from a\n    protocol. Commands can be used to affect the visualization, such as painting nodes or changing the\n    environment's color.\n\n    !!!info\n        Every method in this class is a no-op if a visualization handler is not active. This includes when the protocol is\n        not running on a python simulation environment.\n\n    !!!warning\n        This class is an [extension][gradysim.simulator.extension] and will raise an error if the protocol is not\n        running on a python simulation.\n    \"\"\"\n    def __init__(self, protocol: IProtocol):\n        super().__init__(protocol)\n        if self._provider is not None:\n            self._visualization_handler: Optional[VisualizationHandler] = \\\n                self._provider.handlers.get(\"visualization\") if self._provider is not None else None\n\n    def paint_node(self, node_id: int, color: Tuple[float, float, float]) -&gt; None:\n        \"\"\"\n        Paints a node in the visualization with a specific color.\n\n        Args:\n            node_id: ID of the node to paint\n            color: RGB color of the node\n        \"\"\"\n        if self._visualization_handler is None:\n            return\n\n        self._visualization_handler.command_queue.put({\n            \"command\": \"paint_node\",\n            \"payload\": {\n                \"node_id\": node_id,\n                \"color\": color\n            }\n        })\n\n    def paint_environment(self, color: Tuple[float, float, float]) -&gt; None:\n        \"\"\"\n        Paints the environment in the visualization with a specific color.\n\n        Args:\n            color: RGB color of the environment\n        \"\"\"\n        if self._visualization_handler is None:\n            return\n\n        self._visualization_handler.command_queue.put({\n            \"command\": \"paint_environment\",\n            \"payload\": {\n                \"color\": color\n            }\n        })\n\n    def resize_nodes(self, size: float) -&gt; None:\n        \"\"\"\n        Resizes the nodes in the visualization\n        Args:\n            size: New size of the nodes\n        \"\"\"\n        if self._visualization_handler is None:\n            return\n\n        self._visualization_handler.command_queue.put({\n            \"command\": \"resize_nodes\",\n            \"payload\": {\n                \"size\": size\n            }\n        })\n\n    def show_node_id(self, node_id: int, show: bool):\n        \"\"\"\n        Paints or unpaints the node_id text over the node.\n        Args:\n            node_id: ID of the node\n            show: wheter to show the node_id or not\n        \"\"\"\n        if self._visualization_handler is None:\n            return\n\n        self._visualization_handler.command_queue.put({\n            \"command\": \"show_node_id\",\n            \"payload\": {\n                \"node_id\": node_id,\n                \"show\": show,\n            }\n        })\n</code></pre>"},{"location":"Modules/Simulator/Extension/visualization_controller/#gradysim.simulator.extension.visualization_controller.VisualizationController.paint_environment","title":"<code>paint_environment(color)</code>","text":"<p>Paints the environment in the visualization with a specific color.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>Tuple[float, float, float]</code> <p>RGB color of the environment</p> required Source code in <code>gradysim/simulator/extension/visualization_controller.py</code> <pre><code>def paint_environment(self, color: Tuple[float, float, float]) -&gt; None:\n    \"\"\"\n    Paints the environment in the visualization with a specific color.\n\n    Args:\n        color: RGB color of the environment\n    \"\"\"\n    if self._visualization_handler is None:\n        return\n\n    self._visualization_handler.command_queue.put({\n        \"command\": \"paint_environment\",\n        \"payload\": {\n            \"color\": color\n        }\n    })\n</code></pre>"},{"location":"Modules/Simulator/Extension/visualization_controller/#gradysim.simulator.extension.visualization_controller.VisualizationController.paint_node","title":"<code>paint_node(node_id, color)</code>","text":"<p>Paints a node in the visualization with a specific color.</p> <p>Parameters:</p> Name Type Description Default <code>node_id</code> <code>int</code> <p>ID of the node to paint</p> required <code>color</code> <code>Tuple[float, float, float]</code> <p>RGB color of the node</p> required Source code in <code>gradysim/simulator/extension/visualization_controller.py</code> <pre><code>def paint_node(self, node_id: int, color: Tuple[float, float, float]) -&gt; None:\n    \"\"\"\n    Paints a node in the visualization with a specific color.\n\n    Args:\n        node_id: ID of the node to paint\n        color: RGB color of the node\n    \"\"\"\n    if self._visualization_handler is None:\n        return\n\n    self._visualization_handler.command_queue.put({\n        \"command\": \"paint_node\",\n        \"payload\": {\n            \"node_id\": node_id,\n            \"color\": color\n        }\n    })\n</code></pre>"},{"location":"Modules/Simulator/Extension/visualization_controller/#gradysim.simulator.extension.visualization_controller.VisualizationController.resize_nodes","title":"<code>resize_nodes(size)</code>","text":"<p>Resizes the nodes in the visualization Args:     size: New size of the nodes</p> Source code in <code>gradysim/simulator/extension/visualization_controller.py</code> <pre><code>def resize_nodes(self, size: float) -&gt; None:\n    \"\"\"\n    Resizes the nodes in the visualization\n    Args:\n        size: New size of the nodes\n    \"\"\"\n    if self._visualization_handler is None:\n        return\n\n    self._visualization_handler.command_queue.put({\n        \"command\": \"resize_nodes\",\n        \"payload\": {\n            \"size\": size\n        }\n    })\n</code></pre>"},{"location":"Modules/Simulator/Extension/visualization_controller/#gradysim.simulator.extension.visualization_controller.VisualizationController.show_node_id","title":"<code>show_node_id(node_id, show)</code>","text":"<p>Paints or unpaints the node_id text over the node. Args:     node_id: ID of the node     show: wheter to show the node_id or not</p> Source code in <code>gradysim/simulator/extension/visualization_controller.py</code> <pre><code>def show_node_id(self, node_id: int, show: bool):\n    \"\"\"\n    Paints or unpaints the node_id text over the node.\n    Args:\n        node_id: ID of the node\n        show: wheter to show the node_id or not\n    \"\"\"\n    if self._visualization_handler is None:\n        return\n\n    self._visualization_handler.command_queue.put({\n        \"command\": \"show_node_id\",\n        \"payload\": {\n            \"node_id\": node_id,\n            \"show\": show,\n        }\n    })\n</code></pre>"},{"location":"Modules/Simulator/handlers/","title":"Introduction","text":""},{"location":"Modules/Simulator/handlers/#gradysim.simulator.handler","title":"<code>gradysim.simulator.handler</code>","text":"<p>The Simulator and EventLoop provide the backbone upon which handlers implement functionalities into the simulation. In principle handlers are  classes that have access to the event loop of the simulation and to it's nodes.</p> <p>Handlers are registered during the building of the simulation, they are  associated with a label and providers can access them through this  label. Protocols can access them indirectly through the providers.  Handlers can also have indirect effect on protocols indirectly since they have access to the encapsulated network node.</p> <p>Every handler implements the IHandler interface.</p>"},{"location":"Modules/Simulator/handlers/#gradysim.simulator.handler.interface.INodeHandler","title":"<code>gradysim.simulator.handler.interface.INodeHandler</code>","text":"<p>               Bases: <code>ABC</code></p> <p>The common interface every handler should implement.</p> Source code in <code>gradysim/simulator/handler/interface.py</code> <pre><code>class INodeHandler(ABC):\n    \"\"\"\n    The common interface every handler should implement.\n    \"\"\"\n\n    @staticmethod\n    @abstractmethod\n    def get_label() -&gt; str:\n        \"\"\"\n        Static method returning the unique label of the handler. \n        If two handlers with the same label are registered only the last registered one will be accessible in the simulation.\n\n        Returns:\n            The unique label of this handler\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def inject(self, event_loop: EventLoop) -&gt; None:\n        \"\"\"\n        This function is called when the simulator is instantiated to provide the handler with the simulation's\n        event loop.\n\n        Args:\n            event_loop: The simulation's event loop instance\n        \"\"\"\n        pass\n\n    def initialize(self) -&gt; None:\n        \"\"\"\n        This is called after the simulation is initialized. Useful if the handler implements some functionality\n        that depends on running code at the beginning of the simulation.\n        \"\"\"\n        pass\n\n    def after_simulation_step(self, iteration: int, timestamp: float) -&gt; None:\n        \"\"\"\n        This callback function is called after every simulation step. Useful if the handler implements some \n        functionality that depends on running code at every step of the simulation.\n\n        Args:\n            iteration: Number of the iteration currently being ran\n            timestamp: Current simulation timestamp in seconds\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def register_node(self, node: Node) -&gt; None:\n        \"\"\"\n        This is called after a node is added to the simulation's build process. The encapsulated node is\n        passed as an argument.\n\n        Args:\n            node: Encapsulated node instance added to the simulation\n        \"\"\"\n        pass\n\n    def finalize(self) -&gt; None:\n        \"\"\"\n        This is called after the simulation is finished. Useful if the handler implements some functionality\n        that depends on running code at the end of the simulation.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"Modules/Simulator/handlers/#gradysim.simulator.handler.interface.INodeHandler.after_simulation_step","title":"<code>after_simulation_step(iteration, timestamp)</code>","text":"<p>This callback function is called after every simulation step. Useful if the handler implements some  functionality that depends on running code at every step of the simulation.</p> <p>Parameters:</p> Name Type Description Default <code>iteration</code> <code>int</code> <p>Number of the iteration currently being ran</p> required <code>timestamp</code> <code>float</code> <p>Current simulation timestamp in seconds</p> required Source code in <code>gradysim/simulator/handler/interface.py</code> <pre><code>def after_simulation_step(self, iteration: int, timestamp: float) -&gt; None:\n    \"\"\"\n    This callback function is called after every simulation step. Useful if the handler implements some \n    functionality that depends on running code at every step of the simulation.\n\n    Args:\n        iteration: Number of the iteration currently being ran\n        timestamp: Current simulation timestamp in seconds\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Modules/Simulator/handlers/#gradysim.simulator.handler.interface.INodeHandler.finalize","title":"<code>finalize()</code>","text":"<p>This is called after the simulation is finished. Useful if the handler implements some functionality that depends on running code at the end of the simulation.</p> Source code in <code>gradysim/simulator/handler/interface.py</code> <pre><code>def finalize(self) -&gt; None:\n    \"\"\"\n    This is called after the simulation is finished. Useful if the handler implements some functionality\n    that depends on running code at the end of the simulation.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Modules/Simulator/handlers/#gradysim.simulator.handler.interface.INodeHandler.get_label","title":"<code>get_label()</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Static method returning the unique label of the handler.  If two handlers with the same label are registered only the last registered one will be accessible in the simulation.</p> <p>Returns:</p> Type Description <code>str</code> <p>The unique label of this handler</p> Source code in <code>gradysim/simulator/handler/interface.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef get_label() -&gt; str:\n    \"\"\"\n    Static method returning the unique label of the handler. \n    If two handlers with the same label are registered only the last registered one will be accessible in the simulation.\n\n    Returns:\n        The unique label of this handler\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Modules/Simulator/handlers/#gradysim.simulator.handler.interface.INodeHandler.initialize","title":"<code>initialize()</code>","text":"<p>This is called after the simulation is initialized. Useful if the handler implements some functionality that depends on running code at the beginning of the simulation.</p> Source code in <code>gradysim/simulator/handler/interface.py</code> <pre><code>def initialize(self) -&gt; None:\n    \"\"\"\n    This is called after the simulation is initialized. Useful if the handler implements some functionality\n    that depends on running code at the beginning of the simulation.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Modules/Simulator/handlers/#gradysim.simulator.handler.interface.INodeHandler.inject","title":"<code>inject(event_loop)</code>  <code>abstractmethod</code>","text":"<p>This function is called when the simulator is instantiated to provide the handler with the simulation's event loop.</p> <p>Parameters:</p> Name Type Description Default <code>event_loop</code> <code>EventLoop</code> <p>The simulation's event loop instance</p> required Source code in <code>gradysim/simulator/handler/interface.py</code> <pre><code>@abstractmethod\ndef inject(self, event_loop: EventLoop) -&gt; None:\n    \"\"\"\n    This function is called when the simulator is instantiated to provide the handler with the simulation's\n    event loop.\n\n    Args:\n        event_loop: The simulation's event loop instance\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Modules/Simulator/handlers/#gradysim.simulator.handler.interface.INodeHandler.register_node","title":"<code>register_node(node)</code>  <code>abstractmethod</code>","text":"<p>This is called after a node is added to the simulation's build process. The encapsulated node is passed as an argument.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Node</code> <p>Encapsulated node instance added to the simulation</p> required Source code in <code>gradysim/simulator/handler/interface.py</code> <pre><code>@abstractmethod\ndef register_node(self, node: Node) -&gt; None:\n    \"\"\"\n    This is called after a node is added to the simulation's build process. The encapsulated node is\n    passed as an argument.\n\n    Args:\n        node: Encapsulated node instance added to the simulation\n    \"\"\"\n    pass\n</code></pre>"},{"location":"Modules/Simulator/handlers/assertion/","title":"Assertion","text":""},{"location":"Modules/Simulator/handlers/assertion/#gradysim.simulator.handler.assertion.AssertionHandler","title":"<code>gradysim.simulator.handler.assertion.AssertionHandler</code>","text":"<p>               Bases: <code>INodeHandler</code></p> <p>Adds assertions to the simulation. Enables users to verify that certain conditions in their simulations  are met. Assertions work differently depending on the assertion decorator used, but in general they use functions returning a boolean that get called by this handler and raise exceptions when they fail.</p> <p>Providers don't interact with this handler. It only consults the simulation status to validate the  registered assertions.</p> Source code in <code>gradysim/simulator/handler/assertion.py</code> <pre><code>class AssertionHandler(INodeHandler):\n    \"\"\"\n    Adds assertions to the simulation. Enables users to verify that certain conditions in their simulations \n    are met. Assertions work differently depending on the assertion decorator used, but in general they use\n    functions returning a boolean that get called by this handler and raise exceptions when they fail.\n\n    Providers don't interact with this handler. It only consults the simulation status to validate the \n    registered assertions.\n    \"\"\"\n    _event_loop: EventLoop\n    _nodes: List[Node]\n\n    def __init__(self, assertions: List[Type[SimulationTestCase]]):\n        \"\"\"\n        Constructs an assertion handler. The list of decorated assertions is received by parameter and will\n        be managed during the simulation.\n\n        Args:\n            assertions: List of decorated assertions\n        \"\"\"\n        self._assertions = [assertion() for assertion in assertions]\n        self._nodes = []\n\n    @staticmethod\n    def get_label() -&gt; str:\n        return \"assertion\"\n\n    def inject(self, event_loop: EventLoop) -&gt; None:\n        self._event_loop = event_loop\n\n    def register_node(self, node: Node) -&gt; None:\n        self._nodes.append(node)\n\n    def after_simulation_step(self, iteration: int, timestamp: float):\n        for assertion in self._assertions:\n            assertion.test_iteration(self._nodes, iteration, timestamp)\n\n    def finalize(self):\n        for assertion in self._assertions:\n            assertion.finalize()\n</code></pre>"},{"location":"Modules/Simulator/handlers/assertion/#gradysim.simulator.handler.assertion.AssertionHandler.__init__","title":"<code>__init__(assertions)</code>","text":"<p>Constructs an assertion handler. The list of decorated assertions is received by parameter and will be managed during the simulation.</p> <p>Parameters:</p> Name Type Description Default <code>assertions</code> <code>List[Type[SimulationTestCase]]</code> <p>List of decorated assertions</p> required Source code in <code>gradysim/simulator/handler/assertion.py</code> <pre><code>def __init__(self, assertions: List[Type[SimulationTestCase]]):\n    \"\"\"\n    Constructs an assertion handler. The list of decorated assertions is received by parameter and will\n    be managed during the simulation.\n\n    Args:\n        assertions: List of decorated assertions\n    \"\"\"\n    self._assertions = [assertion() for assertion in assertions]\n    self._nodes = []\n</code></pre>"},{"location":"Modules/Simulator/handlers/assertion/#creating-assertions","title":"Creating assertions","text":"<p>Assertions can be created using one of the provided assertion decorators. They should be applied to a function implementing the condition you wish to verify is met during the  simulation. </p> <p>The parameters received by the decorated function changes depending on the decorator being used, but a common characteristic is that they always should return a Boolean, indicating whether the condition is met or not.</p> <p>Here is an example of how a function is decorated to generate an assertion:</p> <pre><code>@assert_always_true_for_simulation(name=\"received_equals_sent\")\ndef assert_received_equals_sent(nodes: List[Node[PingProtocol]]) -&gt; bool:\n    received = 0\n    sent = 0\n    for node in nodes:\n        received += node.protocol_encapsulator.protocol.received\n        sent += node.protocol_encapsulator.protocol.received\n    return received == sent\n</code></pre>"},{"location":"Modules/Simulator/handlers/assertion/#gradysim.simulator.handler.assertion.assert_always_true_for_protocol","title":"<code>gradysim.simulator.handler.assertion.assert_always_true_for_protocol(protocol_type, name, description='')</code>","text":"<p>Creates a decorator that will wrap any function receiving a Node and returning a boolean into a assertion. If at any point the function returns False the assertion will fail.</p> <p>The assertion function should recieve a single Node instance with a specific protocol type and  return True if the assertion is succesfull and False otherwise.</p> <p>Function should be of type <code>Callable[[Node], bool]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>protocol_type</code> <code>Type[P]</code> <p>Type of protocol that this assertion applies to. Will be called for every node of that type.</p> required <code>name</code> <code>str</code> <p>Name of the assertion, used to identify the assertion</p> required <code>description</code> <code>str</code> <p>Optional description used in logging</p> <code>''</code> Source code in <code>gradysim/simulator/handler/assertion.py</code> <pre><code>def assert_always_true_for_protocol(protocol_type: Type[P],\n                                    name: str,\n                                    description: str = \"\") -&gt; Callable[[], Type[SimulationTestCase]]:\n    \"\"\"\n    Creates a decorator that will wrap any function receiving a Node and returning a boolean into a\n    assertion. If at any point the function returns False the assertion will fail.\n\n    The assertion function should recieve a single Node instance with a specific protocol type and \n    return True if the assertion is succesfull and False otherwise.\n\n     Function should be of type `Callable[[Node], bool]`.\n\n    Args:\n        protocol_type: Type of protocol that this assertion applies to. Will be called for every node of that type.\n        name: Name of the assertion, used to identify the assertion\n        description: Optional description used in logging\n    \"\"\"\n    def decorator(func: Callable[[Node[P]], bool]) -&gt; Type[SimulationTestCase]:\n        nonlocal name\n        if name is None:\n            name = func.__name__\n\n        class TestCase(SimulationTestCase):\n            def test_iteration(self, nodes: List[Node[P]], iteration: int, timestamp: float):\n                for node in nodes:\n                    if isinstance(node.protocol_encapsulator.protocol, protocol_type):\n                        if not func(node):\n                            description_string = \"(\" + description + \") \" if description != \"\" else \"\"\n                            raise FailedAssertionException(f\"Assertion \\\"{name}\\\" {description_string}failed \"\n                                                           f\"[iteration={iteration} | timestamp={timestamp}]\")\n\n            def finalize(self):\n                pass\n\n        return TestCase\n\n    return decorator\n</code></pre>"},{"location":"Modules/Simulator/handlers/assertion/#gradysim.simulator.handler.assertion.assert_eventually_true_for_protocol","title":"<code>gradysim.simulator.handler.assertion.assert_eventually_true_for_protocol(protocol_type, name, description='')</code>","text":"<p>Creates a decorator that will wrap any function receiving a Node and returning a boolean into a assertion. If at any point in the simulation the function returns True for a node the assertion will succeed for that node.</p> <p>The assertion function should recieve a single Node instance with a specific protocol type and  return True if the assertion is succesfull and False otherwise.</p> <p>Function should be of type <code>Callable[[Node], bool]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>protocol_type</code> <code>Type[IProtocol]</code> <p>Type of protocol that this assertion applies to. Will be called for every node of that type.</p> required <code>name</code> <code>str</code> <p>Name of the assertion, used to identify the assertion</p> required <code>description</code> <code>str</code> <p>Optional description used in logging</p> <code>''</code> Source code in <code>gradysim/simulator/handler/assertion.py</code> <pre><code>def assert_eventually_true_for_protocol(protocol_type: Type[IProtocol],\n                                        name: str,\n                                        description: str = \"\") -&gt; Callable[[], Type[SimulationTestCase]]:\n    \"\"\"\n    Creates a decorator that will wrap any function receiving a Node and returning a boolean into a\n    assertion. If at any point in the simulation the function returns True for a node the assertion\n    will succeed for that node.\n\n    The assertion function should recieve a single Node instance with a specific protocol type and \n    return True if the assertion is succesfull and False otherwise.\n\n    Function should be of type `Callable[[Node], bool]`.\n\n    Args:\n        protocol_type: Type of protocol that this assertion applies to. Will be called for every node of that type.\n        name: Name of the assertion, used to identify the assertion\n        description: Optional description used in logging\n    \"\"\"\n\n    def decorator(func: Callable[[Node], bool]) -&gt; Type[SimulationTestCase]:\n        nonlocal name\n        if name is None:\n            name = func.__name__\n\n        class TestCase(SimulationTestCase):\n            has_been_true: Dict[int, bool]\n\n            def __init__(self):\n                self.has_been_true = {}\n\n            def test_iteration(self, nodes: List[Node], iteration: int, timestamp: float):\n                for node in nodes:\n                    if isinstance(node.protocol_encapsulator.protocol, protocol_type):\n                        if node.id not in self.has_been_true:\n                            self.has_been_true[node.id] = False\n                        if func(node):\n                            self.has_been_true[node.id] = True\n\n            def finalize(self):\n                for node, has_been in self.has_been_true.items():\n                    if not has_been:\n                        description_string = \"(\" + description + \") \" if description != \"\" else \"\"\n                        raise FailedAssertionException(\n                            f\"Assertion \\\"{name}\\\" {description_string} failed in node {node}\\n\"\n                            f\"The condition was never met during the simulation\")\n\n        return TestCase\n\n    return decorator\n</code></pre>"},{"location":"Modules/Simulator/handlers/assertion/#gradysim.simulator.handler.assertion.assert_always_true_for_simulation","title":"<code>gradysim.simulator.handler.assertion.assert_always_true_for_simulation(name, description='')</code>","text":"<p>Creates a decorator that will wrap any function receiving all Nodes and returning a boolean into a assertion. If at any point in the simulation this function returns False, the assertion fails.</p> <p>The assertion function should recieve a Node list and return True if the assertion is succesfull  and False otherwise.</p> <p>Function should be of type <code>Callable[[List[Node]], bool]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the assertion, used to identify the assertion</p> required <code>description</code> <code>str</code> <p>Optional description used in logging</p> <code>''</code> Source code in <code>gradysim/simulator/handler/assertion.py</code> <pre><code>def assert_always_true_for_simulation(name: str,\n                                      description: str = \"\") -&gt; Callable[[], Type[SimulationTestCase]]:\n    \"\"\"\n    Creates a decorator that will wrap any function receiving all Nodes and returning a boolean into a\n    assertion. If at any point in the simulation this function returns False, the assertion fails.\n\n    The assertion function should recieve a Node list and return True if the assertion is succesfull \n    and False otherwise.\n\n    Function should be of type `Callable[[List[Node]], bool]`.\n\n    Args:\n        name: Name of the assertion, used to identify the assertion\n        description: Optional description used in logging\n    \"\"\"\n    def decorator(func: Callable[[List[Node]], bool]) -&gt; Type[SimulationTestCase]:\n        nonlocal name\n        if name is None:\n            name = func.__name__\n\n        class TestCase(SimulationTestCase):\n            def test_iteration(self, nodes: List[Node], iteration: int, timestamp: float):\n                if not func(nodes):\n                    description_string = \"(\" + description + \") \" if description != \"\" else \"\"\n                    raise FailedAssertionException(f\"Assertion \\\"{name}\\\" {description_string}failed\\n\"\n                                                   f\"[iteration={iteration} | timestamp={timestamp}]\\n\")\n\n            def finalize(self):\n                pass\n\n        return TestCase\n\n    return decorator\n</code></pre>"},{"location":"Modules/Simulator/handlers/assertion/#gradysim.simulator.handler.assertion.assert_eventually_true_for_simulation","title":"<code>gradysim.simulator.handler.assertion.assert_eventually_true_for_simulation(name, description='')</code>","text":"<p>Creates a decorator that will wrap any function receiving all Nodes and returning a boolean into a assertion. If at any point in the simulation this function returns True, the assertion succeeds.</p> <p>The assertion function should recieve a Node list and return True if the assertion is succesfull  and False otherwise.</p> <p>Function should be of type <code>Callable[[List[Node]], bool]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the assertion, used to identify the assertion</p> required <code>description</code> <code>str</code> <p>Optional description used in logging</p> <code>''</code> Source code in <code>gradysim/simulator/handler/assertion.py</code> <pre><code>def assert_eventually_true_for_simulation(name: str,\n                                          description: str = \"\") -&gt; Callable[[], Type[SimulationTestCase]]:\n    \"\"\"\n    Creates a decorator that will wrap any function receiving all Nodes and returning a boolean into a\n    assertion. If at any point in the simulation this function returns True, the assertion succeeds.\n\n    The assertion function should recieve a Node list and return True if the assertion is succesfull \n    and False otherwise.\n\n    Function should be of type `Callable[[List[Node]], bool]`.\n\n    Args:\n        name: Name of the assertion, used to identify the assertion\n        description: Optional description used in logging\n    \"\"\"\n    def decorator(func: Callable[[List[Node]], bool]) -&gt; Type[SimulationTestCase]:\n        nonlocal name\n        if name is None:\n            name = func.__name__\n\n        class TestCase(SimulationTestCase):\n            has_been_true = False\n\n            def test_iteration(self, nodes: List[Node], iteration: int, timestamp: float):\n                if func(nodes):\n                    self.has_been_true = True\n\n            def finalize(self):\n                if not self.has_been_true:\n                    description_string = \"(\" + description + \") \" if description != \"\" else \"\"\n                    raise FailedAssertionException(f\"Assertion \\\"{name}\\\" {description_string}failed\\n\"\n                                                   f\"The condition was never met during the simulation\")\n\n        return TestCase\n\n    return decorator\n</code></pre>"},{"location":"Modules/Simulator/handlers/communication/","title":"Communication","text":""},{"location":"Modules/Simulator/handlers/communication/#gradysim.simulator.handler.communication.CommunicationHandler","title":"<code>gradysim.simulator.handler.communication.CommunicationHandler</code>","text":"<p>               Bases: <code>INodeHandler</code></p> <p>Adds communication to the simulation. Nodes, through their providers, can send this handler communication commands that dictate how a message should be sent. This message will be delivered to the destination node.</p> <p>Messages are transmited through a medium that determines conditions like communication range and failure rate. Messages can fail to be delivered or  be delivered late.</p> Source code in <code>gradysim/simulator/handler/communication.py</code> <pre><code>class CommunicationHandler(INodeHandler):\n    \"\"\"\n    Adds communication to the simulation. Nodes, through their providers, can\n    send this handler communication commands that dictate how a message should\n    be sent. This message will be delivered to the destination node.\n\n    Messages are transmited through a [medium][gradysim.simulator.handler.communication.CommunicationMedium] that\n    determines conditions like communication range and failure rate. Messages can fail to be delivered or \n    be delivered late.\n    \"\"\"\n    @staticmethod\n    def get_label() -&gt; str:\n        return \"communication\"\n\n    _sources: Dict[int, CommunicationSource]\n    _destinations: Dict[int, CommunicationDestination]\n    _event_loop: EventLoop\n\n    def __init__(self, communication_medium: CommunicationMedium = CommunicationMedium()):\n        \"\"\"\n        Initializes the communication handler.\n\n        Args:\n            communication_medium: Configuration of the network conditions. If not set all default values will be used.\n        \"\"\"\n        self._injected = False\n\n        self._sources: Dict[int, CommunicationSource] = {}\n        self._destinations: Dict[int, CommunicationDestination] = {}\n\n        self.transmission_ranges: Dict[int, float] = {}\n        self.communication_medium = communication_medium\n\n    def inject(self, event_loop: EventLoop):\n        self._injected = True\n        self._event_loop = event_loop\n\n    def register_node(self, node: Node):\n        if not self._injected:\n            raise CommunicationException(\"Error registering node: Cannot register node on uninitialized \"\n                                         \"node handler\")\n        self._sources[node.id] = CommunicationSource(node)\n        self._destinations[node.id] = CommunicationDestination(node)\n        self.transmission_ranges[node.id] = self.communication_medium.transmission_range\n\n    def handle_command(self, command: CommunicationCommand, sender: Node):\n        \"\"\"\n        Performs a communication command. This method should be called by the node's\n        provider to transmit a communication command to the communication handler.\n\n        Args:\n            command: Command being issued\n            sender: Node issuing the command\n        \"\"\"\n        if sender.id == command.destination:\n            raise CommunicationException(\"Error transmitting message: message destination is equal to sender. Try \"\n                                         \"using schedule_timer.\")\n\n        source = self._sources[sender.id]\n\n        if command.command_type == CommunicationCommandType.BROADCAST:\n            for destination, endpoint in self._destinations.items():\n                if destination != sender.id:\n                    self._transmit_message(command.message, source, endpoint)\n        else:\n            destination = command.destination\n            if destination is None:\n                raise CommunicationException(\"Error transmitting message: a destination is \"\n                                             \"required when command type SEND is used.\")\n            if destination not in self._destinations:\n                raise CommunicationException(f\"Error transmitting message: destination {destination} does not exist.\")\n\n            self._transmit_message(command.message, source, self._destinations[destination])\n\n    def can_transmit(self, source_position: Position, destination_position: Position,\n                     node: Node):\n        squared_distance = (destination_position[0] - source_position[0]) ** 2 + \\\n                           (destination_position[1] - source_position[1]) ** 2 + \\\n                           (destination_position[2] - source_position[2]) ** 2\n        in_range = squared_distance &lt;= self.transmission_ranges[node.id] ** 2\n\n        rng = True\n        if self.communication_medium.failure_rate &gt; 0:\n            rng = random.random() &gt; self.communication_medium.failure_rate\n        return rng and in_range\n\n    def _transmit_message(self, message: str, source: CommunicationSource, destination: CommunicationDestination):\n        source.hand_over_message(message, destination)\n\n        if self.can_transmit(source.node.position, destination.node.position, source.node):\n            if self.communication_medium.delay &lt;= 0:\n                self._event_loop.schedule_event(\n                    self._event_loop.current_time,\n                    lambda: destination.receive_message(message, source),\n                    label_node(destination.node) + \" handle_packet\"\n                )\n            else:\n                self._event_loop.schedule_event(\n                    self._event_loop.current_time + self.communication_medium.delay,\n                    lambda: destination.receive_message(message, source),\n                    label_node(destination.node) + \" handle_packet\"\n                )\n</code></pre>"},{"location":"Modules/Simulator/handlers/communication/#gradysim.simulator.handler.communication.CommunicationHandler.__init__","title":"<code>__init__(communication_medium=CommunicationMedium())</code>","text":"<p>Initializes the communication handler.</p> <p>Parameters:</p> Name Type Description Default <code>communication_medium</code> <code>CommunicationMedium</code> <p>Configuration of the network conditions. If not set all default values will be used.</p> <code>CommunicationMedium()</code> Source code in <code>gradysim/simulator/handler/communication.py</code> <pre><code>def __init__(self, communication_medium: CommunicationMedium = CommunicationMedium()):\n    \"\"\"\n    Initializes the communication handler.\n\n    Args:\n        communication_medium: Configuration of the network conditions. If not set all default values will be used.\n    \"\"\"\n    self._injected = False\n\n    self._sources: Dict[int, CommunicationSource] = {}\n    self._destinations: Dict[int, CommunicationDestination] = {}\n\n    self.transmission_ranges: Dict[int, float] = {}\n    self.communication_medium = communication_medium\n</code></pre>"},{"location":"Modules/Simulator/handlers/communication/#gradysim.simulator.handler.communication.CommunicationHandler.handle_command","title":"<code>handle_command(command, sender)</code>","text":"<p>Performs a communication command. This method should be called by the node's provider to transmit a communication command to the communication handler.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>CommunicationCommand</code> <p>Command being issued</p> required <code>sender</code> <code>Node</code> <p>Node issuing the command</p> required Source code in <code>gradysim/simulator/handler/communication.py</code> <pre><code>def handle_command(self, command: CommunicationCommand, sender: Node):\n    \"\"\"\n    Performs a communication command. This method should be called by the node's\n    provider to transmit a communication command to the communication handler.\n\n    Args:\n        command: Command being issued\n        sender: Node issuing the command\n    \"\"\"\n    if sender.id == command.destination:\n        raise CommunicationException(\"Error transmitting message: message destination is equal to sender. Try \"\n                                     \"using schedule_timer.\")\n\n    source = self._sources[sender.id]\n\n    if command.command_type == CommunicationCommandType.BROADCAST:\n        for destination, endpoint in self._destinations.items():\n            if destination != sender.id:\n                self._transmit_message(command.message, source, endpoint)\n    else:\n        destination = command.destination\n        if destination is None:\n            raise CommunicationException(\"Error transmitting message: a destination is \"\n                                         \"required when command type SEND is used.\")\n        if destination not in self._destinations:\n            raise CommunicationException(f\"Error transmitting message: destination {destination} does not exist.\")\n\n        self._transmit_message(command.message, source, self._destinations[destination])\n</code></pre>"},{"location":"Modules/Simulator/handlers/communication/#gradysim.simulator.handler.communication.CommunicationMedium","title":"<code>gradysim.simulator.handler.communication.CommunicationMedium</code>  <code>dataclass</code>","text":"<p>Conditions through which the messages are delivered. Can influence how and when messages can be delivered.</p> Source code in <code>gradysim/simulator/handler/communication.py</code> <pre><code>@dataclass\nclass CommunicationMedium:\n    \"\"\"\n    Conditions through which the messages are delivered. Can influence how and when messages can be delivered.\n    \"\"\"\n    transmission_range: float = 60\n    \"\"\"Maximum range in meters for message delivery. Messages destined to nodes outside this range will not be delivered\"\"\"\n\n    delay: float = 0\n    \"\"\"Sets a delay in seconds for message delivery, representing network delay. Range is evaluated before the delay is applied\"\"\"\n\n    failure_rate: float = 0\n    \"\"\"Failure chance between 0 and 1 for message delivery. 0 represents messages never failing and 1 always fails.\"\"\"\n</code></pre>"},{"location":"Modules/Simulator/handlers/communication/#gradysim.simulator.handler.communication.CommunicationMedium.delay","title":"<code>delay: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Sets a delay in seconds for message delivery, representing network delay. Range is evaluated before the delay is applied</p>"},{"location":"Modules/Simulator/handlers/communication/#gradysim.simulator.handler.communication.CommunicationMedium.failure_rate","title":"<code>failure_rate: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Failure chance between 0 and 1 for message delivery. 0 represents messages never failing and 1 always fails.</p>"},{"location":"Modules/Simulator/handlers/communication/#gradysim.simulator.handler.communication.CommunicationMedium.transmission_range","title":"<code>transmission_range: float = 60</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Maximum range in meters for message delivery. Messages destined to nodes outside this range will not be delivered</p>"},{"location":"Modules/Simulator/handlers/mobility/","title":"Mobility","text":""},{"location":"Modules/Simulator/handlers/mobility/#gradysim.simulator.handler.mobility.MobilityHandler","title":"<code>gradysim.simulator.handler.mobility.MobilityHandler</code>","text":"<p>               Bases: <code>INodeHandler</code></p> <p>Introduces mobility into the simulatuon. Works by registering a regular event that updates every node's position based on it's target and speed. A node, through it's provider, can sent this handler communication commands to alter it's behaviour including it's speed  and current target. Nodes also recieve telemetry updates containing information pertaining a node's current mobility status.</p> Source code in <code>gradysim/simulator/handler/mobility.py</code> <pre><code>class MobilityHandler(INodeHandler):\n    \"\"\"\n    Introduces mobility into the simulatuon. Works by registering a regular event that\n    updates every node's position based on it's target and speed. A node, through it's provider,\n    can sent this handler communication commands to alter it's behaviour including it's speed \n    and current target. Nodes also recieve telemetry updates containing information pertaining\n    a node's current mobility status.\n    \"\"\"\n\n    @staticmethod\n    def get_label() -&gt; str:\n        return \"mobility\"\n\n    _event_loop: EventLoop\n\n    nodes: Dict[int, Node]\n    targets: Dict[int, Position]\n    speeds: Dict[int, float]\n\n    def __init__(self, configuration: MobilityConfiguration = MobilityConfiguration()):\n        \"\"\"\n        Constructor for the mobility handler\n\n        Args:\n            configuration: Configuration for the mobility handler. If not set all default values will be used.\n        \"\"\"\n        self._configuration = configuration\n        self.nodes = {}\n        self.targets = {}\n        self.speeds = {}\n        self._injected = False\n\n    def inject(self, event_loop: EventLoop):\n        self._injected = True\n        self._event_loop = event_loop\n\n        event_loop.schedule_event(event_loop.current_time + self._configuration.update_rate,\n                                  self._update_movement,\n                                  \"Mobility\")\n\n    def register_node(self, node: Node):\n        if not self._injected:\n            raise MobilityException(\"Error registering node: cannot register nodes while mobility handler \"\n                                    \"is uninitialized.\")\n\n        self.nodes[node.id] = node\n        self.speeds[node.id] = self._configuration.default_speed\n\n    def _update_movement(self):\n        for node_id in self.nodes.keys():\n            node = self.nodes[node_id]\n\n            # If the node has a target update its position\n            if node_id in self.targets:\n                target = self.targets[node_id]\n                current_position = node.position\n                speed = self.speeds[node_id]\n                target_vector: Position = (target[0] - current_position[0],\n                                           target[1] - current_position[1],\n                                           target[2] - current_position[2])\n                movement_multiplier = speed * self._configuration.update_rate\n                distance_delta = math.sqrt(target_vector[0] ** 2 + target_vector[1] ** 2 + target_vector[2] ** 2)\n\n                if movement_multiplier &gt;= distance_delta:\n                    node.position = (\n                        target[0],\n                        target[1],\n                        target[2]\n                    )\n                else:\n                    target_vector_multiplier = movement_multiplier / distance_delta\n\n                    node.position = (\n                        current_position[0] + target_vector[0] * target_vector_multiplier,\n                        current_position[1] + target_vector[1] * target_vector_multiplier,\n                        current_position[2] + target_vector[2] * target_vector_multiplier\n                    )\n            telemetry = Telemetry(current_position=node.position)\n\n            def make_send_telemetry(node_ref, telemetry_ref):\n                return lambda: node_ref.protocol_encapsulator.handle_telemetry(telemetry_ref)\n\n            self._event_loop.schedule_event(\n                self._event_loop.current_time,\n                make_send_telemetry(node, telemetry),\n                label_node(node) + \" handle_telemetry\"\n            )\n\n        self._event_loop.schedule_event(self._event_loop.current_time + self._configuration.update_rate,\n                                        self._update_movement,\n                                        \"Mobility\")\n\n    def handle_command(self, command: MobilityCommand, node: Node):\n        \"\"\"\n        Performs a mobility command. This method is called by the node's \n        provider to transmit it's mobility command to the mobility handler.\n\n        Args:\n            command: Command being issued\n            node: Node that issued the command\n        \"\"\"\n        if node.id not in self.nodes:\n            raise MobilityException(\"Error handling commands: Cannot handle command from unregistered node\")\n\n        if command.command_type == MobilityCommandType.GOTO_COORDS:\n            self._goto((command.param_1, command.param_2, command.param_3), node)\n        elif command.command_type == MobilityCommandType.GOTO_GEO_COORDS:\n            relative_coords = geo_to_cartesian(self._configuration.reference_coordinates,\n                                               (command.param_1, command.param_2, command.param_3))\n            self._goto(relative_coords, node)\n        elif command.command_type == MobilityCommandType.SET_SPEED:\n            self.speeds[node.id] = command.param_1\n\n    def _goto(self, position: Position, node: Node):\n        self.targets[node.id] = position\n\n    def _stop(self, node: Node):\n        del self.targets[node.id]\n</code></pre>"},{"location":"Modules/Simulator/handlers/mobility/#gradysim.simulator.handler.mobility.MobilityHandler.__init__","title":"<code>__init__(configuration=MobilityConfiguration())</code>","text":"<p>Constructor for the mobility handler</p> <p>Parameters:</p> Name Type Description Default <code>configuration</code> <code>MobilityConfiguration</code> <p>Configuration for the mobility handler. If not set all default values will be used.</p> <code>MobilityConfiguration()</code> Source code in <code>gradysim/simulator/handler/mobility.py</code> <pre><code>def __init__(self, configuration: MobilityConfiguration = MobilityConfiguration()):\n    \"\"\"\n    Constructor for the mobility handler\n\n    Args:\n        configuration: Configuration for the mobility handler. If not set all default values will be used.\n    \"\"\"\n    self._configuration = configuration\n    self.nodes = {}\n    self.targets = {}\n    self.speeds = {}\n    self._injected = False\n</code></pre>"},{"location":"Modules/Simulator/handlers/mobility/#gradysim.simulator.handler.mobility.MobilityHandler.handle_command","title":"<code>handle_command(command, node)</code>","text":"<p>Performs a mobility command. This method is called by the node's  provider to transmit it's mobility command to the mobility handler.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>MobilityCommand</code> <p>Command being issued</p> required <code>node</code> <code>Node</code> <p>Node that issued the command</p> required Source code in <code>gradysim/simulator/handler/mobility.py</code> <pre><code>def handle_command(self, command: MobilityCommand, node: Node):\n    \"\"\"\n    Performs a mobility command. This method is called by the node's \n    provider to transmit it's mobility command to the mobility handler.\n\n    Args:\n        command: Command being issued\n        node: Node that issued the command\n    \"\"\"\n    if node.id not in self.nodes:\n        raise MobilityException(\"Error handling commands: Cannot handle command from unregistered node\")\n\n    if command.command_type == MobilityCommandType.GOTO_COORDS:\n        self._goto((command.param_1, command.param_2, command.param_3), node)\n    elif command.command_type == MobilityCommandType.GOTO_GEO_COORDS:\n        relative_coords = geo_to_cartesian(self._configuration.reference_coordinates,\n                                           (command.param_1, command.param_2, command.param_3))\n        self._goto(relative_coords, node)\n    elif command.command_type == MobilityCommandType.SET_SPEED:\n        self.speeds[node.id] = command.param_1\n</code></pre>"},{"location":"Modules/Simulator/handlers/mobility/#gradysim.simulator.handler.mobility.MobilityConfiguration","title":"<code>gradysim.simulator.handler.mobility.MobilityConfiguration</code>  <code>dataclass</code>","text":"<p>Configuration class for the mobility handler</p> Source code in <code>gradysim/simulator/handler/mobility.py</code> <pre><code>@dataclass\nclass MobilityConfiguration:\n    \"\"\"\n    Configuration class for the mobility handler\n    \"\"\"\n\n    update_rate: float = 0.01\n    \"\"\"Interval in simulation seconds between mobility updates\"\"\"\n\n    default_speed: float = 10\n    \"\"\"This is the default speed of a node in m/s\"\"\"\n\n    reference_coordinates: Tuple[float, float, float] = (0, 0, 0)\n    \"\"\"\n    These coordinates are used as a reference frame to convert geographical coordinates to cartesian coordinates. They\n    will be used as the center of the scene and all geographical coordinates will be converted relative to it.\n    \"\"\"\n</code></pre>"},{"location":"Modules/Simulator/handlers/mobility/#gradysim.simulator.handler.mobility.MobilityConfiguration.default_speed","title":"<code>default_speed: float = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>This is the default speed of a node in m/s</p>"},{"location":"Modules/Simulator/handlers/mobility/#gradysim.simulator.handler.mobility.MobilityConfiguration.reference_coordinates","title":"<code>reference_coordinates: Tuple[float, float, float] = (0, 0, 0)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>These coordinates are used as a reference frame to convert geographical coordinates to cartesian coordinates. They will be used as the center of the scene and all geographical coordinates will be converted relative to it.</p>"},{"location":"Modules/Simulator/handlers/mobility/#gradysim.simulator.handler.mobility.MobilityConfiguration.update_rate","title":"<code>update_rate: float = 0.01</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Interval in simulation seconds between mobility updates</p>"},{"location":"Modules/Simulator/handlers/timer/","title":"Timer","text":""},{"location":"Modules/Simulator/handlers/timer/#gradysim.simulator.handler.timer.TimerHandler","title":"<code>gradysim.simulator.handler.timer.TimerHandler</code>","text":"<p>               Bases: <code>INodeHandler</code></p> <p>Adds timers to the simulation. This allows nodes to set timers which is a very important feature when implementing distributed algorithms. Nodes can schedule timers through their providers.</p> Source code in <code>gradysim/simulator/handler/timer.py</code> <pre><code>class TimerHandler(INodeHandler):\n    \"\"\"\n    Adds timers to the simulation. This allows nodes to set timers\n    which is a very important feature when implementing distributed\n    algorithms. Nodes can schedule timers through their providers.\n    \"\"\"\n    _event_loop: EventLoop\n\n    _timer_id: int\n    _pending_timers: Dict[int, Dict[str, Set[int]]]\n    \"\"\"Timers pending for each node. A dict of nodes where the value is a dict of messages and their identifiers.\"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Constructs a TimerHandler, no configuration is necessary.\n        \"\"\"\n        self._registed_nodes: Set[Node] = set()\n        self._timer_id = 0\n        self._pending_timers = defaultdict(lambda : defaultdict(set))\n\n    def get_current_time(self):\n        return self._event_loop.current_time\n\n    @staticmethod\n    def get_label() -&gt; str:\n        return \"timer\"\n\n    def inject(self, event_loop: EventLoop) -&gt; None:\n        self._event_loop = event_loop\n\n    def register_node(self, node: Node) -&gt; None:\n        self._registed_nodes.add(node)\n\n    def fire_timer(self, message: str, node: Node, identifier: int):\n        \"\"\"\n        Fires a timer. Should be called by the event loop.\n        \"\"\"\n        if identifier not in self._pending_timers[node.id][message]:\n            return\n\n        node.protocol_encapsulator.handle_timer(message)\n        self._pending_timers[node.id][message].remove(identifier)\n\n    def set_timer(self, message: str, timestamp: float, node: Node):\n        \"\"\"\n        Sets a timer. Should be called by the nodes' providers. Node needs to be\n        registered and timer needs to be set in the future.\n        \"\"\"\n        if node not in self._registed_nodes:\n            raise TimerException(f\"Could not set timer: Node {node.id} not registered\")\n\n        if timestamp &lt; self._event_loop.current_time:\n            raise TimerException(\"Could not set timer: Timer cannot be set in the past\")\n\n        identifier = self._timer_id\n        self._event_loop.schedule_event(timestamp,\n                                        lambda: self.fire_timer(message, node, identifier),\n                                        label_node(node) + \" handle_timer\")\n        self._pending_timers[node.id][message].add(identifier)\n        self._timer_id += 1\n\n    def cancel_timer(self, message: str, node: Node):\n        \"\"\"\n        Cancels a timer. Should be called by the nodes' providers. Node needs to be\n        registered.\n        \"\"\"\n        if node not in self._registed_nodes:\n            raise TimerException(f\"Could not cancel timer: Node {node.id} not registered\")\n\n        self._pending_timers[node.id][message].clear()\n</code></pre>"},{"location":"Modules/Simulator/handlers/timer/#gradysim.simulator.handler.timer.TimerHandler.__init__","title":"<code>__init__()</code>","text":"<p>Constructs a TimerHandler, no configuration is necessary.</p> Source code in <code>gradysim/simulator/handler/timer.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Constructs a TimerHandler, no configuration is necessary.\n    \"\"\"\n    self._registed_nodes: Set[Node] = set()\n    self._timer_id = 0\n    self._pending_timers = defaultdict(lambda : defaultdict(set))\n</code></pre>"},{"location":"Modules/Simulator/handlers/timer/#gradysim.simulator.handler.timer.TimerHandler.cancel_timer","title":"<code>cancel_timer(message, node)</code>","text":"<p>Cancels a timer. Should be called by the nodes' providers. Node needs to be registered.</p> Source code in <code>gradysim/simulator/handler/timer.py</code> <pre><code>def cancel_timer(self, message: str, node: Node):\n    \"\"\"\n    Cancels a timer. Should be called by the nodes' providers. Node needs to be\n    registered.\n    \"\"\"\n    if node not in self._registed_nodes:\n        raise TimerException(f\"Could not cancel timer: Node {node.id} not registered\")\n\n    self._pending_timers[node.id][message].clear()\n</code></pre>"},{"location":"Modules/Simulator/handlers/timer/#gradysim.simulator.handler.timer.TimerHandler.fire_timer","title":"<code>fire_timer(message, node, identifier)</code>","text":"<p>Fires a timer. Should be called by the event loop.</p> Source code in <code>gradysim/simulator/handler/timer.py</code> <pre><code>def fire_timer(self, message: str, node: Node, identifier: int):\n    \"\"\"\n    Fires a timer. Should be called by the event loop.\n    \"\"\"\n    if identifier not in self._pending_timers[node.id][message]:\n        return\n\n    node.protocol_encapsulator.handle_timer(message)\n    self._pending_timers[node.id][message].remove(identifier)\n</code></pre>"},{"location":"Modules/Simulator/handlers/timer/#gradysim.simulator.handler.timer.TimerHandler.set_timer","title":"<code>set_timer(message, timestamp, node)</code>","text":"<p>Sets a timer. Should be called by the nodes' providers. Node needs to be registered and timer needs to be set in the future.</p> Source code in <code>gradysim/simulator/handler/timer.py</code> <pre><code>def set_timer(self, message: str, timestamp: float, node: Node):\n    \"\"\"\n    Sets a timer. Should be called by the nodes' providers. Node needs to be\n    registered and timer needs to be set in the future.\n    \"\"\"\n    if node not in self._registed_nodes:\n        raise TimerException(f\"Could not set timer: Node {node.id} not registered\")\n\n    if timestamp &lt; self._event_loop.current_time:\n        raise TimerException(\"Could not set timer: Timer cannot be set in the past\")\n\n    identifier = self._timer_id\n    self._event_loop.schedule_event(timestamp,\n                                    lambda: self.fire_timer(message, node, identifier),\n                                    label_node(node) + \" handle_timer\")\n    self._pending_timers[node.id][message].add(identifier)\n    self._timer_id += 1\n</code></pre>"},{"location":"Modules/Simulator/handlers/visualization/","title":"Visualization","text":""},{"location":"Modules/Simulator/handlers/visualization/#gradysim.simulator.handler.visualization","title":"<code>gradysim.simulator.handler.visualization</code>","text":"<p>This handler adds visualization to the simulation. It shows regularly updated node positions in a graphical representation of the simulation. This graphical representation is web-based and can be accessed via a browser through this link. When the simulation starts running a WebSocket server is started which the browser connects to. The browser then displays the simulation in a 3D environment. The visualization is updated regularly with the current node positions and other information.</p> <p>Danger</p> <p>The visualization handler uses a separate process to run the WebSocket server, this means that on Windows your script will be rerun when the new process starts. This means that any code that should not be run multiple times should be put in the <code>if __name__ == \"__main__\"</code> block.</p>"},{"location":"Modules/Simulator/handlers/visualization/#gradysim.simulator.handler.visualization.VisualizationConfiguration","title":"<code>VisualizationConfiguration</code>  <code>dataclass</code>","text":"<p>Configuration for the VisualizationHandler</p> Source code in <code>gradysim/simulator/handler/visualization.py</code> <pre><code>@dataclass\nclass VisualizationConfiguration:\n    \"\"\"\n    Configuration for the VisualizationHandler\n    \"\"\"\n\n    information_collection_interval: float = 0.01\n    \"\"\"\n    Interval in simulation seconds between visualization information update. Beware that this is not the frequency\n    at which the visualization is updated in the browser, but the frequency at which data is collected from the \n    running simulation. You can change the broser update frequency with the `update_rate` parameter.\n    \"\"\"\n\n    update_rate: float = 0.05\n    \"\"\"\n    Rate in seconds at which the visualization is updated in the browser. This is the frequency at which the browser\n    receives the information from the simulation.\n    \"\"\"\n\n    x_range: Tuple[float, float] = (-50, 50)\n    \"\"\"Range of the X axis of the visualization in meters\"\"\"\n\n    y_range: Tuple[float, float] = (-50, 50)\n    \"\"\"Range of the Y axis of the visualization in meters\"\"\"\n\n    z_range: Tuple[float, float] = (0, 50)\n    \"\"\"Range of the Z axis of the visualization in meters\"\"\"\n\n    host: str = \"localhost\"\n    \"\"\"Host address of the visualization server\"\"\"\n\n    port: int = 5678\n    \"\"\"Port that the visualization server will run in\"\"\"\n\n    open_browser: bool = False\n    \"\"\"Whether to open the browser automatically when the simulation starts\"\"\"\n</code></pre>"},{"location":"Modules/Simulator/handlers/visualization/#gradysim.simulator.handler.visualization.VisualizationConfiguration.host","title":"<code>host: str = 'localhost'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Host address of the visualization server</p>"},{"location":"Modules/Simulator/handlers/visualization/#gradysim.simulator.handler.visualization.VisualizationConfiguration.information_collection_interval","title":"<code>information_collection_interval: float = 0.01</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Interval in simulation seconds between visualization information update. Beware that this is not the frequency at which the visualization is updated in the browser, but the frequency at which data is collected from the  running simulation. You can change the broser update frequency with the <code>update_rate</code> parameter.</p>"},{"location":"Modules/Simulator/handlers/visualization/#gradysim.simulator.handler.visualization.VisualizationConfiguration.open_browser","title":"<code>open_browser: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to open the browser automatically when the simulation starts</p>"},{"location":"Modules/Simulator/handlers/visualization/#gradysim.simulator.handler.visualization.VisualizationConfiguration.port","title":"<code>port: int = 5678</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Port that the visualization server will run in</p>"},{"location":"Modules/Simulator/handlers/visualization/#gradysim.simulator.handler.visualization.VisualizationConfiguration.update_rate","title":"<code>update_rate: float = 0.05</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Rate in seconds at which the visualization is updated in the browser. This is the frequency at which the browser receives the information from the simulation.</p>"},{"location":"Modules/Simulator/handlers/visualization/#gradysim.simulator.handler.visualization.VisualizationConfiguration.x_range","title":"<code>x_range: Tuple[float, float] = (-50, 50)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Range of the X axis of the visualization in meters</p>"},{"location":"Modules/Simulator/handlers/visualization/#gradysim.simulator.handler.visualization.VisualizationConfiguration.y_range","title":"<code>y_range: Tuple[float, float] = (-50, 50)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Range of the Y axis of the visualization in meters</p>"},{"location":"Modules/Simulator/handlers/visualization/#gradysim.simulator.handler.visualization.VisualizationConfiguration.z_range","title":"<code>z_range: Tuple[float, float] = (0, 50)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Range of the Z axis of the visualization in meters</p>"},{"location":"Modules/Simulator/handlers/visualization/#gradysim.simulator.handler.visualization.VisualizationHandler","title":"<code>VisualizationHandler</code>","text":"<p>               Bases: <code>INodeHandler</code></p> <p>Adds visualization to the simulation. Shows regularly updated node position and other simulation information in a graphical representation of the simulation. The graphical representation is web-based and can be accessed via a browser through this link.</p> <p>The visualization handler uses a separate process to run the WebSocket server, on Windows your script will be rerun when the new process starts. This means that any code that should not be run multiple times should be put in the <code>if __name__ == \"__main__\"</code> block.</p> Source code in <code>gradysim/simulator/handler/visualization.py</code> <pre><code>class VisualizationHandler(INodeHandler):\n    \"\"\"\n    Adds visualization to the simulation. Shows regularly updated node position and other simulation information\n    in a graphical representation of the simulation. The graphical representation is web-based and can be accessed\n    via a browser through [this link](https://project-gradys.github.io/gradys-sim-nextgen-visualization/).\n\n    The visualization handler uses a separate process to run the WebSocket server, on Windows your\n    script will be rerun when the new process starts. This means that any code that should not be run multiple times\n    should be put in the `if __name__ == \"__main__\"` block.\n    \"\"\"\n    _event_loop: EventLoop\n    _nodes: List[Node]\n    _information: _VisualizationInformation\n    _visualization_state: _VisualizationState\n    _information_thread: multiprocessing.Process\n    _start_time: float\n    command_queue: multiprocessing.Queue\n\n    def __init__(self, configuration: VisualizationConfiguration = VisualizationConfiguration()):\n        \"\"\"\n        Constructs the visualization handler.\n\n        Args:\n            configuration: Configuration for the visualization handler. If not set all default values will be used.\n        \"\"\"\n        self._nodes = []\n\n        # Current simulation information shared with the visualization server\n        manager = multiprocessing.Manager()\n        self._information = manager.dict()\n        self._visualization_state = manager.dict()\n        self.command_queue = manager.Queue()\n        self._visualization_state[\"paused\"] = False\n\n        self._configuration = configuration\n\n        self._logger = logging.getLogger()\n\n        global _active_handler\n        _active_handler = self\n\n    @staticmethod\n    def get_label() -&gt; str:\n        return \"visualization\"\n\n    def inject(self, event_loop: EventLoop) -&gt; None:\n        self._event_loop = event_loop\n\n        self._event_loop.schedule_event(self._event_loop.current_time + self._configuration.information_collection_interval,\n                                        self._report_information,\n                                        \"Visualization\")\n\n    def initialize(self) -&gt; None:\n        initialization_information = {\n            \"x_range\": self._configuration.x_range,\n            \"y_range\": self._configuration.y_range,\n            \"z_range\": self._configuration.z_range,\n            \"nodes\": [label_node(node) for node in self._nodes],\n        }\n\n        # Initialize with precise CPU timestamp of simulation's start\n        # does not use event loop\n        self._start_time = time.time()\n\n        self._information_thread = multiprocessing.Process(target=_visualization_thread,\n                                                           args=(self._configuration,\n                                                                 initialization_information,\n                                                                 self._information,\n                                                                 self._visualization_state,\n                                                                 self.command_queue))\n        self._information_thread.start()\n\n    def finalize(self) -&gt; None:\n        self._information_thread.terminate()\n\n    def register_node(self, node: Node) -&gt; None:\n        self._nodes.append(node)\n\n    def _report_information(self) -&gt; None:\n        self._information[\"nodes\"] = [node.id for node in self._nodes]\n        self._information[\"positions\"] = [node.position for node in self._nodes]\n        self._information[\"simulation_time\"] = self._event_loop.current_time\n        self._information[\"real_time\"] = time.time() - self._start_time\n        self._information[\"tracked_variables\"] = \\\n            [node.protocol_encapsulator.protocol.provider.tracked_variables.copy() for node in self._nodes]\n\n        if self._visualization_state[\"paused\"]:\n            logging.info(\"Visualization paused by user\")\n\n            while self._visualization_state[\"paused\"]:\n                time.sleep(0.1)\n\n            logging.info(\"Visualization resumed by user\")\n\n        self._event_loop.schedule_event(\n            self._event_loop.current_time + self._configuration.information_collection_interval,\n            self._report_information,\n            \"Visualization\"\n        )\n</code></pre>"},{"location":"Modules/Simulator/handlers/visualization/#gradysim.simulator.handler.visualization.VisualizationHandler.__init__","title":"<code>__init__(configuration=VisualizationConfiguration())</code>","text":"<p>Constructs the visualization handler.</p> <p>Parameters:</p> Name Type Description Default <code>configuration</code> <code>VisualizationConfiguration</code> <p>Configuration for the visualization handler. If not set all default values will be used.</p> <code>VisualizationConfiguration()</code> Source code in <code>gradysim/simulator/handler/visualization.py</code> <pre><code>def __init__(self, configuration: VisualizationConfiguration = VisualizationConfiguration()):\n    \"\"\"\n    Constructs the visualization handler.\n\n    Args:\n        configuration: Configuration for the visualization handler. If not set all default values will be used.\n    \"\"\"\n    self._nodes = []\n\n    # Current simulation information shared with the visualization server\n    manager = multiprocessing.Manager()\n    self._information = manager.dict()\n    self._visualization_state = manager.dict()\n    self.command_queue = manager.Queue()\n    self._visualization_state[\"paused\"] = False\n\n    self._configuration = configuration\n\n    self._logger = logging.getLogger()\n\n    global _active_handler\n    _active_handler = self\n</code></pre>"}]}